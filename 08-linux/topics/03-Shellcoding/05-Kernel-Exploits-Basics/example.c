/*
 * OBJECTIF  : Comprendre les bases de l'exploitation kernel Linux
 * PREREQUIS : Bases C, syscalls, privilege levels, /proc
 * COMPILE   : gcc -o example example.c
 *
 * Ce programme demontre les concepts fondamentaux de l'exploitation
 * kernel : espace user vs kernel, interfaces d'attaque, et les
 * mecanismes de privilege escalation au niveau kernel.
 * Demonstration pedagogique - pas d'exploitation reelle.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <errno.h>

/*
 * Etape 1 : User space vs Kernel space
 */
static void explain_user_kernel(void) {
    printf("[*] Etape 1 : User space vs Kernel space\n\n");

    printf("    ┌───────────────────────────────────────────┐\n");
    printf("    │           USER SPACE (Ring 3)             │\n");
    printf("    │  ┌─────────┐ ┌─────────┐ ┌─────────┐     │\n");
    printf("    │  │ Process │ │ Process │ │ Process │     │\n");
    printf("    │  │  (bash) │ │ (nginx) │ │  (you)  │     │\n");
    printf("    │  └────┬────┘ └────┬────┘ └────┬────┘     │\n");
    printf("    │       │           │           │           │\n");
    printf("    │  syscall()   syscall()   syscall()        │\n");
    printf("    ├───────┼───────────┼───────────┼───────────┤\n");
    printf("    │       v           v           v           │\n");
    printf("    │           KERNEL SPACE (Ring 0)           │\n");
    printf("    │  ┌──────────────────────────────────┐     │\n");
    printf("    │  │  Syscall table, drivers, FS,     │     │\n");
    printf("    │  │  network stack, memory mgmt      │     │\n");
    printf("    │  │  ACCES TOTAL A LA MACHINE        │     │\n");
    printf("    │  └──────────────────────────────────┘     │\n");
    printf("    └───────────────────────────────────────────┘\n\n");

    printf("    Objectif d'un kernel exploit : passer de Ring 3 a Ring 0\n");
    printf("    -> Execution de code avec les privileges du kernel\n");
    printf("    -> Escalade root via commit_creds(prepare_kernel_cred(0))\n\n");
}

/*
 * Etape 2 : Surfaces d'attaque du kernel
 */
static void explain_attack_surfaces(void) {
    printf("[*] Etape 2 : Surfaces d'attaque du kernel\n\n");

    printf("    1. Syscalls       : Interfaces directes avec le kernel\n");
    printf("    2. ioctl()        : Commandes aux drivers de peripheriques\n");
    printf("    3. /dev/*         : Fichiers de peripheriques\n");
    printf("    4. /proc, /sys    : Pseudo-filesystems\n");
    printf("    5. Modules (LKM)  : Code charge dans le kernel\n");
    printf("    6. Sockets        : Netfilter, packet handlers\n");
    printf("    7. Filesystem     : Parsing de FS malveillant (USB)\n\n");

    printf("    Vulnerabilites courantes :\n");
    printf("    - Stack overflow dans un handler kernel\n");
    printf("    - Use-after-free dans un driver\n");
    printf("    - Race condition (TOCTOU)\n");
    printf("    - Integer overflow dans un ioctl\n");
    printf("    - NULL pointer dereference\n\n");
}

/*
 * Etape 3 : Informations kernel utiles pour l'exploitation
 */
static void gather_kernel_info(void) {
    printf("[*] Etape 3 : Reconnaissance du kernel\n\n");

    /* Version du kernel */
    struct utsname uts;
    if (uname(&uts) == 0) {
        printf("    Kernel version : %s %s\n", uts.sysname, uts.release);
        printf("    Architecture   : %s\n\n", uts.machine);
    }

    /* Lire la version detaillee */
    FILE *fp = fopen("/proc/version", "r");
    if (fp) {
        char line[512];
        if (fgets(line, sizeof(line), fp))
            printf("    /proc/version : %s", line);
        fclose(fp);
    }
    printf("\n");

    /* Verifier KASLR */
    fp = fopen("/proc/sys/kernel/randomize_va_space", "r");
    if (fp) {
        int aslr;
        if (fscanf(fp, "%d", &aslr) == 1) {
            printf("    ASLR : %d (%s)\n", aslr,
                   aslr == 0 ? "desactive" :
                   aslr == 1 ? "partiel" : "complet");
        }
        fclose(fp);
    }

    /* Verifier kptr_restrict */
    fp = fopen("/proc/sys/kernel/kptr_restrict", "r");
    if (fp) {
        int val;
        if (fscanf(fp, "%d", &val) == 1) {
            printf("    kptr_restrict : %d (%s)\n", val,
                   val == 0 ? "adresses visibles" :
                   val == 1 ? "restreint" : "cache");
        }
        fclose(fp);
    }

    /* Verifier dmesg_restrict */
    fp = fopen("/proc/sys/kernel/dmesg_restrict", "r");
    if (fp) {
        int val;
        if (fscanf(fp, "%d", &val) == 1) {
            printf("    dmesg_restrict : %d (%s)\n", val,
                   val == 0 ? "lisible par tous" : "root seulement");
        }
        fclose(fp);
    }

    /* Modules charges */
    printf("\n    Modules kernel charges (extrait) :\n");
    fp = fopen("/proc/modules", "r");
    if (fp) {
        char line[256];
        int count = 0;
        while (fgets(line, sizeof(line), fp) && count < 8) {
            char modname[64];
            if (sscanf(line, "%63s", modname) == 1)
                printf("      %s\n", modname);
            count++;
        }
        if (count >= 8)
            printf("      ... (tronque)\n");
        fclose(fp);
    }
    printf("\n");
}

/*
 * Etape 4 : Concept de privilege escalation kernel
 */
static void explain_privesc(void) {
    printf("[*] Etape 4 : Privilege escalation via kernel\n\n");

    printf("    Methode classique : overwrite de credentials\n\n");

    printf("    1. Declencher le bug (crash dans le kernel)\n");
    printf("    2. Obtenir l'execution de code en Ring 0\n");
    printf("    3. Appeler :\n");
    printf("       struct cred *new = prepare_kernel_cred(NULL);\n");
    printf("       commit_creds(new);\n");
    printf("       // Le processus courant est maintenant root !\n\n");

    printf("    4. Retourner proprement en userspace\n");
    printf("    5. Spawner un shell : execve(\"/bin/sh\", ...)\n\n");

    printf("    Adresses necessaires :\n");
    printf("    - prepare_kernel_cred : cat /proc/kallsyms | grep prepare_kernel_cred\n");
    printf("    - commit_creds        : cat /proc/kallsyms | grep commit_creds\n\n");

    /* Essayer de lire kallsyms */
    FILE *fp = fopen("/proc/kallsyms", "r");
    if (fp) {
        char line[256];
        int found = 0;
        while (fgets(line, sizeof(line), fp)) {
            if (strstr(line, "prepare_kernel_cred") ||
                strstr(line, "commit_creds")) {
                printf("    %s", line);
                found++;
                if (found >= 2) break;
            }
        }
        if (found == 0)
            printf("    (adresses masquees par kptr_restrict)\n");
        fclose(fp);
    }
    printf("\n");
}

/*
 * Etape 5 : Protections kernel
 */
static void explain_protections(void) {
    printf("[*] Etape 5 : Protections du kernel\n\n");

    printf("    Protection        | Description\n");
    printf("    ──────────────────|──────────────────────────────────\n");
    printf("    KASLR             | Randomise l'adresse de base du kernel\n");
    printf("    SMEP              | Empeche le kernel d'executer du code user\n");
    printf("    SMAP              | Empeche le kernel d'acceder aux donnees user\n");
    printf("    kptr_restrict     | Cache les adresses kernel dans /proc\n");
    printf("    dmesg_restrict    | Restreint l'acces aux logs kernel\n");
    printf("    KPTI              | Isole les tables de pages kernel/user\n");
    printf("    Stack Canary      | Detecte les overflows dans le kernel\n");
    printf("    Lockdown          | Restreint les interfaces de debug\n\n");
}

int main(void) {
    printf("[*] Demo : Kernel Exploits Basics\n\n");

    explain_user_kernel();
    explain_attack_surfaces();
    gather_kernel_info();
    explain_privesc();
    explain_protections();

    printf("[+] Demo terminee avec succes\n");
    return 0;
}
