{
  "title": "Week 10: Beacon Architecture Quiz",
  "description": "Test your understanding of beacon concepts, configuration, sleep loops, and HTTP check-ins",
  "passingScore": 70,
  "questions": [
    {
      "id": 1,
      "question": "What is the primary difference between a beacon and a reverse shell?",
      "options": [
        "A beacon uses UDP while reverse shells use TCP",
        "A beacon checks in periodically with short-lived connections, while reverse shells maintain persistent connections",
        "A beacon can only execute one command while reverse shells can execute multiple",
        "Beacons are more detectable than reverse shells"
      ],
      "correctAnswer": 1,
      "explanation": "Beacons use periodic, short-lived HTTP/HTTPS connections (asynchronous), while reverse shells maintain long-lived TCP connections (synchronous). This makes beacons harder to detect as they blend with normal web traffic.",
      "difficulty": "easy"
    },
    {
      "id": 2,
      "question": "Why is jitter important in beacon sleep timing?",
      "options": [
        "To make the beacon sleep longer and save CPU resources",
        "To synchronize multiple beacons on the same network",
        "To make check-in timing irregular and harder to detect with automated tools",
        "To ensure the beacon checks in at exactly the same time every cycle"
      ],
      "correctAnswer": 2,
      "explanation": "Jitter adds randomness to sleep intervals, making network traffic patterns irregular. Without jitter, beacons check in at exact intervals (e.g., every 60s), creating a predictable pattern that network monitoring tools can easily detect. With 20% jitter on 60s, check-ins vary between 48-72 seconds.",
      "difficulty": "easy"
    },
    {
      "id": 3,
      "question": "What information should be included in a BEACON_CONFIG structure?",
      "options": [
        "Only the C2 server hostname and port",
        "C2 host, port, sleep time, jitter, beacon ID, user-agent, and communication paths",
        "Just the beacon's unique identifier",
        "Only encryption keys and protocols"
      ],
      "correctAnswer": 1,
      "explanation": "A comprehensive BEACON_CONFIG structure includes: C2 server details (host, port, SSL), timing parameters (sleep, jitter), identity (beacon ID, user-agent), communication paths (check-in URI, result URI), and operational settings (retries, kill date). This provides all information needed for beacon operation.",
      "difficulty": "medium"
    },
    {
      "id": 4,
      "question": "Given baseSleep=60 seconds and jitter=30%, what is the valid sleep range?",
      "options": [
        "30-90 seconds",
        "42-78 seconds",
        "54-66 seconds",
        "0-120 seconds"
      ],
      "correctAnswer": 1,
      "explanation": "Jitter range = 60 * 30 / 100 = 18 seconds. Min = 60 - 18 = 42 seconds. Max = 60 + 18 = 78 seconds. The beacon will sleep for a random duration between 42 and 78 seconds each cycle.",
      "difficulty": "medium"
    },
    {
      "id": 5,
      "question": "What HTTP method is typically used for beacon check-ins?",
      "options": [
        "POST only, to send beacon data",
        "DELETE to request task removal",
        "GET to request tasks from the server",
        "PUT to update beacon status"
      ],
      "correctAnswer": 2,
      "explanation": "Beacons typically use GET requests for check-ins (requesting tasks from the server) and POST requests for sending results. GET is used because the beacon is 'getting' tasks from the C2, making it look like normal web browsing activity.",
      "difficulty": "easy"
    },
    {
      "id": 6,
      "question": "What is the purpose of the X-Beacon-ID custom HTTP header?",
      "options": [
        "To encrypt the HTTP request",
        "To identify which beacon is checking in to the C2 server",
        "To specify the beacon's IP address",
        "To request a specific type of task"
      ],
      "correctAnswer": 1,
      "explanation": "The X-Beacon-ID header allows the C2 server to identify which specific beacon is checking in, enabling the server to deliver the correct tasks to that beacon and track multiple implants. Each beacon has a unique ID (often based on hostname, UUID, or similar).",
      "difficulty": "medium"
    },
    {
      "id": 7,
      "question": "What should a beacon do when the C2 server responds with 'NOTASK'?",
      "options": [
        "Terminate immediately",
        "Return to sleep and check in again later",
        "Execute the last received command again",
        "Switch to a backup C2 server"
      ],
      "correctAnswer": 1,
      "explanation": "NOTASK means no tasks are queued for the beacon. The beacon should simply return to its sleep cycle and check in again after the next sleep interval. This is the most common response and normal operation.",
      "difficulty": "easy"
    },
    {
      "id": 8,
      "question": "Why is it better to use WaitForSingleObject instead of Sleep() in production malware?",
      "options": [
        "WaitForSingleObject uses less CPU",
        "It obfuscates the sleep behavior and avoids obvious Sleep() API calls",
        "WaitForSingleObject is faster",
        "Sleep() doesn't work on all Windows versions"
      ],
      "correctAnswer": 1,
      "explanation": "Using WaitForSingleObject on an event that never signals achieves the same result as Sleep() but is less obvious to security tools looking for Sleep() API calls. This is a simple evasion technique to make the beacon less detectable in API call analysis.",
      "difficulty": "hard"
    },
    {
      "id": 9,
      "question": "What is interruptible sleep and why is it useful?",
      "options": [
        "Sleep that can be interrupted by network errors",
        "Sleep broken into small chunks allowing the beacon to check for termination signals or urgent tasks",
        "Sleep that randomly wakes up early",
        "Sleep that only works during business hours"
      ],
      "correctAnswer": 1,
      "explanation": "Interruptible sleep breaks a long sleep period into smaller chunks (e.g., 1-second intervals), checking a termination flag or urgent task flag between each chunk. This allows the beacon to respond to EXIT commands or high-priority tasks without waiting for the entire sleep cycle to complete.",
      "difficulty": "hard"
    },
    {
      "id": 10,
      "question": "In a typical beacon lifecycle, what happens AFTER receiving and executing a task?",
      "options": [
        "The beacon immediately terminates",
        "The beacon sends results back to the C2 server, then returns to sleep",
        "The beacon waits for the next task without sleeping",
        "The beacon generates a new beacon ID"
      ],
      "correctAnswer": 1,
      "explanation": "After executing a task, the beacon sends the results back to the C2 server (typically via HTTP POST), then returns to its sleep cycle. This completes one iteration of the beacon loop: Sleep -> Check-in -> Execute -> Report -> Repeat.",
      "difficulty": "medium"
    }
  ]
}
