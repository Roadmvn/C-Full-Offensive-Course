{
  "week": 2,
  "title": "Memory & Pointers",
  "passing_score": 8,
  "questions": [
    {
      "id": 1,
      "type": "multiple_choice",
      "question": "Que retourne l'expression &x si x est un int ?",
      "options": [
        "La valeur de x",
        "L'adresse memoire de x",
        "Un pointeur NULL",
        "Une erreur"
      ],
      "answer": 1,
      "explanation": "L'operateur & (adresse de) retourne l'adresse memoire de la variable."
    },
    {
      "id": 2,
      "type": "multiple_choice",
      "question": "Soit int* ptr = &x; Que fait *ptr = 10; ?",
      "options": [
        "Change l'adresse de ptr",
        "Change la valeur de x a 10",
        "Cree une nouvelle variable",
        "Erreur de compilation"
      ],
      "answer": 1,
      "explanation": "*ptr accede a la valeur pointee. Donc *ptr = 10 modifie x."
    },
    {
      "id": 3,
      "type": "multiple_choice",
      "question": "Si int* p pointe vers un tableau, que fait p++ ?",
      "options": [
        "Ajoute 1 a l'adresse",
        "Ajoute sizeof(int) a l'adresse",
        "Ajoute sizeof(p) a l'adresse",
        "Ne fait rien"
      ],
      "answer": 1,
      "explanation": "p++ avance de sizeof(int) bytes, pas de 1 byte. C'est l'arithmetique des pointeurs."
    },
    {
      "id": 4,
      "type": "multiple_choice",
      "question": "Quelle fonction alloue de la memoire initialisee a zero ?",
      "options": [
        "malloc",
        "calloc",
        "realloc",
        "free"
      ],
      "answer": 1,
      "explanation": "calloc alloue et initialise a zero. malloc n'initialise pas."
    },
    {
      "id": 5,
      "type": "find_error",
      "question": "Quel est le probleme ?\n\nint* ptr;\n*ptr = 42;",
      "options": [
        "ptr n'est pas initialise (dangling pointer)",
        "On ne peut pas assigner 42 a un pointeur",
        "Il manque un point-virgule",
        "Pas de probleme"
      ],
      "answer": 0,
      "explanation": "ptr n'est pas initialise, il pointe vers une adresse aleatoire. Crash probable !"
    },
    {
      "id": 6,
      "type": "multiple_choice",
      "question": "Que vaut sizeof(ptr) si ptr est un int* sur un systeme 64-bit ?",
      "options": [
        "4 bytes",
        "8 bytes",
        "Depend de sizeof(int)",
        "1 byte"
      ],
      "answer": 1,
      "explanation": "Un pointeur fait toujours 8 bytes sur 64-bit, quel que soit le type pointe."
    },
    {
      "id": 7,
      "type": "complete_code",
      "question": "Complete pour liberer la memoire :\n\nint* data = malloc(100);\n// utilisation...\n_______(data);",
      "options": [
        "delete",
        "free",
        "release",
        "dealloc"
      ],
      "answer": 1,
      "explanation": "free() libere la memoire allouee par malloc/calloc."
    },
    {
      "id": 8,
      "type": "multiple_choice",
      "question": "Comment s'appelle le caractere qui termine une string en C ?",
      "options": [
        "NULL character (\\0)",
        "Newline (\\n)",
        "End of file (EOF)",
        "Il n'y en a pas"
      ],
      "answer": 0,
      "explanation": "Les strings C sont terminees par \\0 (null terminator, valeur 0)."
    },
    {
      "id": 9,
      "type": "multiple_choice",
      "question": "tab[3] est equivalent a quoi ?",
      "options": [
        "&(tab + 3)",
        "*(tab + 3)",
        "tab + 3",
        "*tab + 3"
      ],
      "answer": 1,
      "explanation": "tab[i] est syntaxiquement equivalent a *(tab + i)."
    },
    {
      "id": 10,
      "type": "find_error",
      "question": "Quel est le probleme ?\n\nchar* str = malloc(10);\nstrcpy(str, \"Hello\");\nfree(str);\nprintf(\"%s\", str);",
      "options": [
        "Use after free - str est utilise apres free()",
        "strcpy est mal utilise",
        "malloc devrait etre calloc",
        "Pas de probleme"
      ],
      "answer": 0,
      "explanation": "Apres free(), la memoire n'est plus valide. L'utiliser = undefined behavior."
    }
  ]
}
