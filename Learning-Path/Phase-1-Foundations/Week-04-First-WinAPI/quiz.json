{
  "title": "Week 04 - First WinAPI Quiz",
  "description": "Test your knowledge of Windows types, MessageBox, error handling, and handles",
  "questions": [
    {
      "id": 1,
      "question": "Quelle est la taille d'un DWORD en bytes ?",
      "options": [
        "2 bytes",
        "4 bytes",
        "8 bytes",
        "Dépend de l'architecture (32/64 bits)"
      ],
      "correct": 1,
      "explanation": "DWORD signifie Double Word et fait toujours 4 bytes (32 bits), quelle que soit l'architecture."
    },
    {
      "id": 2,
      "question": "Quelle valeur retourne CreateFileA en cas d'échec ?",
      "options": [
        "NULL",
        "0",
        "INVALID_HANDLE_VALUE",
        "-1"
      ],
      "correct": 2,
      "explanation": "CreateFileA retourne INVALID_HANDLE_VALUE (qui vaut -1 casté en HANDLE) en cas d'échec. D'autres fonctions comme OpenProcess retournent NULL."
    },
    {
      "id": 3,
      "question": "Quelle fonction permet de récupérer le code d'erreur après un échec d'API ?",
      "options": [
        "GetError()",
        "GetLastError()",
        "GetErrorCode()",
        "ErrorCode()"
      ],
      "correct": 1,
      "explanation": "GetLastError() retourne le code d'erreur de la dernière fonction WinAPI ayant échoué dans le thread actuel."
    },
    {
      "id": 4,
      "question": "Que signifie le préfixe 'lp' dans 'lpBuffer' (Hungarian Notation) ?",
      "options": [
        "Local Pointer",
        "Long Pointer",
        "Large Parameter",
        "Low Priority"
      ],
      "correct": 1,
      "explanation": "lp signifie 'Long Pointer', un héritage de Windows 16 bits où il y avait des 'near' et 'far' pointers. Aujourd'hui équivalent à un pointeur normal."
    },
    {
      "id": 5,
      "question": "Quelle est la différence entre MessageBoxA et MessageBoxW ?",
      "options": [
        "MessageBoxA est asynchrone, MessageBoxW est synchrone",
        "MessageBoxA utilise ANSI (char*), MessageBoxW utilise Unicode (wchar_t*)",
        "MessageBoxA est pour Windows 32 bits, MessageBoxW pour 64 bits",
        "Il n'y a aucune différence"
      ],
      "correct": 1,
      "explanation": "MessageBoxA prend des chaînes ANSI (char*), MessageBoxW prend des chaînes Unicode (wchar_t*). Le A signifie ANSI, le W signifie Wide (Unicode)."
    },
    {
      "id": 6,
      "question": "Que doit-on toujours faire avec un HANDLE après utilisation ?",
      "options": [
        "Le libérer avec free()",
        "Le fermer avec CloseHandle()",
        "Le supprimer avec delete()",
        "Rien, Windows le gère automatiquement"
      ],
      "correct": 1,
      "explanation": "Il faut TOUJOURS fermer un HANDLE avec CloseHandle() pour éviter les fuites de ressources (handle leak)."
    },
    {
      "id": 7,
      "question": "Quelle fonction convertit un code d'erreur en message lisible ?",
      "options": [
        "ErrorToString()",
        "TranslateError()",
        "FormatMessage()",
        "GetErrorMessage()"
      ],
      "correct": 2,
      "explanation": "FormatMessage() (ou FormatMessageA/W) convertit un code d'erreur système en message texte lisible."
    },
    {
      "id": 8,
      "question": "Quel est le code d'erreur pour 'Fichier non trouvé' ?",
      "options": [
        "ERROR_FILE_NOT_FOUND (2)",
        "ERROR_NOT_FOUND (1)",
        "ERROR_NO_FILE (3)",
        "ERROR_MISSING (404)"
      ],
      "correct": 0,
      "explanation": "ERROR_FILE_NOT_FOUND a la valeur 2. C'est l'une des erreurs les plus courantes lors de l'ouverture de fichiers."
    },
    {
      "id": 9,
      "question": "Que retourne GetCurrentProcess() ?",
      "options": [
        "Un vrai handle vers le processus actuel",
        "Un pseudo-handle (valeur magique -1)",
        "Le PID du processus actuel",
        "NULL"
      ],
      "correct": 1,
      "explanation": "GetCurrentProcess() retourne un pseudo-handle (valeur constante -1), pas un vrai handle. Il NE FAUT PAS appeler CloseHandle() dessus."
    },
    {
      "id": 10,
      "question": "Comment combiner plusieurs flags pour MessageBoxA (par exemple MB_YESNO et MB_ICONWARNING) ?",
      "options": [
        "MB_YESNO + MB_ICONWARNING",
        "MB_YESNO & MB_ICONWARNING",
        "MB_YESNO | MB_ICONWARNING",
        "MB_YESNO && MB_ICONWARNING"
      ],
      "correct": 2,
      "explanation": "Les flags Windows se combinent avec l'opérateur OR bitwise (|). Chaque flag est un bit différent, donc | les combine correctement."
    }
  ],
  "scoring": {
    "passing_score": 7,
    "total_questions": 10,
    "excellent": 9,
    "good": 7,
    "needs_review": 5
  },
  "resources": {
    "lessons": [
      "01-windows-types.c",
      "02-messagebox.c",
      "03-error-handling.c",
      "04-handles.c"
    ],
    "documentation": [
      "https://learn.microsoft.com/en-us/windows/win32/api/",
      "https://learn.microsoft.com/en-us/windows/win32/winprog/windows-data-types"
    ]
  }
}
