{
  "title": "Week 3 - Structs & Files Quiz",
  "description": "Test tes connaissances sur les structures et les fichiers en C",
  "passingScore": 70,
  "questions": [
    {
      "id": 1,
      "question": "Quelle est la différence principale entre une struct et une union ?",
      "options": [
        "Une struct est plus rapide qu'une union",
        "Une struct alloue de la mémoire pour TOUS ses membres, une union partage la MÊME mémoire pour tous ses membres",
        "Une union ne peut contenir que des entiers",
        "Il n'y a pas de différence, c'est juste une syntaxe différente"
      ],
      "correctAnswer": 1,
      "explanation": "Dans une struct, chaque membre a son propre espace mémoire. Dans une union, tous les membres partagent la MÊME zone mémoire, donc modifier un membre écrase les autres."
    },
    {
      "id": 2,
      "question": "Comment accède-t-on au membre 'age' d'une structure via un pointeur 'p' ?",
      "options": [
        "p.age",
        "p->age",
        "*p.age",
        "age->p"
      ],
      "correctAnswer": 1,
      "explanation": "L'opérateur '->' est utilisé pour accéder aux membres via un pointeur. C'est équivalent à (*p).age mais plus lisible."
    },
    {
      "id": 3,
      "question": "Quel mode d'ouverture faut-il utiliser pour lire un fichier binaire ?",
      "options": [
        "\"r\"",
        "\"rb\"",
        "\"w\"",
        "\"binary\""
      ],
      "correctAnswer": 1,
      "explanation": "Le mode \"rb\" signifie 'read binary' (lecture binaire). Le 'b' est crucial pour lire correctement les fichiers binaires sur Windows."
    },
    {
      "id": 4,
      "question": "Que fait l'instruction 'fseek(f, 0, SEEK_END)' ?",
      "options": [
        "Ferme le fichier",
        "Lit jusqu'à la fin du fichier",
        "Déplace le curseur à la fin du fichier",
        "Supprime le fichier"
      ],
      "correctAnswer": 2,
      "explanation": "fseek() déplace le curseur de lecture/écriture. SEEK_END signifie 'depuis la fin'. Avec offset 0, on va exactement à la fin. Très utile pour obtenir la taille du fichier avec ftell()."
    },
    {
      "id": 5,
      "question": "À quoi sert un 'magic number' dans un header de fichier binaire ?",
      "options": [
        "À chiffrer le fichier",
        "À identifier le type de fichier et valider sa signature",
        "À calculer la taille du fichier",
        "À compresser les données"
      ],
      "correctAnswer": 1,
      "explanation": "Le magic number (ex: 'MZ' pour les PE, 0xDEADBEEF pour notre format custom) sert à identifier rapidement le type de fichier et vérifier qu'il est valide."
    },
    {
      "id": 6,
      "question": "Quelle est la taille en bytes d'une union contenant un int (4 bytes) et un char[10] (10 bytes) ?",
      "options": [
        "4 bytes",
        "10 bytes",
        "14 bytes",
        "Ça dépend du compilateur"
      ],
      "correctAnswer": 1,
      "explanation": "Une union a toujours la taille de son PLUS GRAND membre. Ici c'est char[10] qui fait 10 bytes, donc l'union fait 10 bytes (plus d'éventuel padding)."
    },
    {
      "id": 7,
      "question": "Quel est l'avantage des enums par rapport aux #define pour les constantes ?",
      "options": [
        "Les enums sont plus rapides",
        "Les enums prennent moins de mémoire",
        "Les enums sont typées et peuvent être débugguées plus facilement",
        "Il n'y a aucun avantage"
      ],
      "correctAnswer": 2,
      "explanation": "Les enums créent un véritable type, ce qui permet au compilateur de faire des vérifications et au debugger de montrer les noms au lieu des valeurs numériques."
    },
    {
      "id": 8,
      "question": "Pourquoi doit-on TOUJOURS fermer un fichier avec fclose() ?",
      "options": [
        "Pour libérer les ressources et s'assurer que toutes les données sont bien écrites sur le disque",
        "C'est optionnel, le système le fait automatiquement",
        "Seulement pour les fichiers en écriture",
        "Pour éviter les virus"
      ],
      "correctAnswer": 0,
      "explanation": "fclose() libère les ressources système (descripteurs de fichiers) et vide les buffers, garantissant que toutes les données sont écrites. Ne pas fermer peut causer des fuites de ressources ou des pertes de données."
    },
    {
      "id": 9,
      "question": "Dans un fichier PE Windows, que contient le champ 'e_lfanew' du DOS Header ?",
      "options": [
        "La taille du fichier",
        "L'offset vers le PE Header",
        "Le point d'entrée du programme",
        "Le nombre de sections"
      ],
      "correctAnswer": 1,
      "explanation": "e_lfanew contient l'offset (position en bytes) où se trouve le véritable PE Header. C'est crucial pour parser correctement un PE : DOS Header -> e_lfanew -> PE Header."
    },
    {
      "id": 10,
      "question": "Que fait la fonction ftell() ?",
      "options": [
        "Ferme le fichier",
        "Lit une ligne du fichier",
        "Retourne la position actuelle du curseur dans le fichier",
        "Écrit dans le fichier"
      ],
      "correctAnswer": 2,
      "explanation": "ftell() retourne la position actuelle (en bytes depuis le début). Combiné avec fseek(f, 0, SEEK_END), on peut obtenir la taille totale du fichier."
    }
  ],
  "categories": {
    "structs": [1, 2, 6],
    "unions_enums": [1, 6, 7],
    "file_io": [3, 4, 8, 10],
    "binary_parsing": [5, 9]
  },
  "difficulty": {
    "beginner": [1, 2, 3, 8],
    "intermediate": [4, 6, 7, 10],
    "advanced": [5, 9]
  },
  "maldev_relevant": [5, 9],
  "tips": [
    "Les structures sont la base de TOUTE l'API Windows",
    "Tous les PE (EXE/DLL) commencent par 'MZ' (0x5A4D)",
    "Toujours valider les magic numbers avant de parser",
    "L'opérateur -> est ton meilleur ami avec les pointeurs de structures",
    "fread() et fwrite() sont parfaits pour les structures entières",
    "En maldev, on parse BEAUCOUP de headers binaires (PE, shellcodes, etc.)"
  ]
}
