{
  "title": "Week 08: Winsock Basics Quiz",
  "description": "Test your understanding of Winsock fundamentals, TCP client/server programming, and reverse shell concepts",
  "passingScore": 70,
  "questions": [
    {
      "id": 1,
      "question": "Which function MUST be called before using any Winsock functions?",
      "type": "multiple-choice",
      "options": [
        "socket()",
        "WSAStartup()",
        "connect()",
        "WSAInit()"
      ],
      "correctAnswer": 1,
      "explanation": "WSAStartup() must be called to initialize the Winsock library before any other Winsock functions. It loads the appropriate Winsock DLL and verifies version compatibility.",
      "points": 10
    },
    {
      "id": 2,
      "question": "What does MAKEWORD(2, 2) represent in WSAStartup?",
      "type": "multiple-choice",
      "options": [
        "Winsock version 2.2",
        "Two sockets with two connections",
        "IPv4 address family version 2",
        "Maximum 2 connections"
      ],
      "correctAnswer": 0,
      "explanation": "MAKEWORD(2, 2) specifies that we want to use Winsock version 2.2. The first parameter is the minor version and the second is the major version.",
      "points": 10
    },
    {
      "id": 3,
      "question": "What is the correct order of operations for a TCP client?",
      "type": "multiple-choice",
      "options": [
        "socket() -> bind() -> connect() -> send()",
        "socket() -> connect() -> send() -> recv()",
        "connect() -> socket() -> send() -> recv()",
        "socket() -> listen() -> connect() -> send()"
      ],
      "correctAnswer": 1,
      "explanation": "The correct TCP client workflow is: create socket with socket(), connect to server with connect(), then exchange data with send()/recv(). Clients don't need bind() or listen().",
      "points": 10
    },
    {
      "id": 4,
      "question": "What does htons() do and why is it necessary?",
      "type": "multiple-choice",
      "options": [
        "Converts hostname to string",
        "Converts port from host byte order to network byte order (big-endian)",
        "Converts IP address to binary format",
        "Creates a socket handle"
      ],
      "correctAnswer": 1,
      "explanation": "htons() (Host TO Network Short) converts a 16-bit port number from host byte order to network byte order (big-endian). Network protocols require big-endian byte order.",
      "points": 10
    },
    {
      "id": 5,
      "question": "What does recv() return when the connection is closed gracefully by the peer?",
      "type": "multiple-choice",
      "options": [
        "SOCKET_ERROR (-1)",
        "INVALID_SOCKET",
        "0 (zero)",
        "NULL"
      ],
      "correctAnswer": 2,
      "explanation": "recv() returns 0 when the connection has been gracefully closed by the peer. It returns SOCKET_ERROR on error and a positive number (bytes received) on success.",
      "points": 10
    },
    {
      "id": 6,
      "question": "In a TCP server, what is the difference between the listening socket and client socket?",
      "type": "multiple-choice",
      "options": [
        "There is no difference, they are the same socket",
        "Listening socket accepts connections, client socket communicates with specific client",
        "Listening socket sends data, client socket receives data",
        "Client socket is created by the client application"
      ],
      "correctAnswer": 1,
      "explanation": "The listening socket (from socket() and listen()) waits for connections. accept() creates a NEW client socket for each connection to communicate with that specific client. The listening socket remains open to accept more connections.",
      "points": 10
    },
    {
      "id": 7,
      "question": "Which STARTUPINFO flag is required to redirect process I/O in a reverse shell?",
      "type": "multiple-choice",
      "options": [
        "STARTF_USESHOWWINDOW",
        "STARTF_USESTDHANDLES",
        "STARTF_USEPOSITION",
        "STARTF_FORCEONFEEDBACK"
      ],
      "correctAnswer": 1,
      "explanation": "STARTF_USESTDHANDLES tells CreateProcess to use the hStdInput, hStdOutput, and hStdError handles specified in STARTUPINFO. This is essential for redirecting I/O to a socket.",
      "points": 10
    },
    {
      "id": 8,
      "question": "Why must bInheritHandles be TRUE when creating a reverse shell?",
      "type": "multiple-choice",
      "options": [
        "To allow the process to run with elevated privileges",
        "To allow the child process (cmd.exe) to use the parent's socket handles",
        "To prevent the process from being detected",
        "To enable network access for the process"
      ],
      "correctAnswer": 1,
      "explanation": "bInheritHandles must be TRUE so that the child process (cmd.exe) can inherit and use the socket handles we set in STARTUPINFO. Without this, cmd.exe cannot read from or write to the socket.",
      "points": 10
    },
    {
      "id": 9,
      "question": "What is the main advantage of a reverse shell over a bind shell?",
      "type": "multiple-choice",
      "options": [
        "Reverse shells are faster",
        "Reverse shells bypass firewalls by connecting outward",
        "Reverse shells are encrypted by default",
        "Reverse shells cannot be detected"
      ],
      "correctAnswer": 1,
      "explanation": "Reverse shells connect OUT from the target to the attacker, which often bypasses firewalls that typically block INCOMING connections but allow OUTGOING connections. This is their main tactical advantage.",
      "points": 10
    },
    {
      "id": 10,
      "question": "What happens if you forget to call WSACleanup()?",
      "type": "multiple-choice",
      "options": [
        "The program will crash immediately",
        "Winsock resources may not be freed, causing resource leaks",
        "Future socket operations will fail",
        "Nothing, it's optional"
      ],
      "correctAnswer": 1,
      "explanation": "While the OS typically cleans up resources when a process exits, not calling WSACleanup() can cause resource leaks in long-running programs. It should be called once for each successful WSAStartup() to properly free Winsock resources.",
      "points": 10
    }
  ],
  "summary": {
    "totalQuestions": 10,
    "totalPoints": 100,
    "topics": [
      "Winsock initialization and cleanup",
      "TCP client/server workflow",
      "Network byte order conversion",
      "Socket lifecycle management",
      "Process I/O redirection",
      "Reverse shell concepts"
    ]
  }
}
