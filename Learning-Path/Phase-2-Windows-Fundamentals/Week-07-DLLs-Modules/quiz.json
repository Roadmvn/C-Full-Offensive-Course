{
  "week": 7,
  "title": "DLLs & Dynamic API Resolution",
  "questions": [
    {
      "id": 1,
      "question": "Quelle fonction Windows charge une DLL en mémoire ?",
      "options": [
        "GetModuleHandle",
        "LoadLibrary",
        "FreeLibrary",
        "MapViewOfFile"
      ],
      "correct": 1,
      "explanation": "LoadLibrary (A/W) charge une DLL et retourne un HMODULE."
    },
    {
      "id": 2,
      "question": "Que retourne GetProcAddress si la fonction n'existe pas ?",
      "options": [
        "INVALID_HANDLE_VALUE",
        "-1",
        "NULL",
        "Une exception"
      ],
      "correct": 2,
      "explanation": "GetProcAddress retourne NULL si la fonction n'est pas trouvée."
    },
    {
      "id": 3,
      "question": "Pourquoi utiliser la résolution dynamique d'APIs en maldev ?",
      "options": [
        "Pour accélérer l'exécution",
        "Pour réduire la taille du binaire",
        "Pour éviter les imports visibles dans l'IAT",
        "Pour supporter plus de versions Windows"
      ],
      "correct": 2,
      "explanation": "Les imports statiques sont visibles dans le PE header. La résolution dynamique les cache des analyses statiques."
    },
    {
      "id": 4,
      "question": "Qu'est-ce que le PEB ?",
      "options": [
        "Process Execution Block",
        "Process Environment Block",
        "Program Entry Block",
        "Protected Execution Buffer"
      ],
      "correct": 1,
      "explanation": "Le PEB (Process Environment Block) contient des informations sur le processus, dont la liste des modules chargés."
    },
    {
      "id": 5,
      "question": "Comment accède-t-on au PEB en x64 ?",
      "options": [
        "Via fs:[0x30]",
        "Via gs:[0x60]",
        "Via GetPEB()",
        "Via NtQueryInformationProcess"
      ],
      "correct": 1,
      "explanation": "En x64, le PEB est accessible via gs:[0x60]. En x86, c'est fs:[0x30]."
    },
    {
      "id": 6,
      "question": "Quelle est la différence entre LoadLibrary et GetModuleHandle ?",
      "options": [
        "Aucune différence",
        "LoadLibrary charge la DLL, GetModuleHandle retourne un handle si déjà chargée",
        "GetModuleHandle charge la DLL, LoadLibrary ne fait que vérifier",
        "LoadLibrary est pour x86, GetModuleHandle pour x64"
      ],
      "correct": 1,
      "explanation": "GetModuleHandle retourne un handle vers une DLL DÉJÀ chargée, LoadLibrary la charge si nécessaire."
    },
    {
      "id": 7,
      "question": "Quel est le type de retour de GetProcAddress ?",
      "options": [
        "HMODULE",
        "HANDLE",
        "FARPROC",
        "LPVOID"
      ],
      "correct": 2,
      "explanation": "GetProcAddress retourne FARPROC, un pointeur de fonction générique qui doit être casté."
    },
    {
      "id": 8,
      "question": "Pour appeler une API résolue dynamiquement, que faut-il définir ?",
      "options": [
        "Une macro",
        "Un typedef du prototype de la fonction",
        "Une variable globale",
        "Un header spécial"
      ],
      "correct": 1,
      "explanation": "Il faut définir un typedef correspondant au prototype de la fonction pour pouvoir caster et appeler correctement."
    }
  ]
}
