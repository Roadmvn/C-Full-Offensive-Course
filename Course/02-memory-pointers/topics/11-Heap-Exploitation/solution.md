# Solutions - Exploitation du Heap Avancée

## Exercice 1 : Découverte (Très facile)

### Objectif
Comprendre le concept de Use-After-Free en créant un programme vulnérable simple.

### Solution

```c
/*
 * Exercice 1 : Démonstration Use-After-Free (UAF)
 * Comprendre le danger d'utiliser un pointeur après free()
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure simple pour démonstration
typedef struct {
    int id;
    char name[32];
} User;

// Fonction pour afficher un utilisateur
void print_user(User *user) {
    printf("[*] User ID: %d\n", user->id);
    printf("[*] User Name: %s\n", user->name);
}

int main() {
    printf("[*] Exercice 1 : Use-After-Free\n");
    printf("==========================================\n\n");

    // === PHASE 1 : Allocation normale ===
    printf("=== PHASE 1 : Allocation ===\n");
    User *alice = malloc(sizeof(User));
    if (alice == NULL) {
        printf("[-] Erreur malloc\n");
        return 1;
    }

    alice->id = 1001;
    strcpy(alice->name, "Alice");

    printf("[+] Utilisateur créé à l'adresse: %p\n", (void*)alice);
    print_user(alice);

    printf("\n=== PHASE 2 : Free ===\n");
    // Libération de la mémoire
    free(alice);
    printf("[+] Mémoire libérée\n");
    printf("[!] alice pointe toujours vers: %p (dangling pointer!)\n", (void*)alice);

    // ERREUR : Ne pas mettre alice = NULL permet le bug
    // alice = NULL;  // Bonne pratique pour éviter UAF

    printf("\n=== PHASE 3 : Nouvelle allocation ===\n");
    // Une nouvelle allocation peut réutiliser LA MÊME adresse
    User *bob = malloc(sizeof(User));
    bob->id = 2002;
    strcpy(bob->name, "Bob");

    printf("[+] Nouvel utilisateur créé à: %p\n", (void*)bob);
    print_user(bob);

    printf("\n=== PHASE 4 : Use-After-Free ! ===\n");
    // BUG : Utiliser alice qui a été libéré
    printf("[!] Lecture du pointeur dangling 'alice':\n");
    print_user(alice);  // Lit les données de Bob !

    printf("\n[*] Observation:\n");
    printf("    - alice et bob pointent vers la même adresse: %s\n",
           (alice == bob) ? "OUI" : "NON");
    printf("    - alice->id devrait être 1001, mais vaut: %d\n", alice->id);
    printf("    - C'est un Use-After-Free !\n");

    // Libération propre
    free(bob);

    printf("\n[+] Exercice terminé avec succès\n");
    return 0;
}
```

### Explication

1. **Phase 1** : Allocation normale d'une structure User pour "Alice"
2. **Phase 2** : `free(alice)` libère la mémoire, mais le pointeur n'est pas mis à NULL
3. **Phase 3** : `malloc()` réutilise la même adresse pour "Bob"
4. **Phase 4** : Utiliser `alice` lit maintenant les données de Bob !

### Danger en exploitation

```
SCÉNARIO OFFENSIF :

1. Programme libère un objet contenant un pointeur de fonction
2. Attaquant alloue un nouvel objet à la même adresse
3. Attaquant contrôle le contenu (notamment le pointeur de fonction)
4. Programme utilise l'ancien pointeur → appelle l'adresse contrôlée
5. EXÉCUTION DE CODE ARBITRAIRE
```

### Résultat attendu
```
[*] Exercice 1 : Use-After-Free
==========================================

=== PHASE 1 : Allocation ===
[+] Utilisateur créé à l'adresse: 0x555555559290
[*] User ID: 1001
[*] User Name: Alice

=== PHASE 2 : Free ===
[+] Mémoire libérée
[!] alice pointe toujours vers: 0x555555559290 (dangling pointer!)

=== PHASE 3 : Nouvelle allocation ===
[+] Nouvel utilisateur créé à: 0x555555559290
[*] User ID: 2002
[*] User Name: Bob

=== PHASE 4 : Use-After-Free ! ===
[!] Lecture du pointeur dangling 'alice':
[*] User ID: 2002
[*] User Name: Bob

[*] Observation:
    - alice et bob pointent vers la même adresse: OUI
    - alice->id devrait être 1001, mais vaut: 2002
    - C'est un Use-After-Free !

[+] Exercice terminé avec succès
```

---

## Exercice 2 : Modification (Facile)

### Objectif
Créer un Use-After-Free exploitable avec un pointeur de fonction.

### Solution

```c
/*
 * Exercice 2 : UAF avec pointeur de fonction
 * Démonstration d'exécution de code via UAF
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Fonctions légitimes
void safe_function(const char *msg) {
    printf("[SAFE] Message: %s\n", msg);
}

void admin_function(const char *msg) {
    printf("[ADMIN] Accès administrateur obtenu!\n");
    printf("[ADMIN] Message: %s\n", msg);
}

// Structure avec pointeur de fonction
typedef struct {
    char data[32];
    void (*callback)(const char *);  // Pointeur de fonction
} VulnerableObject;

// Fonction pour créer un objet
VulnerableObject* create_object(const char *data, void (*func)(const char *)) {
    VulnerableObject *obj = malloc(sizeof(VulnerableObject));
    if (obj == NULL) return NULL;

    strcpy(obj->data, data);
    obj->callback = func;

    printf("[+] Objet créé à %p\n", (void*)obj);
    printf("    - data: %s\n", obj->data);
    printf("    - callback: %p\n", (void*)obj->callback);

    return obj;
}

// Fonction pour utiliser un objet
void use_object(VulnerableObject *obj) {
    printf("[*] Utilisation de l'objet à %p\n", (void*)obj);
    obj->callback(obj->data);
}

int main() {
    printf("[*] Exercice 2 : UAF avec pointeur de fonction\n");
    printf("==========================================\n\n");

    // === ÉTAPE 1 : Utilisation normale ===
    printf("=== ÉTAPE 1 : Utilisation normale ===\n");
    VulnerableObject *victim = create_object("Hello", safe_function);
    use_object(victim);

    printf("\n=== ÉTAPE 2 : Free (bug - pas de NULL) ===\n");
    free(victim);
    // BUG : victim n'est pas mis à NULL
    printf("[!] Pointeur dangling: %p\n", (void*)victim);

    printf("\n=== ÉTAPE 3 : Allocation malveillante ===\n");
    // Allouer un objet de même taille
    VulnerableObject *evil = malloc(sizeof(VulnerableObject));
    printf("[+] Objet malveillant alloué à: %p\n", (void*)evil);

    // Remplir avec nos données
    strcpy(evil->data, "PWNED");
    evil->callback = admin_function;  // Pointer vers fonction admin !

    printf("    - evil->data: %s\n", evil->data);
    printf("    - evil->callback: %p (admin_function)\n", (void*)evil->callback);

    printf("\n=== ÉTAPE 4 : Exploitation UAF ===\n");
    printf("[!] Appel du pointeur dangling...\n");

    // BUG : Utiliser victim (libéré) au lieu de evil
    use_object(victim);  // Appelle admin_function !

    printf("\n[*] Résultat:\n");
    printf("    - Nous avons appelé admin_function via UAF\n");
    printf("    - Dans un vrai exploit, callback pourrait pointer vers shellcode\n");

    // Nettoyage
    free(evil);

    printf("\n[+] Exercice terminé avec succès\n");
    return 0;
}
```

### Visualisation de la mémoire

```
AVANT free(victim):
┌──────────────────────────────────┐
│ victim → [data: "Hello"          │
│          [callback: safe_function]│  Adresse: 0x555555559290
└──────────────────────────────────┘

APRÈS free(victim):
┌──────────────────────────────────┐
│ victim → [??? garbage ???]       │  Chunk dans freelist
│          [??? garbage ???]        │  Adresse: 0x555555559290
└──────────────────────────────────┘

APRÈS malloc(evil):
┌──────────────────────────────────┐
│ victim → [data: "PWNED"           │  MÊME ADRESSE !
│ evil   → [callback: admin_func]   │  Adresse: 0x555555559290
└──────────────────────────────────┘

use_object(victim) appelle admin_function !
```

### Résultat attendu
```
[*] Exercice 2 : UAF avec pointeur de fonction
==========================================

=== ÉTAPE 1 : Utilisation normale ===
[+] Objet créé à 0x555555559290
    - data: Hello
    - callback: 0x555555554890
[*] Utilisation de l'objet à 0x555555559290
[SAFE] Message: Hello

=== ÉTAPE 2 : Free (bug - pas de NULL) ===
[!] Pointeur dangling: 0x555555559290

=== ÉTAPE 3 : Allocation malveillante ===
[+] Objet malveillant alloué à: 0x555555559290
    - evil->data: PWNED
    - evil->callback: 0x5555555548b0 (admin_function)

=== ÉTAPE 4 : Exploitation UAF ===
[!] Appel du pointeur dangling...
[*] Utilisation de l'objet à 0x555555559290
[ADMIN] Accès administrateur obtenu!
[ADMIN] Message: PWNED

[*] Résultat:
    - Nous avons appelé admin_function via UAF
    - Dans un vrai exploit, callback pourrait pointer vers shellcode

[+] Exercice terminé avec succès
```

---

## Exercice 3 : Création (Moyen)

### Objectif
Implémenter une attaque Double Free (fastbin duplication).

### Solution

```c
/*
 * Exercice 3 : Double Free / Fastbin Duplication
 * Technique pour obtenir deux pointeurs vers la même mémoire
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Afficher l'état d'un chunk
void print_chunk_info(void *ptr, const char *name) {
    if (ptr == NULL) {
        printf("    %s: NULL\n", name);
        return;
    }

    printf("    %s: %p\n", name, ptr);

    // Lire le pointeur fd (forward) dans le chunk libéré
    // Pour un chunk libéré, les 8 premiers bytes contiennent fd
    void **fd_ptr = (void **)ptr;
    printf("        → fd (next free): %p\n", *fd_ptr);
}

int main() {
    printf("[*] Exercice 3 : Double Free / Fastbin Duplication\n");
    printf("==========================================\n\n");

    printf("[*] Technique: Fastbin Duplication\n");
    printf("    Objectif: Obtenir 2 pointeurs vers la même adresse\n\n");

    // === ÉTAPE 1 : Allocations initiales ===
    printf("=== ÉTAPE 1 : Allocations ===\n");

    void *chunk_a = malloc(0x40);  // 64 bytes (fastbin)
    void *chunk_b = malloc(0x40);
    void *chunk_c = malloc(0x40);  // Prévenir consolidation

    printf("[+] chunk_a: %p\n", chunk_a);
    printf("[+] chunk_b: %p\n", chunk_b);
    printf("[+] chunk_c: %p\n", chunk_c);

    // === ÉTAPE 2 : Premier free ===
    printf("\n=== ÉTAPE 2 : free(chunk_a) ===\n");
    free(chunk_a);
    printf("[+] Fastbin head → chunk_a\n");
    printf("    Fastbin: [chunk_a] → NULL\n");

    // === ÉTAPE 3 : Free intermédiaire ===
    printf("\n=== ÉTAPE 3 : free(chunk_b) ===\n");
    free(chunk_b);
    printf("[+] Fastbin head → chunk_b\n");
    printf("    Fastbin: [chunk_b] → [chunk_a] → NULL\n");

    // === ÉTAPE 4 : Double Free ! ===
    printf("\n=== ÉTAPE 4 : free(chunk_a) ENCORE (Double Free!) ===\n");
    free(chunk_a);
    printf("[+] Fastbin head → chunk_a\n");
    printf("    Fastbin: [chunk_a] → [chunk_b] → [chunk_a] → ...\n");
    printf("    ⚠️  Boucle dans la freelist !\n");

    // === ÉTAPE 5 : Réallocations ===
    printf("\n=== ÉTAPE 5 : Réallocations ===\n");

    // Premier malloc : obtient chunk_a
    void *ptr1 = malloc(0x40);
    printf("[+] ptr1 = malloc(0x40) → %p\n", ptr1);
    printf("    Fastbin: [chunk_b] → [chunk_a] → ...\n");

    // Deuxième malloc : obtient chunk_b
    void *ptr2 = malloc(0x40);
    printf("[+] ptr2 = malloc(0x40) → %p\n", ptr2);
    printf("    Fastbin: [chunk_a] → ...\n");

    // Troisième malloc : obtient chunk_a ENCORE !
    void *ptr3 = malloc(0x40);
    printf("[+] ptr3 = malloc(0x40) → %p\n", ptr3);
    printf("    Fastbin: ...\n");

    // === ÉTAPE 6 : Vérification ===
    printf("\n=== ÉTAPE 6 : Vérification ===\n");
    printf("[*] ptr1 == ptr3 ? %s\n", (ptr1 == ptr3) ? "OUI!" : "NON");
    printf("[*] ptr1: %p\n", ptr1);
    printf("[*] ptr3: %p\n", ptr3);

    if (ptr1 == ptr3) {
        printf("\n[!] EXPLOITATION RÉUSSIE !\n");
        printf("    ptr1 et ptr3 pointent vers la même mémoire\n");
        printf("    Conséquences:\n");
        printf("    - Écrire dans ptr1 affecte ptr3\n");
        printf("    - On peut créer des overlapping chunks\n");
        printf("    - Permet d'obtenir arbitrary write\n");
    }

    // === ÉTAPE 7 : Démonstration ===
    printf("\n=== ÉTAPE 7 : Démonstration ===\n");

    // Écrire dans ptr1
    strcpy((char *)ptr1, "AAAA");
    printf("[*] Écrit 'AAAA' dans ptr1\n");

    // Lire depuis ptr3
    printf("[*] Lecture depuis ptr3: %s\n", (char *)ptr3);
    printf("[+] Les deux pointeurs partagent la même mémoire !\n");

    // Nettoyage (ne pas free ptr1/ptr3 deux fois!)
    free(ptr2);
    free(ptr3);  // Libère aussi ptr1 (même adresse)
    free(chunk_c);

    printf("\n[+] Exercice terminé avec succès\n");
    return 0;
}
```

### Explication Détaillée

#### Protection contournée

```c
// glibc vérifie si le chunk au sommet de fastbin == chunk à libérer
// Protection basique contre double free consécutif

free(a);
free(a);  // ❌ DÉTECTÉ : "double free or corruption (fasttop)"

// CONTOURNEMENT : Intercaler un autre free
free(a);
free(b);  // OK
free(a);  // ✅ RÉUSSI : la protection ne regarde que le sommet
```

#### État de la Fastbin

```
INITIAL:
Fastbin → NULL

Après free(a):
Fastbin → [a] → NULL

Après free(b):
Fastbin → [b] → [a] → NULL

Après free(a) ENCORE:
Fastbin → [a] → [b] → [a] → [b] → [a] → ... (boucle!)
```

#### Exploitation

```
malloc(0x40) #1 → retourne a, Fastbin: [b] → [a] → ...
malloc(0x40) #2 → retourne b, Fastbin: [a] → ...
malloc(0x40) #3 → retourne a, Fastbin: ...

Maintenant ptr1 == ptr3 !
On peut écrire via ptr1, modifier le fd de ptr3, puis malloc() pour
obtenir un chunk à une adresse arbitraire !
```

### Résultat attendu
```
[*] Exercice 3 : Double Free / Fastbin Duplication
==========================================

[*] Technique: Fastbin Duplication
    Objectif: Obtenir 2 pointeurs vers la même adresse

=== ÉTAPE 1 : Allocations ===
[+] chunk_a: 0x555555559290
[+] chunk_b: 0x5555555592e0
[+] chunk_c: 0x555555559330

=== ÉTAPE 2 : free(chunk_a) ===
[+] Fastbin head → chunk_a
    Fastbin: [chunk_a] → NULL

=== ÉTAPE 3 : free(chunk_b) ===
[+] Fastbin head → chunk_b
    Fastbin: [chunk_b] → [chunk_a] → NULL

=== ÉTAPE 4 : free(chunk_a) ENCORE (Double Free!) ===
[+] Fastbin head → chunk_a
    Fastbin: [chunk_a] → [chunk_b] → [chunk_a] → ...
    ⚠️  Boucle dans la freelist !

=== ÉTAPE 5 : Réallocations ===
[+] ptr1 = malloc(0x40) → 0x555555559290
    Fastbin: [chunk_b] → [chunk_a] → ...
[+] ptr2 = malloc(0x40) → 0x5555555592e0
    Fastbin: [chunk_a] → ...
[+] ptr3 = malloc(0x40) → 0x555555559290
    Fastbin: ...

=== ÉTAPE 6 : Vérification ===
[*] ptr1 == ptr3 ? OUI!
[*] ptr1: 0x555555559290
[*] ptr3: 0x555555559290

[!] EXPLOITATION RÉUSSIE !
    ptr1 et ptr3 pointent vers la même mémoire
    Conséquences:
    - Écrire dans ptr1 affecte ptr3
    - On peut créer des overlapping chunks
    - Permet d'obtenir arbitrary write

=== ÉTAPE 7 : Démonstration ===
[*] Écrit 'AAAA' dans ptr1
[*] Lecture depuis ptr3: AAAA
[+] Les deux pointeurs partagent la même mémoire !

[+] Exercice terminé avec succès
```

---

## Exercice 4 : Challenge (Difficile)

### Objectif
Implémenter un Heap Spray pour augmenter les chances d'exploitation.

### Solution

```c
/*
 * Exercice 4 : Heap Spray
 * Technique pour créer un "terrain d'atterrissage" prévisible
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define SPRAY_COUNT 1000
#define SPRAY_SIZE  0x1000  // 4 KB par bloc
#define NOP_SLED_SIZE 0xF00 // NOP sled

// Shellcode simulé (affiche juste un message)
unsigned char fake_shellcode[] = {
    0x90, 0x90, 0x90, 0x90,  // NOPs
    // En réalité: code pour pop shell
    // Pour démo: on affiche juste l'adresse
};

// Structure pour tracker les allocations
typedef struct {
    void *address;
    size_t size;
} SprayBlock;

// Fonction pour afficher les adresses de spray
void print_spray_stats(SprayBlock *blocks, int count) {
    printf("\n[*] === STATISTIQUES HEAP SPRAY ===\n");

    // Trouver min et max
    uintptr_t min_addr = (uintptr_t)blocks[0].address;
    uintptr_t max_addr = (uintptr_t)blocks[0].address;

    for (int i = 1; i < count; i++) {
        uintptr_t addr = (uintptr_t)blocks[i].address;
        if (addr < min_addr) min_addr = addr;
        if (addr > max_addr) max_addr = addr;
    }

    printf("    Blocs alloués: %d\n", count);
    printf("    Taille par bloc: %zu bytes (0x%zx)\n", SPRAY_SIZE, SPRAY_SIZE);
    printf("    Taille totale: %zu MB\n", (count * SPRAY_SIZE) / (1024*1024));
    printf("    Plage d'adresses:\n");
    printf("        Min: 0x%lx\n", min_addr);
    printf("        Max: 0x%lx\n", max_addr);
    printf("        Span: 0x%lx (%zu MB)\n",
           max_addr - min_addr,
           (max_addr - min_addr) / (1024*1024));

    // Échantillon d'adresses
    printf("    Échantillon (10 premières adresses):\n");
    for (int i = 0; i < 10 && i < count; i++) {
        printf("        [%3d] %p\n", i, blocks[i].address);
    }

    printf("\n");
}

// Créer un bloc de spray
void* create_spray_block(void) {
    // Allouer le bloc
    unsigned char *block = malloc(SPRAY_SIZE);
    if (block == NULL) return NULL;

    // Remplir avec NOP sled
    memset(block, 0x90, NOP_SLED_SIZE);  // 0x90 = NOP sur x86/x64

    // Placer le "shellcode" à la fin
    size_t shellcode_offset = SPRAY_SIZE - sizeof(fake_shellcode);
    memcpy(block + shellcode_offset, fake_shellcode, sizeof(fake_shellcode));

    return block;
}

// Tester si une adresse est dans notre spray
int is_in_spray_range(void *addr, SprayBlock *blocks, int count) {
    uintptr_t target = (uintptr_t)addr;

    for (int i = 0; i < count; i++) {
        uintptr_t start = (uintptr_t)blocks[i].address;
        uintptr_t end = start + SPRAY_SIZE;

        if (target >= start && target < end) {
            return 1;  // Dans le spray !
        }
    }

    return 0;
}

int main() {
    printf("[*] Exercice 4 : Heap Spray\n");
    printf("==========================================\n\n");

    printf("[*] Stratégie de Heap Spray:\n");
    printf("    1. Allouer beaucoup de blocs identiques\n");
    printf("    2. Remplir chaque bloc avec: [NOP sled] + [shellcode]\n");
    printf("    3. Si on saute n'importe où dans un bloc,\n");
    printf("       on atterrit dans le NOP sled qui mène au shellcode\n\n");

    // Allouer le tableau de tracking
    SprayBlock *spray_blocks = malloc(SPRAY_COUNT * sizeof(SprayBlock));
    if (spray_blocks == NULL) {
        printf("[-] Erreur allocation tracking\n");
        return 1;
    }

    // === PHASE 1 : SPRAY ===
    printf("=== PHASE 1 : HEAP SPRAY ===\n");
    printf("[*] Allocation de %d blocs de %zu bytes...\n", SPRAY_COUNT, SPRAY_SIZE);

    int successful = 0;
    for (int i = 0; i < SPRAY_COUNT; i++) {
        void *block = create_spray_block();
        if (block != NULL) {
            spray_blocks[successful].address = block;
            spray_blocks[successful].size = SPRAY_SIZE;
            successful++;

            if ((i + 1) % 100 == 0) {
                printf("    Progress: %d/%d blocs\n", i + 1, SPRAY_COUNT);
            }
        }
    }

    printf("[+] Spray terminé: %d/%d blocs alloués\n", successful, SPRAY_COUNT);

    // Statistiques
    print_spray_stats(spray_blocks, successful);

    // === PHASE 2 : SIMULATION D'EXPLOITATION ===
    printf("=== PHASE 2 : SIMULATION D'EXPLOITATION ===\n");

    // Simuler une adresse "devinée"
    // En réalité, cela pourrait venir d'un UAF partiel, info leak, etc.
    uintptr_t guessed_addr = (uintptr_t)spray_blocks[successful/2].address + 0x500;

    printf("[*] Scénario: Nous avons un bug qui nous permet de sauter\n");
    printf("    à une adresse partiellement contrôlée\n");
    printf("[*] Adresse devinée: 0x%lx\n", guessed_addr);

    // Vérifier si dans le spray
    if (is_in_spray_range((void*)guessed_addr, spray_blocks, successful)) {
        printf("[+] EXPLOITATION RÉUSSIE !\n");
        printf("    L'adresse devinée tombe dans notre heap spray\n");
        printf("    → Exécution du shellcode garantie\n");

        // Trouver dans quel bloc
        for (int i = 0; i < successful; i++) {
            uintptr_t start = (uintptr_t)spray_blocks[i].address;
            uintptr_t end = start + SPRAY_SIZE;

            if (guessed_addr >= start && guessed_addr < end) {
                printf("    Bloc touché: #%d (%p)\n", i, spray_blocks[i].address);
                printf("    Offset dans le bloc: 0x%lx\n", guessed_addr - start);

                if ((guessed_addr - start) < NOP_SLED_SIZE) {
                    printf("    → Atterrissage dans le NOP sled\n");
                    printf("    → Glissera jusqu'au shellcode\n");
                } else {
                    printf("    → Atterrissage direct dans/après le shellcode\n");
                }
                break;
            }
        }
    } else {
        printf("[-] Raté: L'adresse n'est pas dans notre spray\n");
        printf("    Solution: Augmenter SPRAY_COUNT\n");
    }

    // === PHASE 3 : CALCUL DE PROBABILITÉS ===
    printf("\n=== PHASE 3 : ANALYSE DE FIABILITÉ ===\n");

    uintptr_t min_addr = (uintptr_t)spray_blocks[0].address;
    uintptr_t max_addr = (uintptr_t)spray_blocks[0].address;

    for (int i = 1; i < successful; i++) {
        uintptr_t addr = (uintptr_t)spray_blocks[i].address;
        if (addr < min_addr) min_addr = addr;
        if (addr > max_addr) max_addr = addr;
    }

    uintptr_t total_spray = successful * SPRAY_SIZE;
    uintptr_t address_space = max_addr - min_addr + SPRAY_SIZE;

    double coverage = (double)total_spray / (double)address_space * 100.0;

    printf("[*] Couverture du heap:\n");
    printf("    Espace total occupé: %zu MB\n", total_spray / (1024*1024));
    printf("    Plage d'adresses: %zu MB\n", address_space / (1024*1024));
    printf("    Couverture: %.2f%%\n", coverage);
    printf("\n");
    printf("[*] Probabilité de succès:\n");
    printf("    Si on devine une adresse aléatoire dans la plage,\n");
    printf("    chances de tomber dans le spray: %.2f%%\n", coverage);

    // === NETTOYAGE ===
    printf("\n=== NETTOYAGE ===\n");
    for (int i = 0; i < successful; i++) {
        free(spray_blocks[i].address);
    }
    free(spray_blocks);
    printf("[+] Mémoire libérée\n");

    printf("\n[+] Exercice terminé avec succès\n");
    printf("\n[*] Applications réelles du Heap Spray:\n");
    printf("    - Exploitation de navigateurs (JavaScript heap spray)\n");
    printf("    - Contournement ASLR partiel\n");
    printf("    - Exploitation sans information leak\n");
    printf("    - Augmenter la fiabilité d'exploits UAF\n");

    return 0;
}
```

### Explication Détaillée

#### Concept du Heap Spray

```
OBJECTIF:
Remplir le heap avec des copies identiques de:
[NOP sled (0x90 x N)] + [shellcode]

RÉSULTAT:
┌─────────────────────────────────────────────────────┐
│ Adresse       Contenu                               │
├─────────────────────────────────────────────────────┤
│ 0x10000000    [NOP NOP NOP ... shellcode]          │
│ 0x10001000    [NOP NOP NOP ... shellcode]          │
│ 0x10002000    [NOP NOP NOP ... shellcode]          │
│ ...           ...                                   │
│ 0x20000000    [NOP NOP NOP ... shellcode]          │
└─────────────────────────────────────────────────────┘

Si on saute ANYWHERE entre 0x10000000 et 0x20000000,
on a de fortes chances de tomber dans un NOP sled !
```

#### NOP Sled (Toboggan de NOPs)

```
NOP = No Operation (0x90 sur x86/x64)
CPU exécute et passe à l'instruction suivante

Séquence:
0x1000: NOP    → va à 0x1001
0x1001: NOP    → va à 0x1002
0x1002: NOP    → va à 0x1003
...
0x0F00: NOP    → va à 0x0F01
0x0F01: [début du shellcode]

Peu importe OÙ on saute dans le bloc (tant que dans le NOP sled),
on glisse jusqu'au shellcode !
```

#### Cas d'usage réel

```c
// JavaScript Heap Spray (navigateur)
var spray = [];
var shellcode = unescape("%u9090%u9090...%uCC90");  // NOP + shellcode

for (var i = 0; i < 1000; i++) {
    spray[i] = shellcode + shellcode + shellcode + ...;
}

// Maintenant le heap JavaScript contient 1000 copies
// Si une vulnérabilité permet de sauter à une adresse,
// chances élevées de tomber dans notre shellcode !
```

### Résultat attendu
```
[*] Exercice 4 : Heap Spray
==========================================

[*] Stratégie de Heap Spray:
    1. Allouer beaucoup de blocs identiques
    2. Remplir chaque bloc avec: [NOP sled] + [shellcode]
    3. Si on saute n'importe où dans un bloc,
       on atterrit dans le NOP sled qui mène au shellcode

=== PHASE 1 : HEAP SPRAY ===
[*] Allocation de 1000 blocs de 4096 bytes...
    Progress: 100/1000 blocs
    Progress: 200/1000 blocs
    Progress: 300/1000 blocs
    Progress: 400/1000 blocs
    Progress: 500/1000 blocs
    Progress: 600/1000 blocs
    Progress: 700/1000 blocs
    Progress: 800/1000 blocs
    Progress: 900/1000 blocs
    Progress: 1000/1000 blocs
[+] Spray terminé: 1000/1000 blocs alloués

[*] === STATISTIQUES HEAP SPRAY ===
    Blocs alloués: 1000
    Taille par bloc: 4096 bytes (0x1000)
    Taille totale: 3 MB
    Plage d'adresses:
        Min: 0x555555559000
        Max: 0x555555959000
        Span: 0x400000 (4 MB)
    Échantillon (10 premières adresses):
        [  0] 0x555555559290
        [  1] 0x55555555a2b0
        [  2] 0x55555555b2d0
        [  3] 0x55555555c2f0
        [  4] 0x55555555d310
        [  5] 0x55555555e330
        [  6] 0x55555555f350
        [  7] 0x555555560370
        [  8] 0x555555561390
        [  9] 0x5555555623b0

=== PHASE 2 : SIMULATION D'EXPLOITATION ===
[*] Scénario: Nous avons un bug qui nous permet de sauter
    à une adresse partiellement contrôlée
[*] Adresse devinée: 0x5555556d9500
[+] EXPLOITATION RÉUSSIE !
    L'adresse devinée tombe dans notre heap spray
    → Exécution du shellcode garantie
    Bloc touché: #500 (0x5555556d9000)
    Offset dans le bloc: 0x500
    → Atterrissage dans le NOP sled
    → Glissera jusqu'au shellcode

=== PHASE 3 : ANALYSE DE FIABILITÉ ===
[*] Couverture du heap:
    Espace total occupé: 3 MB
    Plage d'adresses: 4 MB
    Couverture: 75.00%

[*] Probabilité de succès:
    Si on devine une adresse aléatoire dans la plage,
    chances de tomber dans le spray: 75.00%

=== NETTOYAGE ===
[+] Mémoire libérée

[+] Exercice terminé avec succès

[*] Applications réelles du Heap Spray:
    - Exploitation de navigateurs (JavaScript heap spray)
    - Contournement ASLR partiel
    - Exploitation sans information leak
    - Augmenter la fiabilité d'exploits UAF
```

---

## Bonus : Heap Grooming

### Objectif
Contrôler le layout du heap pour placer des chunks de manière prévisible.

### Solution

```c
/*
 * BONUS : Heap Grooming (Heap Feng Shui)
 * Technique pour contrôler le layout du heap
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CHUNK_SIZE 0x80

// Afficher l'état du heap
void print_heap_layout(void **chunks, int count, const char *labels[]) {
    printf("[*] Layout actuel du heap:\n");
    for (int i = 0; i < count; i++) {
        if (chunks[i] != NULL) {
            printf("    [%2d] %p : %s\n", i, chunks[i], labels[i]);
        } else {
            printf("    [%2d] (freed)    : %s\n", i, labels[i]);
        }
    }
    printf("\n");
}

int main() {
    printf("[*] BONUS : Heap Grooming\n");
    printf("==========================================\n\n");

    void *chunks[10];
    const char *labels[10];

    // === PHASE 1 : Remplir le heap ===
    printf("=== PHASE 1 : Remplir le heap ===\n");

    for (int i = 0; i < 10; i++) {
        chunks[i] = malloc(CHUNK_SIZE);
        labels[i] = "padding";
        memset(chunks[i], 'A' + i, CHUNK_SIZE);
    }

    print_heap_layout(chunks, 10, labels);

    // === PHASE 2 : Créer des trous ===
    printf("=== PHASE 2 : Libérer chunks alternés ===\n");
    printf("[*] Libération des chunks pairs (0, 2, 4, 6, 8)\n\n");

    for (int i = 0; i < 10; i += 2) {
        free(chunks[i]);
        chunks[i] = NULL;
    }

    print_heap_layout(chunks, 10, labels);

    // === PHASE 3 : Placement contrôlé ===
    printf("=== PHASE 3 : Allocations ciblées ===\n");

    // Le prochain malloc() réutilisera un des trous
    void *victim = malloc(CHUNK_SIZE);
    strcpy(victim, "VICTIM_DATA");

    void *attacker = malloc(CHUNK_SIZE);
    strcpy(attacker, "ATTACKER_DATA");

    printf("[+] victim alloué à: %p\n", victim);
    printf("[+] attacker alloué à: %p\n", attacker);

    // Vérifier s'ils sont adjacents
    if ((char*)attacker == (char*)victim + CHUNK_SIZE + 16) {
        printf("[+] SUCCÈS: attacker est adjacent à victim !\n");
        printf("    → Overflow dans attacker peut corrompre victim\n");
    }

    // === PHASE 4 : Démonstration overflow ===
    printf("\n=== PHASE 4 : Démonstration overflow ===\n");

    printf("[*] Contenu avant overflow:\n");
    printf("    victim: %s\n", (char*)victim);
    printf("    attacker: %s\n", (char*)attacker);

    // Overflow dans attacker (SIMULATION)
    printf("\n[*] Overflow dans attacker...\n");
    // En réalité: memcpy(attacker, evil_data, CHUNK_SIZE + overflow)
    // Pour démo, on modifie juste directement

    printf("[!] Dans un vrai exploit, on pourrait:\n");
    printf("    - Écraser les métadonnées du chunk victim\n");
    printf("    - Modifier le pointeur fd/bk\n");
    printf("    - Déclencher unlink() pour arbitrary write\n");

    // Nettoyage
    free(victim);
    free(attacker);
    for (int i = 1; i < 10; i += 2) {
        if (chunks[i] != NULL) free(chunks[i]);
    }

    printf("\n[+] Exercice BONUS terminé\n");
    printf("\n[*] Le Heap Grooming est crucial pour:\n");
    printf("    - Exploiter heap overflow de manière fiable\n");
    printf("    - Placer victim et attacker de manière prévisible\n");
    printf("    - Contourner les allocateurs modernes\n");

    return 0;
}
```

---

## Critères de Réussite

Avant de passer au module suivant, tu dois :

- [ ] Comprendre le concept de Use-After-Free
- [ ] Savoir exploiter un UAF avec pointeur de fonction
- [ ] Maîtriser la technique du double free (fastbin dup)
- [ ] Comprendre le principe du heap spray
- [ ] Savoir créer un NOP sled
- [ ] Comprendre le heap grooming
- [ ] Identifier ces vulnérabilités dans du code réel
- [ ] Connaître les protections modernes (safe-linking, tcache key)

---

**Prochaine étape :** Phase OS-spécifique (Windows/Linux/macOS)
