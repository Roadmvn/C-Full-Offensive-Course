# 29 - Architecture ARM64 (AArch64)

## ğŸ¯ Ce que tu vas apprendre

- Comprendre l'architecture ARM64 (AArch64) utilisÃ©e par Apple Silicon
- MaÃ®triser les registres, instructions et conventions d'appel ARM64
- Ã‰crire du code assembleur ARM64 pour macOS
- Exploiter les syscalls macOS ARM64 pour la Red Team

## ğŸ“š ThÃ©orie

### Concept 1 : ARM64 vs x86-64

**C'est quoi ?**

Les Mac modernes (depuis 2020) utilisent des **puces Apple Silicon** (M1, M2, M3, M4) basÃ©es sur l'architecture **ARM64** (aussi appelÃ©e AArch64). Contrairement aux anciens Mac Intel qui utilisaient x86-64, ARM64 fonctionne trÃ¨s diffÃ©remment.

### 1.1 Qu'est-ce que l'Assembleur ?

L'**assembleur** est le langage le plus proche du processeur. Chaque instruction assembleur correspond Ã  **une seule opÃ©ration** que le CPU peut effectuer.

```ascii
NIVEAUX DE PROGRAMMATION :

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  C / Python / Java      â”‚  â† Haut niveau (humain)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“ Compilation
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Assembleur (ASM)       â”‚  â† Bas niveau (proche CPU)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“ Assemblage
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Code Machine (Bytes)   â”‚  â† Ce que le CPU exÃ©cute
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Exemple :
C:          int x = 5 + 3;
ASM:        mov x0, #5
            add x0, x0, #3
Machine:    0xD2800A00 0x91000C00
```

### 1.2 RISC vs CISC

**ARM64 = RISC** (Reduced Instruction Set Computer)
- Instructions **simples** et **uniformes**
- **Beaucoup de registres** (31 registres gÃ©nÃ©raux)
- Toutes les instructions font **4 octets** (32 bits)
- ExÃ©cution **rapide** (1-2 cycles par instruction)

**x86-64 = CISC** (Complex Instruction Set Computer)
- Instructions **complexes** et **variables**
- Moins de registres (16 principaux)
- Instructions de **1 Ã  15 octets**
- CompatibilitÃ© avec x86 32-bit

```ascii
COMPARAISON :

ARM64 (RISC)                    x86-64 (CISC)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Instruction  â”‚ 4 bytes       â”‚ Instruction  â”‚ 1-15 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Instruction  â”‚ 4 bytes       â”‚ Instruction  â”‚ 1-15 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Instruction  â”‚ 4 bytes       â”‚ Instruction  â”‚ 1-15 bytes
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Uniforme                       Variable
```

## 2. Registres ARM64 - Le Tableau de Bord du CPU

### 2.1 Vue d'Ensemble des 31 Registres

ARM64 dispose de **31 registres gÃ©nÃ©raux** de 64 bits, numÃ©rotÃ©s **X0 Ã  X30**, plus des registres spÃ©ciaux.

```ascii
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    REGISTRES ARM64                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ NOM           â”‚ USAGE                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ X0 - X7       â”‚ Arguments de fonction (8 premiers)          â”‚
â”‚               â”‚ X0 aussi utilisÃ© pour RETOUR                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ X8            â”‚ Indirect result location (struct return)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ X9 - X15      â”‚ Registres temporaires (Caller-saved)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ X16, X17      â”‚ Intra-procedure call (IP0, IP1)             â”‚
â”‚               â”‚ X16 = NumÃ©ro SYSCALL sur macOS !            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ X18           â”‚ RÃ©servÃ© plateforme (ne pas utiliser)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ X19 - X28     â”‚ Registres sauvegardÃ©s (Callee-saved)        â”‚
â”‚               â”‚ Doivent Ãªtre prÃ©servÃ©s dans fonctions       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ X29 (FP)      â”‚ Frame Pointer (base de la stack frame)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ X30 (LR)      â”‚ Link Register (adresse de retour)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SP            â”‚ Stack Pointer (sommet de la pile)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PC            â”‚ Program Counter (instruction courante)      â”‚
â”‚               â”‚ Non accessible directement                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Registres 32-bit vs 64-bit

Chaque registre peut Ãªtre utilisÃ© en **64-bit** (X) ou **32-bit** (W) :

```ascii
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Registre 64-bit : X0 (8 octets)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 63                                                        0 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚                     64 bits                           â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚           Registre 32-bit : W0 (4 octets)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 31                             0                            â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚ â”‚         32 bits               â”‚ â† Utilise moitiÃ© basse    â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Exemple** :
```asm
mov x0, #0xFFFFFFFFFFFFFFFF    ; X0 = 64 bits tous Ã  1
mov w0, #0x12345678            ; W0 = 32 bits (met Ã  0 les 32 bits hauts de X0)
```

### 2.3 Registres SpÃ©ciaux DÃ©taillÃ©s

#### X29 - Frame Pointer (FP)

Le **Frame Pointer** marque le **dÃ©but** de la stack frame d'une fonction.

```ascii
STACK MEMORY :

Higher addresses â†‘
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† FP (X29) pointe ici
    â”‚ Variables  â”‚
    â”‚ locales    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† SP (Stack Pointer) descend ici
    â”‚            â”‚
    â†“            â†“
Lower addresses
```

#### X30 - Link Register (LR)

Contient l'**adresse de retour** quand une fonction est appelÃ©e.

```ascii
APPEL DE FONCTION :

main() appelle fonction_a()

AVANT BL (Branch with Link) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ main()       â”‚
â”‚ ...          â”‚
â”‚ BL fonction_aâ”‚ â† PC est ici
â”‚ ...          â”‚  â† Adresse de retour
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

APRÃˆS BL :
- PC saute Ã  fonction_a
- LR (X30) = adresse de l'instruction aprÃ¨s BL
- fonction_a peut faire RET pour revenir

RET = saute Ã  l'adresse dans LR
```

#### SP - Stack Pointer

Pointe vers le **sommet** de la pile (stack). Descend quand on alloue, monte quand on libÃ¨re.

```ascii
Ã‰VOLUTION DU STACK POINTER :

Initial :
    SP â†’ â”Œâ”€â”€â”€â”€â”  0x7FF000
         â”‚    â”‚
         â””â”€â”€â”€â”€â”˜

AprÃ¨s "SUB SP, SP, #16" (allouer 16 bytes) :
         â”Œâ”€â”€â”€â”€â”  0x7FF000
         â”‚    â”‚
    SP â†’ â”œâ”€â”€â”€â”€â”¤  0x7FEFF0 (SP - 16)
         â”‚ 16 â”‚
         â”‚bytesâ”‚
         â””â”€â”€â”€â”€â”˜

La pile DESCEND (vers adresses plus basses)
```

## 3. Instructions de Base - DÃ©taillÃ©es

### 3.1 MOV - DÃ©placer des DonnÃ©es

#### Syntaxe

```asm
MOV destination, source
```

#### Types de MOV

```asm
; Constante immÃ©diate (# = immÃ©diat)
mov x0, #42          ; X0 = 42
mov x0, #0x1234      ; X0 = 0x1234 (hexa)

; Registre vers registre
mov x1, x0           ; X1 = X0

; Grande constante (nÃ©cessite plusieurs instructions)
mov x0, #0x1234      ; Bits bas
movk x0, #0x5678, lsl #16  ; Bits suivants
```

**âš ï¸ Limitation** : On ne peut pas charger directement de grandes valeurs (> 16 bits par instruction).

### 3.2 LDR/STR - Load/Store (AccÃ¨s MÃ©moire)

En ARM64, on ne peut **pas** accÃ©der directement Ã  la mÃ©moire dans les opÃ©rations arithmÃ©tiques. Il faut **charger** en registre d'abord.

#### LDR - Load Register (Lire depuis mÃ©moire)

```asm
; Charger 64 bits
ldr x0, [x1]         ; X0 = *X1 (lire 8 octets Ã  l'adresse X1)

; Charger 32 bits
ldr w0, [x1]         ; W0 = *(int*)X1 (4 octets)

; Charger 8 bits (byte)
ldrb w0, [x1]        ; W0 = *(char*)X1 (1 octet)

; Avec offset
ldr x0, [x1, #8]     ; X0 = *(X1 + 8)

; Post-increment
ldr x0, [x1], #8     ; X0 = *X1, puis X1 += 8

; Pre-increment
ldr x0, [x1, #8]!    ; X1 += 8, puis X0 = *X1
```

**Visualisation** :

```ascii
MÃ‰MOIRE :
         X1 = 0x1000
              â†“
0x1000   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   42   â”‚  â† Valeur stockÃ©e ici
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

APRÃˆS "ldr x0, [x1]" :
X0 = 42  (valeur lue)
X1 = 0x1000  (inchangÃ©)
```

#### STR - Store Register (Ã‰crire en mÃ©moire)

```asm
str x0, [x1]         ; *X1 = X0 (Ã©crire X0 Ã  l'adresse X1)
str w0, [sp, #4]     ; *(SP + 4) = W0 (32 bits)
strb w0, [x1]        ; *(char*)X1 = W0 (1 octet)
```

### 3.3 STP/LDP - Store/Load Pair

OpÃ©rations sur **deux registres** Ã  la fois (optimisation).

```asm
; Sauvegarder FP et LR (prologue de fonction)
stp x29, x30, [sp, #-16]!   ; *(SP-16) = X29, *(SP-8) = X30, SP -= 16

; Restaurer FP et LR (Ã©pilogue de fonction)
ldp x29, x30, [sp], #16     ; X29 = *SP, X30 = *(SP+8), SP += 16
```

**Visualisation** :

```ascii
AVANT "stp x29, x30, [sp, #-16]!" :

SP â†’ 0x1000 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚        â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

APRÃˆS :
     0x1000 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  ...   â”‚
     0x0FF8 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚  X30   â”‚  â† LR sauvegardÃ©
     0x0FF0 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤
SP â†’ 0x0FF0 â”‚  X29   â”‚  â† FP sauvegardÃ©
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Le "!" signifie "write-back" : SP est mis Ã  jour
```

### 3.4 ADD/SUB - ArithmÃ©tique

```asm
; Addition
add x0, x1, x2       ; X0 = X1 + X2
add x0, x0, #10      ; X0 = X0 + 10

; Soustraction
sub x0, x1, x2       ; X0 = X1 - X2
sub sp, sp, #32      ; Allouer 32 bytes sur la stack
```

**Autres opÃ©rations** :
```asm
mul x0, x1, x2       ; X0 = X1 * X2
sdiv x0, x1, x2      ; X0 = X1 / X2 (signed division)
and x0, x1, x2       ; X0 = X1 & X2 (ET binaire)
orr x0, x1, x2       ; X0 = X1 | X2 (OU binaire)
eor x0, x1, x2       ; X0 = X1 ^ X2 (XOR binaire)
```

### 3.5 Branches (Sauts)

#### B - Branch Incondi tionnel

```asm
b loop              ; Saute Ã  l'Ã©tiquette "loop"
```

#### BL - Branch with Link (Appel de Fonction)

```asm
bl fonction         ; LR = adresse suivante, puis saute Ã  "fonction"
```

#### Branches Conditionnelles

```asm
; AprÃ¨s une comparaison (CMP)
cmp x0, #10         ; Compare X0 avec 10
b.eq equal          ; Branch if Equal
b.ne not_equal      ; Branch if Not Equal
b.gt greater        ; Branch if Greater Than
b.lt less           ; Branch if Less Than
b.ge greater_equal  ; Branch if Greater or Equal
b.le less_equal     ; Branch if Less or Equal
```

#### CBZ/CBNZ - Compare and Branch if Zero

```asm
cbz x0, label       ; Si X0 == 0, saute Ã  label
cbnz x0, label      ; Si X0 != 0, saute Ã  label
```

### 3.6 RET - Retour de Fonction

```asm
ret                 ; PC = LR (saute Ã  l'adresse dans X30)
```

### 3.7 SVC - Supervisor Call (Syscall)

TransfÃ¨re le contrÃ´le au **noyau** (kernel) en mode privilÃ©giÃ©.

```asm
svc #0x80           ; Appel systÃ¨me (macOS)
svc #0              ; Appel systÃ¨me (Linux ARM)
```

**Sur macOS** : Le numÃ©ro de syscall doit Ãªtre dans **X16** (pas X8 comme Linux).

## 4. Convention d'Appel ARM64 (AAPCS64)

### 4.1 Passage d'Arguments

Les **8 premiers arguments** vont dans X0-X7. Les suivants sur la **stack**.

```ascii
void fonction(int a, int b, int c, int d, int e, int f, int g, int h, int i);
              â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚
              X0   X1   X2   X3   X4   X5   X6   X7   Stack
```

**Exemple** :
```c
int add(int a, int b) {
    return a + b;
}
```

En ARM64 :
```asm
_add:
    add x0, x0, x1      ; X0 = X0 (a) + X1 (b)
    ret                 ; Retourne X0
```

### 4.2 Valeur de Retour

Le rÃ©sultat d'une fonction est **toujours** dans **X0** (ou W0 pour 32-bit).

```asm
_fonction:
    mov x0, #42         ; PrÃ©parer valeur de retour
    ret                 ; Retourner 42
```

### 4.3 Registres Ã  PrÃ©server

Si une fonction utilise **X19-X28**, elle **doit** les sauvegarder et restaurer.

```asm
_fonction:
    ; Prologue : sauvegarder registres utilisÃ©s
    stp x19, x20, [sp, #-16]!
    
    ; Corps de la fonction
    mov x19, #100       ; Utiliser X19
    
    ; Ã‰pilogue : restaurer
    ldp x19, x20, [sp], #16
    ret
```

## 5. Syscalls macOS ARM64 - En DÃ©tail

### 5.1 DiffÃ©rence avec Linux

| Aspect | Linux ARM64 | macOS ARM64 |
|--------|-------------|-------------|
| NumÃ©ro syscall | **X8** | **X16** |
| Instruction | `SVC #0` | `SVC #0x80` |
| NumÃ©ros | 0, 1, 2... | 0x2000000+ |

### 5.2 Syscalls Courants macOS

```ascii
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Syscall      â”‚ NumÃ©ro X16  â”‚ Arguments              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ exit         â”‚ 0x2000001   â”‚ X0 = code              â”‚
â”‚ fork         â”‚ 0x2000002   â”‚ -                      â”‚
â”‚ read         â”‚ 0x2000003   â”‚ X0=fd, X1=buf, X2=len  â”‚
â”‚ write        â”‚ 0x2000004   â”‚ X0=fd, X1=buf, X2=len  â”‚
â”‚ open         â”‚ 0x2000005   â”‚ X0=path, X1=flags      â”‚
â”‚ close        â”‚ 0x2000006   â”‚ X0=fd                  â”‚
â”‚ execve       â”‚ 0x200003B   â”‚ X0=path, X1=argv, X2=e â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.3 Exemple DÃ©taillÃ© : write("Hello\n")

**En C** :
```c
write(1, "Hello\n", 6);
```

**En ARM64** :
```asm
.global _main
.align 2

_main:
    ; PrÃ©parer les arguments
    mov x0, #1              ; Argument 1 : fd = 1 (stdout)
    adr x1, msg             ; Argument 2 : adresse du buffer
    mov x2, #6              ; Argument 3 : longueur (6 bytes)
    
    ; Appel syscall write
    mov x16, #0x2000004     ; NumÃ©ro syscall write
    svc #0x80               ; ExÃ©cuter syscall
    
    ; Syscall exit
    mov x0, #0              ; Code de retour = 0
    mov x16, #0x2000001     ; NumÃ©ro syscall exit
    svc #0x80
    
msg:
    .ascii "Hello\n"
```

**Ã‰tape par Ã©tape** :

```ascii
Ã‰TAPE 1 : PrÃ©parer X0
    mov x0, #1
    â”Œâ”€â”€â”€â”€â”
X0  â”‚ 1  â”‚  â† File descriptor (stdout)
    â””â”€â”€â”€â”€â”˜

Ã‰TAPE 2 : PrÃ©parer X1
    adr x1, msg
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
X1  â”‚ 0x100008 â”‚  â† Adresse de "Hello\n" en mÃ©moire
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰TAPE 3 : PrÃ©parer X2
    mov x2, #6
    â”Œâ”€â”€â”€â”€â”
X2  â”‚ 6  â”‚  â† Nombre d'octets Ã  Ã©crire
    â””â”€â”€â”€â”€â”˜

Ã‰TAPE 4 : NumÃ©ro syscall
    mov x16, #0x2000004
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
X16 â”‚ 0x2000004  â”‚  â† Syscall number (write)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰TAPE 5 : ExÃ©cuter
    svc #0x80
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  USER MODE      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â†“ SVC
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  KERNEL MODE    â”‚ â† Noyau prend le contrÃ´le
    â”‚  ExÃ©cute write()â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â†“ Retour
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  USER MODE      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 6. Structure d'une Fonction ARM64

### 6.1 Prologue et Ã‰pilogue

```asm
_ma_fonction:
    ; === PROLOGUE ===
    stp x29, x30, [sp, #-16]!   ; Sauvegarder FP et LR
    mov x29, sp                  ; Nouveau frame pointer
    sub sp, sp, #32              ; Allouer 32 bytes pour variables locales
    
    ; === CORPS ===
    ; ... code de la fonction ...
    mov x0, #42                  ; Valeur de retour
    
    ; === Ã‰PILOGUE ===
    add sp, sp, #32              ; LibÃ©rer variables locales
    ldp x29, x30, [sp], #16      ; Restaurer FP et LR
    ret                          ; Retourner (PC = LR)
```

**Visualisation Stack** :

```ascii
AVANT PROLOGUE :
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    SP â†’ â”‚         â”‚  0x1000
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

APRÃˆS PROLOGUE :
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Old FP  â”‚  0x1000
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
         â”‚ Old LR  â”‚  0x0FF8
FP â†’ X29 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  0x0FF0
         â”‚ Local 1 â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
         â”‚ Local 2 â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    SP â†’ â”‚ Local 3 â”‚  0x0FD0 (SP - 48)
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 Exemple Complet : Factorielle

```asm
; int factorial(int n)  // X0 = n
_factorial:
    ; Prologue
    stp x29, x30, [sp, #-16]!
    mov x29, sp
    
    ; Cas de base : if (n <= 1) return 1
    cmp x0, #1
    b.le .base_case
    
    ; Cas rÃ©cursif : return n * factorial(n-1)
    sub sp, sp, #16          ; Allouer pour sauvegarder n
    str x0, [sp]             ; Sauvegarder n
    
    sub x0, x0, #1           ; X0 = n - 1
    bl _factorial            ; Appel rÃ©cursif
    
    ldr x1, [sp]             ; Charger n dans X1
    add sp, sp, #16          ; LibÃ©rer
    
    mul x0, x0, x1           ; X0 = factorial(n-1) * n
    b .epilogue
    
.base_case:
    mov x0, #1               ; Retourner 1
    
.epilogue:
    ; Ã‰pilogue
    ldp x29, x30, [sp], #16
    ret

; factorial(5) :
; 5 * factorial(4)
; 5 * 4 * factorial(3)
; 5 * 4 * 3 * factorial(2)
; 5 * 4 * 3 * 2 * factorial(1)
; 5 * 4 * 3 * 2 * 1 = 120
```

## 7. Comparaison ARM64 vs x86-64

### 7.1 Hello World Comparaison

**ARM64 (macOS)** :
```asm
mov x0, #1              ; 4 bytes
adr x1, msg             ; 4 bytes
mov x2, #13             ; 4 bytes
mov x16, #0x2000004     ; 4 bytes
svc #0x80               ; 4 bytes
```

**x86-64 (Linux)** :
```asm
mov rax, 1              ; Syscall number (variable length)
mov rdi, 1              ; fd
lea rsi, [msg]          ; buffer
mov rdx, 13             ; length
syscall                 ; Syscall
```

### 7.2 DiffÃ©rences Architecturales

| Aspect | ARM64 | x86-64 |
|--------|-------|--------|
| **Instructions** | 4 bytes fixes | 1-15 bytes variables |
| **Registres** | 31 gÃ©nÃ©raux | 16 gÃ©nÃ©raux |
| **AccÃ¨s mÃ©moire** | LDR/STR sÃ©parÃ©s | MOV direct possible |
| **Philosophie** | RISC (simple) | CISC (complexe) |
| **Endianness** | Little-endian | Little-endian |

## 8. Adressage MÃ©moire

### 8.1 ADR vs LDR

**ADR** : Address of label (PC-relative)
```asm
adr x0, msg         ; X0 = adresse de "msg" (calculÃ© depuis PC)
```

**LDR avec litÃ©ral** :
```asm
ldr x0, =msg        ; Pseudo-instruction : charge l'adresse
```

**LDR depuis mÃ©moire** :
```asm
ldr x0, [x1]        ; Charge la valeur Ã€ l'adresse X1
```

### 8.2 Position-Independent Code (PIC)

Le code doit fonctionner peu importe oÃ¹ il est chargÃ© en mÃ©moire (ASLR).

```asm
; BON : PC-relative
adr x0, data
ldr x1, [x0]

; MAUVAIS : Adresse absolue (ne marchera pas avec ASLR)
ldr x0, =0x100000
```

## 9. Registres de Flags (NZCV)

AprÃ¨s certaines opÃ©rations, des **flags** sont mis Ã  jour :

```ascii
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  N â”‚  Z â”‚  C â”‚  V â”‚  (Flags) â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 31 â”‚ 30 â”‚ 29 â”‚ 28 â”‚  (Bits)  â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

N = Negative (rÃ©sultat nÃ©gatif)
Z = Zero (rÃ©sultat zÃ©ro)
C = Carry (retenue)
V = Overflow (dÃ©bordement)
```

**Exemple** :
```asm
subs x0, x1, x2     ; X0 = X1 - X2, met Ã  jour les flags
b.mi negative       ; Branch if Minus (N=1)
```

## 10. Exemple Complet AnnotÃ©

```asm
.global _main
.align 2

; Point d'entrÃ©e du programme
_main:
    ; === PROLOGUE ===
    ; Sauvegarder le Frame Pointer et Link Register sur la stack
    stp x29, x30, [sp, #-16]!   ; *(SP-16)=X29, *(SP-8)=X30, SP-=16
    mov x29, sp                  ; FP = SP (nouveau frame)
    
    ; === APPEL write() ===
    mov x0, #1                   ; Arg 1 : fd = 1 (stdout)
    adr x1, hello_msg            ; Arg 2 : adresse message
    mov x2, #13                  ; Arg 3 : longueur
    mov x16, #0x2000004          ; Syscall write = 4 (macOS offset 0x2000000)
    svc #0x80                    ; Appel noyau
    
    ; === RETOUR ===
    mov x0, #0                   ; Code de retour = 0 (succÃ¨s)
    
    ; === Ã‰PILOGUE ===
    ldp x29, x30, [sp], #16      ; Restaurer FP et LR, SP+=16
    ret                          ; PC = LR (retour Ã  l'appelant)

; === SECTION DATA ===
hello_msg:
    .ascii "Hello ARM64!\n"
    
; Fin du programme
```

**Explication Ligne par Ligne** :

1. `.global _main` : Rend `_main` visible au linker
2. `.align 2` : Aligne sur 4 bytes (2^2)
3. `stp x29, x30, [sp, #-16]!` : 
   - Descend SP de 16
   - Sauvegarde FP Ã  (SP)
   - Sauvegarde LR Ã  (SP+8)
4. `mov x29, sp` : Frame pointer = stack pointer actuel
5. `mov x0, #1` : Premier argument de write() = stdout
6. `adr x1, hello_msg` : X1 = adresse de la string
7. `mov x2, #13` : Longueur = 13 caractÃ¨res
8. `mov x16, #0x2000004` : NumÃ©ro syscall write
9. `svc #0x80` : Appel kernel
10. `mov x0, #0` : Code de retour 0
11. `ldp x29, x30, [sp], #16` : Restaure FP et LR
12. `ret` : Retourne Ã  l'appelant

## 11. DiffÃ©rences ARM64 vs x86-64 - Tableau RÃ©capitulatif

| Concept | ARM64 | x86-64 |
|---------|-------|--------|
| **Registres arguments** | X0-X7 | RDI, RSI, RDX, RCX, R8, R9 |
| **Retour fonction** | X0 | RAX |
| **Stack pointer** | SP | RSP |
| **Frame pointer** | X29 (FP) | RBP |
| **Link register** | X30 (LR) | (sur stack) |
| **Syscall register** | X16 (macOS) | RAX |
| **Syscall instruction** | SVC #0x80 | SYSCALL |
| **Taille instruction** | 4 bytes fixe | 1-15 bytes |
| **AccÃ¨s mÃ©moire** | LDR/STR | MOV direct |

## 12. Glossaire des Termes Techniques

- **AAPCS64** : ARM Architecture Procedure Call Standard (convention d'appel)
- **AArch64** : Architecture ARM 64-bit
- **Caller-saved** : Registres que l'appelant doit sauvegarder
- **Callee-saved** : Registres que la fonction appelÃ©e doit sauvegarder
- **Frame Pointer** : Pointeur vers la base de la stack frame
- **Link Register** : Registre contenant l'adresse de retour
- **PC-relative** : Adressage relatif au Program Counter
- **RISC** : Reduced Instruction Set Computer
- **SVC** : Supervisor Call (appel systÃ¨me)
- **Write-back** : Mise Ã  jour automatique du registre d'adresse

## 13. Ressources ComplÃ©mentaires

- [ARM Architecture Reference Manual](https://developer.arm.com/documentation/ddi0487/)
- [Apple Silicon ABI](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms)
- [ARM Instruction Set](https://developer.arm.com/documentation/ddi0596/)
- [macOS System Calls](https://opensource.apple.com/source/xnu/)
