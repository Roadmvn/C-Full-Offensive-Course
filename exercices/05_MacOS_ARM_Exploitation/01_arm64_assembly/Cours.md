# Cours : Assembleur ARM64 (AArch64) pour macOS

## 1. Introduction - Pourquoi ARM64 ?

Les Mac modernes (depuis 2020) utilisent des **puces Apple Silicon** (M1, M2, M3, M4) basées sur l'architecture **ARM64** (aussi appelée AArch64). Contrairement aux anciens Mac Intel qui utilisaient x86-64, ARM64 fonctionne très différemment.

### 1.1 Qu'est-ce que l'Assembleur ?

L'**assembleur** est le langage le plus proche du processeur. Chaque instruction assembleur correspond à **une seule opération** que le CPU peut effectuer.

```ascii
NIVEAUX DE PROGRAMMATION :

┌─────────────────────────┐
│  C / Python / Java      │  ← Haut niveau (humain)
└───────────┬─────────────┘
            ↓ Compilation
┌─────────────────────────┐
│  Assembleur (ASM)       │  ← Bas niveau (proche CPU)
└───────────┬─────────────┘
            ↓ Assemblage
┌─────────────────────────┐
│  Code Machine (Bytes)   │  ← Ce que le CPU exécute
└─────────────────────────┘

Exemple :
C:          int x = 5 + 3;
ASM:        mov x0, #5
            add x0, x0, #3
Machine:    0xD2800A00 0x91000C00
```

### 1.2 RISC vs CISC

**ARM64 = RISC** (Reduced Instruction Set Computer)
- Instructions **simples** et **uniformes**
- **Beaucoup de registres** (31 registres généraux)
- Toutes les instructions font **4 octets** (32 bits)
- Exécution **rapide** (1-2 cycles par instruction)

**x86-64 = CISC** (Complex Instruction Set Computer)
- Instructions **complexes** et **variables**
- Moins de registres (16 principaux)
- Instructions de **1 à 15 octets**
- Compatibilité avec x86 32-bit

```ascii
COMPARAISON :

ARM64 (RISC)                    x86-64 (CISC)
┌──────────────┐               ┌──────────────┐
│ Instruction  │ 4 bytes       │ Instruction  │ 1-15 bytes
├──────────────┤               ├──────────────┤
│ Instruction  │ 4 bytes       │ Instruction  │ 1-15 bytes
├──────────────┤               ├──────────────┤
│ Instruction  │ 4 bytes       │ Instruction  │ 1-15 bytes
└──────────────┘               └──────────────┘
    Uniforme                       Variable
```

## 2. Registres ARM64 - Le Tableau de Bord du CPU

### 2.1 Vue d'Ensemble des 31 Registres

ARM64 dispose de **31 registres généraux** de 64 bits, numérotés **X0 à X30**, plus des registres spéciaux.

```ascii
┌─────────────────────────────────────────────────────────────┐
│                    REGISTRES ARM64                          │
├───────────────┬─────────────────────────────────────────────┤
│ NOM           │ USAGE                                       │
├───────────────┼─────────────────────────────────────────────┤
│ X0 - X7       │ Arguments de fonction (8 premiers)          │
│               │ X0 aussi utilisé pour RETOUR                │
├───────────────┼─────────────────────────────────────────────┤
│ X8            │ Indirect result location (struct return)    │
├───────────────┼─────────────────────────────────────────────┤
│ X9 - X15      │ Registres temporaires (Caller-saved)        │
├───────────────┼─────────────────────────────────────────────┤
│ X16, X17      │ Intra-procedure call (IP0, IP1)             │
│               │ X16 = Numéro SYSCALL sur macOS !            │
├───────────────┼─────────────────────────────────────────────┤
│ X18           │ Réservé plateforme (ne pas utiliser)        │
├───────────────┼─────────────────────────────────────────────┤
│ X19 - X28     │ Registres sauvegardés (Callee-saved)        │
│               │ Doivent être préservés dans fonctions       │
├───────────────┼─────────────────────────────────────────────┤
│ X29 (FP)      │ Frame Pointer (base de la stack frame)      │
├───────────────┼─────────────────────────────────────────────┤
│ X30 (LR)      │ Link Register (adresse de retour)           │
├───────────────┼─────────────────────────────────────────────┤
│ SP            │ Stack Pointer (sommet de la pile)           │
├───────────────┼─────────────────────────────────────────────┤
│ PC            │ Program Counter (instruction courante)      │
│               │ Non accessible directement                  │
└───────────────┴─────────────────────────────────────────────┘
```

### 2.2 Registres 32-bit vs 64-bit

Chaque registre peut être utilisé en **64-bit** (X) ou **32-bit** (W) :

```ascii
┌─────────────────────────────────────────────────────────────┐
│           Registre 64-bit : X0 (8 octets)                   │
├─────────────────────────────────────────────────────────────┤
│ 63                                                        0 │
│ ┌───────────────────────────────────────────────────────┐   │
│ │                     64 bits                           │   │
│ └───────────────────────────────────────────────────────┘   │
│                                                             │
│           Registre 32-bit : W0 (4 octets)                   │
├─────────────────────────────────────────────────────────────┤
│ 31                             0                            │
│ ┌───────────────────────────────┐                           │
│ │         32 bits               │ ← Utilise moitié basse    │
│ └───────────────────────────────┘                           │
└─────────────────────────────────────────────────────────────┘
```

**Exemple** :
```asm
mov x0, #0xFFFFFFFFFFFFFFFF    ; X0 = 64 bits tous à 1
mov w0, #0x12345678            ; W0 = 32 bits (met à 0 les 32 bits hauts de X0)
```

### 2.3 Registres Spéciaux Détaillés

#### X29 - Frame Pointer (FP)

Le **Frame Pointer** marque le **début** de la stack frame d'une fonction.

```ascii
STACK MEMORY :

Higher addresses ↑
                 │
    ┌────────────┤  ← FP (X29) pointe ici
    │ Variables  │
    │ locales    │
    ├────────────┤  ← SP (Stack Pointer) descend ici
    │            │
    ↓            ↓
Lower addresses
```

#### X30 - Link Register (LR)

Contient l'**adresse de retour** quand une fonction est appelée.

```ascii
APPEL DE FONCTION :

main() appelle fonction_a()

AVANT BL (Branch with Link) :
┌──────────────┐
│ main()       │
│ ...          │
│ BL fonction_a│ ← PC est ici
│ ...          │  ← Adresse de retour
└──────────────┘

APRÈS BL :
- PC saute à fonction_a
- LR (X30) = adresse de l'instruction après BL
- fonction_a peut faire RET pour revenir

RET = saute à l'adresse dans LR
```

#### SP - Stack Pointer

Pointe vers le **sommet** de la pile (stack). Descend quand on alloue, monte quand on libère.

```ascii
ÉVOLUTION DU STACK POINTER :

Initial :
    SP → ┌────┐  0x7FF000
         │    │
         └────┘

Après "SUB SP, SP, #16" (allouer 16 bytes) :
         ┌────┐  0x7FF000
         │    │
    SP → ├────┤  0x7FEFF0 (SP - 16)
         │ 16 │
         │bytes│
         └────┘

La pile DESCEND (vers adresses plus basses)
```

## 3. Instructions de Base - Détaillées

### 3.1 MOV - Déplacer des Données

#### Syntaxe

```asm
MOV destination, source
```

#### Types de MOV

```asm
; Constante immédiate (# = immédiat)
mov x0, #42          ; X0 = 42
mov x0, #0x1234      ; X0 = 0x1234 (hexa)

; Registre vers registre
mov x1, x0           ; X1 = X0

; Grande constante (nécessite plusieurs instructions)
mov x0, #0x1234      ; Bits bas
movk x0, #0x5678, lsl #16  ; Bits suivants
```

**⚠️ Limitation** : On ne peut pas charger directement de grandes valeurs (> 16 bits par instruction).

### 3.2 LDR/STR - Load/Store (Accès Mémoire)

En ARM64, on ne peut **pas** accéder directement à la mémoire dans les opérations arithmétiques. Il faut **charger** en registre d'abord.

#### LDR - Load Register (Lire depuis mémoire)

```asm
; Charger 64 bits
ldr x0, [x1]         ; X0 = *X1 (lire 8 octets à l'adresse X1)

; Charger 32 bits
ldr w0, [x1]         ; W0 = *(int*)X1 (4 octets)

; Charger 8 bits (byte)
ldrb w0, [x1]        ; W0 = *(char*)X1 (1 octet)

; Avec offset
ldr x0, [x1, #8]     ; X0 = *(X1 + 8)

; Post-increment
ldr x0, [x1], #8     ; X0 = *X1, puis X1 += 8

; Pre-increment
ldr x0, [x1, #8]!    ; X1 += 8, puis X0 = *X1
```

**Visualisation** :

```ascii
MÉMOIRE :
         X1 = 0x1000
              ↓
0x1000   ┌────────┐
         │   42   │  ← Valeur stockée ici
         └────────┘

APRÈS "ldr x0, [x1]" :
X0 = 42  (valeur lue)
X1 = 0x1000  (inchangé)
```

#### STR - Store Register (Écrire en mémoire)

```asm
str x0, [x1]         ; *X1 = X0 (écrire X0 à l'adresse X1)
str w0, [sp, #4]     ; *(SP + 4) = W0 (32 bits)
strb w0, [x1]        ; *(char*)X1 = W0 (1 octet)
```

### 3.3 STP/LDP - Store/Load Pair

Opérations sur **deux registres** à la fois (optimisation).

```asm
; Sauvegarder FP et LR (prologue de fonction)
stp x29, x30, [sp, #-16]!   ; *(SP-16) = X29, *(SP-8) = X30, SP -= 16

; Restaurer FP et LR (épilogue de fonction)
ldp x29, x30, [sp], #16     ; X29 = *SP, X30 = *(SP+8), SP += 16
```

**Visualisation** :

```ascii
AVANT "stp x29, x30, [sp, #-16]!" :

SP → 0x1000 ┌────────┐
            │        │
            └────────┘

APRÈS :
     0x1000 ┌────────┐
            │  ...   │
     0x0FF8 ├────────┤
            │  X30   │  ← LR sauvegardé
     0x0FF0 ├────────┤
SP → 0x0FF0 │  X29   │  ← FP sauvegardé
            └────────┘

Le "!" signifie "write-back" : SP est mis à jour
```

### 3.4 ADD/SUB - Arithmétique

```asm
; Addition
add x0, x1, x2       ; X0 = X1 + X2
add x0, x0, #10      ; X0 = X0 + 10

; Soustraction
sub x0, x1, x2       ; X0 = X1 - X2
sub sp, sp, #32      ; Allouer 32 bytes sur la stack
```

**Autres opérations** :
```asm
mul x0, x1, x2       ; X0 = X1 * X2
sdiv x0, x1, x2      ; X0 = X1 / X2 (signed division)
and x0, x1, x2       ; X0 = X1 & X2 (ET binaire)
orr x0, x1, x2       ; X0 = X1 | X2 (OU binaire)
eor x0, x1, x2       ; X0 = X1 ^ X2 (XOR binaire)
```

### 3.5 Branches (Sauts)

#### B - Branch Incondi tionnel

```asm
b loop              ; Saute à l'étiquette "loop"
```

#### BL - Branch with Link (Appel de Fonction)

```asm
bl fonction         ; LR = adresse suivante, puis saute à "fonction"
```

#### Branches Conditionnelles

```asm
; Après une comparaison (CMP)
cmp x0, #10         ; Compare X0 avec 10
b.eq equal          ; Branch if Equal
b.ne not_equal      ; Branch if Not Equal
b.gt greater        ; Branch if Greater Than
b.lt less           ; Branch if Less Than
b.ge greater_equal  ; Branch if Greater or Equal
b.le less_equal     ; Branch if Less or Equal
```

#### CBZ/CBNZ - Compare and Branch if Zero

```asm
cbz x0, label       ; Si X0 == 0, saute à label
cbnz x0, label      ; Si X0 != 0, saute à label
```

### 3.6 RET - Retour de Fonction

```asm
ret                 ; PC = LR (saute à l'adresse dans X30)
```

### 3.7 SVC - Supervisor Call (Syscall)

Transfère le contrôle au **noyau** (kernel) en mode privilégié.

```asm
svc #0x80           ; Appel système (macOS)
svc #0              ; Appel système (Linux ARM)
```

**Sur macOS** : Le numéro de syscall doit être dans **X16** (pas X8 comme Linux).

## 4. Convention d'Appel ARM64 (AAPCS64)

### 4.1 Passage d'Arguments

Les **8 premiers arguments** vont dans X0-X7. Les suivants sur la **stack**.

```ascii
void fonction(int a, int b, int c, int d, int e, int f, int g, int h, int i);
              │    │    │    │    │    │    │    │    │
              X0   X1   X2   X3   X4   X5   X6   X7   Stack
```

**Exemple** :
```c
int add(int a, int b) {
    return a + b;
}
```

En ARM64 :
```asm
_add:
    add x0, x0, x1      ; X0 = X0 (a) + X1 (b)
    ret                 ; Retourne X0
```

### 4.2 Valeur de Retour

Le résultat d'une fonction est **toujours** dans **X0** (ou W0 pour 32-bit).

```asm
_fonction:
    mov x0, #42         ; Préparer valeur de retour
    ret                 ; Retourner 42
```

### 4.3 Registres à Préserver

Si une fonction utilise **X19-X28**, elle **doit** les sauvegarder et restaurer.

```asm
_fonction:
    ; Prologue : sauvegarder registres utilisés
    stp x19, x20, [sp, #-16]!
    
    ; Corps de la fonction
    mov x19, #100       ; Utiliser X19
    
    ; Épilogue : restaurer
    ldp x19, x20, [sp], #16
    ret
```

## 5. Syscalls macOS ARM64 - En Détail

### 5.1 Différence avec Linux

| Aspect | Linux ARM64 | macOS ARM64 |
|--------|-------------|-------------|
| Numéro syscall | **X8** | **X16** |
| Instruction | `SVC #0` | `SVC #0x80` |
| Numéros | 0, 1, 2... | 0x2000000+ |

### 5.2 Syscalls Courants macOS

```ascii
┌──────────────┬─────────────┬────────────────────────┐
│ Syscall      │ Numéro X16  │ Arguments              │
├──────────────┼─────────────┼────────────────────────┤
│ exit         │ 0x2000001   │ X0 = code              │
│ fork         │ 0x2000002   │ -                      │
│ read         │ 0x2000003   │ X0=fd, X1=buf, X2=len  │
│ write        │ 0x2000004   │ X0=fd, X1=buf, X2=len  │
│ open         │ 0x2000005   │ X0=path, X1=flags      │
│ close        │ 0x2000006   │ X0=fd                  │
│ execve       │ 0x200003B   │ X0=path, X1=argv, X2=e │
└──────────────┴─────────────┴────────────────────────┘
```

### 5.3 Exemple Détaillé : write("Hello\n")

**En C** :
```c
write(1, "Hello\n", 6);
```

**En ARM64** :
```asm
.global _main
.align 2

_main:
    ; Préparer les arguments
    mov x0, #1              ; Argument 1 : fd = 1 (stdout)
    adr x1, msg             ; Argument 2 : adresse du buffer
    mov x2, #6              ; Argument 3 : longueur (6 bytes)
    
    ; Appel syscall write
    mov x16, #0x2000004     ; Numéro syscall write
    svc #0x80               ; Exécuter syscall
    
    ; Syscall exit
    mov x0, #0              ; Code de retour = 0
    mov x16, #0x2000001     ; Numéro syscall exit
    svc #0x80
    
msg:
    .ascii "Hello\n"
```

**Étape par étape** :

```ascii
ÉTAPE 1 : Préparer X0
    mov x0, #1
    ┌────┐
X0  │ 1  │  ← File descriptor (stdout)
    └────┘

ÉTAPE 2 : Préparer X1
    adr x1, msg
    ┌──────────┐
X1  │ 0x100008 │  ← Adresse de "Hello\n" en mémoire
    └──────────┘

ÉTAPE 3 : Préparer X2
    mov x2, #6
    ┌────┐
X2  │ 6  │  ← Nombre d'octets à écrire
    └────┘

ÉTAPE 4 : Numéro syscall
    mov x16, #0x2000004
    ┌────────────┐
X16 │ 0x2000004  │  ← Syscall number (write)
    └────────────┘

ÉTAPE 5 : Exécuter
    svc #0x80
    
    ┌─────────────────┐
    │  USER MODE      │
    └────────┬────────┘
             ↓ SVC
    ┌─────────────────┐
    │  KERNEL MODE    │ ← Noyau prend le contrôle
    │  Exécute write()│
    └────────┬────────┘
             ↓ Retour
    ┌─────────────────┐
    │  USER MODE      │
    └─────────────────┘
```

## 6. Structure d'une Fonction ARM64

### 6.1 Prologue et Épilogue

```asm
_ma_fonction:
    ; === PROLOGUE ===
    stp x29, x30, [sp, #-16]!   ; Sauvegarder FP et LR
    mov x29, sp                  ; Nouveau frame pointer
    sub sp, sp, #32              ; Allouer 32 bytes pour variables locales
    
    ; === CORPS ===
    ; ... code de la fonction ...
    mov x0, #42                  ; Valeur de retour
    
    ; === ÉPILOGUE ===
    add sp, sp, #32              ; Libérer variables locales
    ldp x29, x30, [sp], #16      ; Restaurer FP et LR
    ret                          ; Retourner (PC = LR)
```

**Visualisation Stack** :

```ascii
AVANT PROLOGUE :
         ┌─────────┐
    SP → │         │  0x1000
         └─────────┘

APRÈS PROLOGUE :
         ┌─────────┐
         │ Old FP  │  0x1000
         ├─────────┤
         │ Old LR  │  0x0FF8
FP → X29 ├─────────┤  0x0FF0
         │ Local 1 │
         ├─────────┤
         │ Local 2 │
         ├─────────┤
    SP → │ Local 3 │  0x0FD0 (SP - 48)
         └─────────┘
```

### 6.2 Exemple Complet : Factorielle

```asm
; int factorial(int n)  // X0 = n
_factorial:
    ; Prologue
    stp x29, x30, [sp, #-16]!
    mov x29, sp
    
    ; Cas de base : if (n <= 1) return 1
    cmp x0, #1
    b.le .base_case
    
    ; Cas récursif : return n * factorial(n-1)
    sub sp, sp, #16          ; Allouer pour sauvegarder n
    str x0, [sp]             ; Sauvegarder n
    
    sub x0, x0, #1           ; X0 = n - 1
    bl _factorial            ; Appel récursif
    
    ldr x1, [sp]             ; Charger n dans X1
    add sp, sp, #16          ; Libérer
    
    mul x0, x0, x1           ; X0 = factorial(n-1) * n
    b .epilogue
    
.base_case:
    mov x0, #1               ; Retourner 1
    
.epilogue:
    ; Épilogue
    ldp x29, x30, [sp], #16
    ret

; factorial(5) :
; 5 * factorial(4)
; 5 * 4 * factorial(3)
; 5 * 4 * 3 * factorial(2)
; 5 * 4 * 3 * 2 * factorial(1)
; 5 * 4 * 3 * 2 * 1 = 120
```

## 7. Comparaison ARM64 vs x86-64

### 7.1 Hello World Comparaison

**ARM64 (macOS)** :
```asm
mov x0, #1              ; 4 bytes
adr x1, msg             ; 4 bytes
mov x2, #13             ; 4 bytes
mov x16, #0x2000004     ; 4 bytes
svc #0x80               ; 4 bytes
```

**x86-64 (Linux)** :
```asm
mov rax, 1              ; Syscall number (variable length)
mov rdi, 1              ; fd
lea rsi, [msg]          ; buffer
mov rdx, 13             ; length
syscall                 ; Syscall
```

### 7.2 Différences Architecturales

| Aspect | ARM64 | x86-64 |
|--------|-------|--------|
| **Instructions** | 4 bytes fixes | 1-15 bytes variables |
| **Registres** | 31 généraux | 16 généraux |
| **Accès mémoire** | LDR/STR séparés | MOV direct possible |
| **Philosophie** | RISC (simple) | CISC (complexe) |
| **Endianness** | Little-endian | Little-endian |

## 8. Adressage Mémoire

### 8.1 ADR vs LDR

**ADR** : Address of label (PC-relative)
```asm
adr x0, msg         ; X0 = adresse de "msg" (calculé depuis PC)
```

**LDR avec litéral** :
```asm
ldr x0, =msg        ; Pseudo-instruction : charge l'adresse
```

**LDR depuis mémoire** :
```asm
ldr x0, [x1]        ; Charge la valeur À l'adresse X1
```

### 8.2 Position-Independent Code (PIC)

Le code doit fonctionner peu importe où il est chargé en mémoire (ASLR).

```asm
; BON : PC-relative
adr x0, data
ldr x1, [x0]

; MAUVAIS : Adresse absolue (ne marchera pas avec ASLR)
ldr x0, =0x100000
```

## 9. Registres de Flags (NZCV)

Après certaines opérations, des **flags** sont mis à jour :

```ascii
┌───────────────────────────────┐
│  N │  Z │  C │  V │  (Flags) │
├────┼────┼────┼────┼───────────┤
│ 31 │ 30 │ 29 │ 28 │  (Bits)  │
└────┴────┴────┴────┴───────────┘

N = Negative (résultat négatif)
Z = Zero (résultat zéro)
C = Carry (retenue)
V = Overflow (débordement)
```

**Exemple** :
```asm
subs x0, x1, x2     ; X0 = X1 - X2, met à jour les flags
b.mi negative       ; Branch if Minus (N=1)
```

## 10. Exemple Complet Annoté

```asm
.global _main
.align 2

; Point d'entrée du programme
_main:
    ; === PROLOGUE ===
    ; Sauvegarder le Frame Pointer et Link Register sur la stack
    stp x29, x30, [sp, #-16]!   ; *(SP-16)=X29, *(SP-8)=X30, SP-=16
    mov x29, sp                  ; FP = SP (nouveau frame)
    
    ; === APPEL write() ===
    mov x0, #1                   ; Arg 1 : fd = 1 (stdout)
    adr x1, hello_msg            ; Arg 2 : adresse message
    mov x2, #13                  ; Arg 3 : longueur
    mov x16, #0x2000004          ; Syscall write = 4 (macOS offset 0x2000000)
    svc #0x80                    ; Appel noyau
    
    ; === RETOUR ===
    mov x0, #0                   ; Code de retour = 0 (succès)
    
    ; === ÉPILOGUE ===
    ldp x29, x30, [sp], #16      ; Restaurer FP et LR, SP+=16
    ret                          ; PC = LR (retour à l'appelant)

; === SECTION DATA ===
hello_msg:
    .ascii "Hello ARM64!\n"
    
; Fin du programme
```

**Explication Ligne par Ligne** :

1. `.global _main` : Rend `_main` visible au linker
2. `.align 2` : Aligne sur 4 bytes (2^2)
3. `stp x29, x30, [sp, #-16]!` : 
   - Descend SP de 16
   - Sauvegarde FP à (SP)
   - Sauvegarde LR à (SP+8)
4. `mov x29, sp` : Frame pointer = stack pointer actuel
5. `mov x0, #1` : Premier argument de write() = stdout
6. `adr x1, hello_msg` : X1 = adresse de la string
7. `mov x2, #13` : Longueur = 13 caractères
8. `mov x16, #0x2000004` : Numéro syscall write
9. `svc #0x80` : Appel kernel
10. `mov x0, #0` : Code de retour 0
11. `ldp x29, x30, [sp], #16` : Restaure FP et LR
12. `ret` : Retourne à l'appelant

## 11. Différences ARM64 vs x86-64 - Tableau Récapitulatif

| Concept | ARM64 | x86-64 |
|---------|-------|--------|
| **Registres arguments** | X0-X7 | RDI, RSI, RDX, RCX, R8, R9 |
| **Retour fonction** | X0 | RAX |
| **Stack pointer** | SP | RSP |
| **Frame pointer** | X29 (FP) | RBP |
| **Link register** | X30 (LR) | (sur stack) |
| **Syscall register** | X16 (macOS) | RAX |
| **Syscall instruction** | SVC #0x80 | SYSCALL |
| **Taille instruction** | 4 bytes fixe | 1-15 bytes |
| **Accès mémoire** | LDR/STR | MOV direct |

## 12. Glossaire des Termes Techniques

- **AAPCS64** : ARM Architecture Procedure Call Standard (convention d'appel)
- **AArch64** : Architecture ARM 64-bit
- **Caller-saved** : Registres que l'appelant doit sauvegarder
- **Callee-saved** : Registres que la fonction appelée doit sauvegarder
- **Frame Pointer** : Pointeur vers la base de la stack frame
- **Link Register** : Registre contenant l'adresse de retour
- **PC-relative** : Adressage relatif au Program Counter
- **RISC** : Reduced Instruction Set Computer
- **SVC** : Supervisor Call (appel système)
- **Write-back** : Mise à jour automatique du registre d'adresse

## 13. Ressources Complémentaires

- [ARM Architecture Reference Manual](https://developer.arm.com/documentation/ddi0487/)
- [Apple Silicon ABI](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms)
- [ARM Instruction Set](https://developer.arm.com/documentation/ddi0596/)
- [macOS System Calls](https://opensource.apple.com/source/xnu/)
