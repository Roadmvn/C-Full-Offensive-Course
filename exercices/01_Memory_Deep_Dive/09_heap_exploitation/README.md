# Heap Exploitation

L'exploitation du heap (tas) cible les allocations dynamiques via malloc/free. Les vulnérabilités incluent heap overflow, use-after-free, double-free, permettant d'écrire en mémoire arbitraire ou d'exécuter du code.

⚠️ AVERTISSEMENT : Code éducatif. Uniquement sur tes propres systèmes de test. Usage malveillant est ILLÉGAL.

```c
// Use-After-Free
char *ptr = malloc(100);
free(ptr);
strcpy(ptr, "data");  // VULNÉRABLE : UAF

// Double-Free
free(ptr);
free(ptr);  // VULNÉRABLE : double-free

// Heap Overflow
char *buf = malloc(64);
strcpy(buf, long_string);  // Déborde dans chunk suivant
```

## Compilation

```bash
gcc -fno-stack-protector example.c -o example
# Ou avec sanitizer pour détecter :
gcc -fsanitize=address example.c -o example
```

## Concepts clés

- Heap : mémoire dynamique gérée par malloc/free
- Chunks : blocs de mémoire avec metadata (size, flags)
- Use-After-Free (UAF) : utiliser un pointeur après free()
- Double-Free : libérer le même pointeur deux fois
- Heap Overflow : déborder d'un chunk dans le suivant
- Corruption de metadata pour contrôler malloc/free

## Exploitation

Heap overflow écrase les metadata du chunk suivant. En contrôlant size et pointeurs, on peut faire écrire malloc() à une adresse arbitraire.

Use-After-Free : après free(), le chunk est réutilisable. Si on alloue un objet avec pointeur de fonction, on peut le contrôler. Double-free corrompt les free lists.

Techniques avancées : fastbin dup, tcache poisoning, house of spirit, house of force (spécifiques à la libc).

## Outils

- GDB avec heap commands (gef, pwndbg)
- pwntools pour exploitation automatisée
- AddressSanitizer (-fsanitize=address) pour détecter les bugs
