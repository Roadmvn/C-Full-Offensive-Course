⚠️ AVERTISSEMENT : Exercices d'exploitation éducatifs. Uniquement sur tes propres systèmes de test. Usage malveillant est ILLÉGAL.

EXERCICE 15 - BUFFER OVERFLOW BASIQUE

OBJECTIFS :
- Écraser des variables adjacentes
- Bypasser des vérifications d'authentification
- Contrôler précisément les écrasements
- Comprendre le layout mémoire de la stack

DÉFIS D'EXPLOITATION

[ ] Défi 1 : Écraser une variable "authenticated"
    Écris un programme avec :
    - char buffer[32]
    - int authenticated = 0

    Utilise gets() pour lire l'input et écrase authenticated à 1.
    Compile avec : gcc -fno-stack-protector -z execstack prog.c -o prog

    Combien de bytes faut-il pour atteindre authenticated ?

[ ] Défi 2 : Bypass d'authentification
    Crée un système de login avec :
    - struct { char username[16]; char password[16]; int admin; }

    Exploite un buffer overflow dans username ou password pour mettre
    admin à une valeur non-nulle sans connaître le mot de passe.

[ ] Défi 3 : Contrôle précis de la valeur
    Programme avec :
    - char buffer[64]
    - unsigned int target = 0xDEADBEEF

    Écrase target avec exactement 0x41424344 (DCBA en little-endian).
    Utilise Python pour générer le payload.

[ ] Défi 4 : Écrasement de pointeur
    Crée deux variables :
    - char buffer[48]
    - char *message = "Access Denied"

    Overflow buffer pour modifier le pointeur message vers une chaîne
    "Access Granted" que tu places dans le buffer.

[ ] Défi 5 : Analyse avec GDB
    Pour le programme du Défi 1, utilise GDB pour :
    - Placer un breakpoint avant gets()
    - Examiner la stack avec "x/32wx $esp" ou "x/32gx $rsp"
    - Identifier la distance exacte entre buffer et authenticated
    - Vérifier l'écrasement après gets()

[ ] Défi 6 : Visualisation mémoire
    Écris un programme qui affiche :
    - Les adresses de toutes les variables locales
    - Le contenu hexadécimal de la stack
    - L'offset entre chaque variable

    Utilise ce programme pour comprendre le layout de la stack.

[ ] Défi 7 : Protection avec canary manuel
    Implémente un canary simple :
    - Place une valeur aléatoire avant/après le buffer
    - Vérifie le canary après chaque écriture
    - Détecte et signale les corruptions

[ ] Défi 8 : Exploitation de strcpy
    Programme vulnérable :
    void vulnerable(char *input) {
        char buffer[100];
        strcpy(buffer, input);  // Pas de vérification
    }

    Crée un exploit qui :
    - Génère un payload de 120 bytes
    - Écrase une variable après buffer
    - Documente exactement ce qui est écrasé

TECHNIQUES

1. Calcul d'offset :
   offset = adresse_cible - adresse_buffer

2. Génération de payload Python :
   payload = b'A' * offset + struct.pack('<I', 0x41424344)

3. Test avec pattern :
   python -c "print('A'*32 + 'B'*4 + 'C'*4)" | ./prog

4. Analyse GDB :
   gdb ./prog
   (gdb) break main
   (gdb) run
   (gdb) x/32wx $esp    # x86
   (gdb) x/32gx $rsp    # x64

OUTILS

- GDB : debugger pour analyser la mémoire
- Python struct : générer des payloads binaires
- hexdump : visualiser les données
- objdump -d : désassembler le programme

VALIDATION

Chaque exploit doit :
✓ Démontrer l'écrasement de la cible
✓ Être reproductible
✓ Inclure un commentaire expliquant l'offset calculé
✓ Fonctionner avec les protections désactivées
