SOLUTIONS - MODULE 31 : ANTI-VM & ANTI-SANDBOX

⚠️ AVERTISSEMENT : Techniques pour analyse défensive uniquement.

SOLUTION 1 : CPUID COMPREHENSIVE

Hypervisor bit :
int regs[4];
__cpuid(regs, 1);
if (regs[2] & (1 << 31)) vm_detected();

Vendor string :
__cpuid(regs, 0x40000000);
char vendor[13];
memcpy(vendor, &regs[1], 12);
vendor[12] = 0;
// "VMwareVMware", "Microsoft Hv", "KVMKVMKVM", "VBoxVBoxVBox"

All hypervisors :
- VMware: "VMwareVMware"
- Hyper-V: "Microsoft Hv"
- KVM: "KVMKVMKVM"
- VirtualBox: "VBoxVBoxVBox"
- Xen: "XenVMMXenVMM"


SOLUTION 2 : MAC & NETWORK CHECKS

MAC OUI :
struct {
    uint8_t mac[3];
    const char* vendor;
} vm_macs[] = {
    {{0x00, 0x0C, 0x29}, "VMware"},
    {{0x00, 0x1C, 0x14}, "VMware"},
    {{0x00, 0x50, 0x56}, "VMware"},
    {{0x08, 0x00, 0x27}, "VirtualBox"},
    {{0x52, 0x54, 0x00}, "QEMU/KVM"}
};

Hostname check :
char hostname[256];
GetComputerNameA(hostname, &size);
if (strstr(strlwr(hostname), "sandbox")) vm();
if (strstr(hostname, "malware")) vm();

IP range :
// 192.168.x.x, 10.x.x.x = common VM networks


SOLUTION 3 : VM ARTIFACTS

Files :
const char* files[] = {
    "C:\\windows\\system32\\drivers\\vmmouse.sys",
    "C:\\windows\\system32\\drivers\\vmhgfs.sys",
    "C:\\windows\\system32\\drivers\\VBoxMouse.sys",
    "C:\\windows\\system32\\drivers\\VBoxGuest.sys",
    "C:\\windows\\system32\\drivers\\VBoxSF.sys",
    "C:\\Program Files\\VMware\\VMware Tools\\",
    "C:\\Program Files\\Oracle\\VirtualBox Guest Additions\\"
};

Registry :
"HARDWARE\\Description\\System\\BIOS\\SystemManufacturer" = "VMware"
"HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0\\Identifier" = "VMware"

Services :
"vmtools", "vboxservice", "vpcmap"


SOLUTION 4 : SANDBOX BEHAVIOR

Sleep acceleration :
start = GetTickCount();
Sleep(10000);
actual = GetTickCount() - start;
if (actual < 9000) sandbox();  // Accéléré

Execution timeout :
// Delayed execution (après 10min)
Sleep(600000);
real_payload();  // Sandbox timeout avant

Limited disk :
ULARGE_INTEGER free, total;
GetDiskFreeSpaceExA("C:\\", &free, &total, NULL);
if (total.QuadPart < 60GB) sandbox();  // VMs petits disques

File operations fake :
FILE* f = fopen("test.txt", "w");
fputs("data", f);
fclose(f);
f = fopen("test.txt", "r");
char buf[10];
fgets(buf, sizeof(buf), f);
if (strcmp(buf, "data") != 0) sandbox();  // Hooked


SOLUTION 5 : WMI QUERIES

IWbemServices* pSvc;
IWbemLocator* pLoc;
CoCreateInstance(&CLSID_WbemLocator, ...);
pLoc->ConnectServer(L"ROOT\\CIMV2", NULL, NULL, 0, NULL, 0, 0, &pSvc);

Query :
pSvc->ExecQuery(L"WQL", L"SELECT * FROM Win32_ComputerSystem", ...);

Check results :
- Manufacturer: "VMware", "innotek GmbH" (VBox), "QEMU"
- Model: "VirtualBox", "VMware Virtual Platform"

BIOS check :
SELECT * FROM Win32_BIOS
- SerialNumber: "0", "VMware-..."
- Version: "VBOX", "QEMU"


SOLUTION 6 : TIMING & PERFORMANCE

RDTSC :
start = __rdtsc();
for(int i=0; i<1000000; i++) dummy_op();
end = __rdtsc();
cycles_per_op = (end - start) / 1000000;
if (cycles_per_op > threshold) vm();  // VM overhead

Disk I/O :
start = GetTickCount();
FILE* f = fopen("test.dat", "wb");
for(int i=0; i<10000; i++) fwrite(buf, 1024, 1, f);
fclose(f);
elapsed = GetTickCount() - start;
if (elapsed > threshold) vm();  // Slow disk


SOLUTION 7 : HUMAN INTERACTION

Mouse movement :
POINT prev, curr;
GetCursorPos(&prev);
Sleep(5000);
GetCursorPos(&curr);
if (prev.x == curr.x && prev.y == curr.y) sandbox();  // No movement

Keyboard :
int keypresses = 0;
for(int i=0; i<60; i++) {  // 1 minute
    for(int k=0; k<256; k++) {
        if (GetAsyncKeyState(k) & 0x8000) keypresses++;
    }
    Sleep(1000);
}
if (keypresses < 5) sandbox();  // No typing

Idle time :
LASTINPUTINFO lii;
GetLastInputInfo(&lii);
if ((GetTickCount() - lii.dwTime) > 600000) sandbox();  // 10min idle


SOLUTION 8 : MULTI-LAYER

int vm_score = 0;
vm_score += check_cpuid() * 10;
vm_score += check_mac() * 8;
vm_score += check_files() * 7;
vm_score += check_registry() * 7;
vm_score += check_processes() * 6;
vm_score += check_sleep_accel() * 9;
vm_score += check_user_interaction() * 5;
vm_score += check_wmi() * 8;
vm_score += check_timing() * 4;

if (vm_score > 30) {
    // High confidence VM/Sandbox
    exit(0);
}

Delayed checks :
CreateThread(NULL, 0, delayed_check_thread, NULL, 0, NULL);
// Thread wait 5min, puis check again

Random order :
int checks[] = {0,1,2,3,4,5,6,7,8};
shuffle(checks);
for (int c : checks) run_check(c);

RÉFÉRENCES :
- Pafish (open source anti-VM tool)
- Al-Khaser (comprehensive checks)
- CheckPoint SandBlast evasion
- Cuckoo Sandbox documentation
- Unprotect.it VM detection techniques
