# Cours : Format String Vulnerability

## 1. Introduction - Une Vulnérabilité Subtile

### 1.1 Le Bug Apparemment Innocent

```c
// Code vulnérable
char buffer[100];
gets(buffer);
printf(buffer);  // ❌ ERREUR CRITIQUE !
```

**Ce qui semble innocent** :
- "Je veux juste afficher ce que l'utilisateur a tapé"

**Ce qui est dangereux** :
- L'utilisateur contrôle le **format string** de printf()

### 1.2 Utilisation Normale vs Malveillante

```ascii
UTILISATION NORMALE :

User tape : "Bonjour"
printf("Bonjour")
  ↓
Sortie : Bonjour  ✅ OK

═══════════════════════════════════════

UTILISATION MALVEILLANTE :

User tape : "%x %x %x %x"
printf("%x %x %x %x")
  ↓
Sortie : 7fff1234 deadbeef baadf00d ...
         └─ LEAK DE LA STACK ! ❌

User tape : "%s"
printf("%s")
  ↓
Tente de lire une string à une adresse aléatoire
→ CRASH ou leak mémoire
```

### 1.3 Comment printf() Fonctionne ?

**printf() analyse la format string** et lit des arguments sur la **stack**.

```ascii
APPEL NORMAL :

printf("Age: %d, Nom: %s", age, nom);
         │         │        │    │
         │         │        ↓    ↓
         │         │      STACK :
         │         │      ┌──────┐
         │         │      │ nom  │  Arg 2
         │         │      ├──────┤
         │         └──────┤ age  │  Arg 1
         └────────────────┤format│  Arg 0
                          └──────┘

printf() lit :
1. %d → Va chercher arg 1 (age) sur stack
2. %s → Va chercher arg 2 (nom) sur stack

═══════════════════════════════════════

APPEL VULNÉRABLE :

printf(buffer);  // buffer = "%x %x %x"
         │
         └─ Pas d'arguments fournis !

printf() lit quand même :
1. %x → Lit ce qui est sur la stack (données aléatoires)
2. %x → Continue à lire
3. %x → Continue à lire

STACK :
┌──────────────┐
│ return addr  │  ← printf() lit ici ! (leak)
├──────────────┤
│ saved RBP    │  ← Et ici !
├──────────────┤
│ variables    │  ← Et ici !
│ locales      │
└──────────────┘

printf() affiche le CONTENU DE LA STACK !
```

## 2. Exploiter la Vulnérabilité

### 2.1 Leak d'Information

```ascii
OBJECTIF : Lire des données sensibles en mémoire

STACK pendant printf("%x %x %x") :

Position:  [RBP] [RET] [VAR1] [VAR2] [PASSWORD] [...]
             ↓     ↓     ↓      ↓       ↓
Format:     %x    %x    %x     %x      %x
             │     │     │      │       │
Affiche: 0x7f.. 0x40.. 0xdead 0xbeef 0x706173...
                                        └─ "pass" en ASCII !

L'attaquant peut LIRE la stack et trouver :
- Adresses (bypass ASLR)
- Variables sensibles (mots de passe)
- Pointeurs de code (bypass PIE)
```

### 2.2 Format Specifiers Dangereux

```ascii
┌────────────┬──────────────────────────────────────┐
│ Specifier  │ Effet                                │
├────────────┼──────────────────────────────────────┤
│ %x         │ Affiche un int en hexa               │
│            │ (leak 4 bytes de la stack)           │
├────────────┼──────────────────────────────────────┤
│ %p         │ Affiche un pointeur                  │
│            │ (leak 8 bytes sur 64-bit)            │
├────────────┼──────────────────────────────────────┤
│ %s         │ Affiche une string                   │
│            │ (lit à une adresse, peut crasher)    │
├────────────┼──────────────────────────────────────┤
│ %n         │ ÉCRIT le nombre de bytes affichés    │
│            │ (WRITE PRIMITIVE !)                  │
├────────────┼──────────────────────────────────────┤
│ %$n        │ Accès direct à la position N         │
│            │ (ex: %7$x = 7ème argument)           │
└────────────┴──────────────────────────────────────┘
```

### 2.3 Le Specifier %n - Écriture Arbitraire

**%n** est le plus dangereux : il **ÉCRIT** en mémoire !

```c
int compteur;
printf("AAAA%n", &compteur);
// compteur = 4 (nombre de caractères affichés avant %n)
```

**Exploitation** :

```ascii
EXPLOIT : Écrire une valeur à une adresse arbitraire

PAYLOAD : "\x10\x60\x40\x00%x%x%x%n"
          └───────────┘└──────┘│
          Adresse cible Format │
          (4 bytes)    (padding)%n = écrit

STACK AVANT printf() :

┌──────────────────┐
│ ...              │
├──────────────────┤
│ 0x00406010       │  ← Adresse interprétée comme arg
│ (dans le buffer) │
└──────────────────┘

EXÉCUTION :

printf("%x%x%x%n")
        │  │  │ │
        │  │  │ └─ %n écrit à l'adresse 0x00406010
        │  │  └─ %x consomme stack (padding)
        │  └─ %x consomme stack
        └─ %x lit 0x00406010

RÉSULTAT :
Mémoire à 0x00406010 = nombre de bytes affichés

UTILISATION :
- Écraser GOT (Global Offset Table)
- Modifier pointeur de fonction
- Changer valeur de variable
```

### 2.4 Exploitation Complète - Étape par Étape

```ascii
OBJECTIF : Écrire 0x41414141 à l'adresse 0x08040000

ÉTAPE 1 : Placer l'adresse cible dans le buffer

Buffer : "\x00\x40\x04\x08JUNK%4$n"
         └───────────┘    └┘
         Adresse          Accès position 4

ÉTAPE 2 : Padding pour atteindre la valeur voulue

0x41414141 = 1094795585 en décimal

printf() doit afficher 1094795585 caractères avant %n

Impossible directement, on utilise %width:
"%1094795585d%4$n"
  └─────────┘
  Largeur = nombre de caractères

ÉTAPE 3 : printf() exécute

1. Affiche 1094795585 espaces
2. %4$n écrit 1094795585 à la position 4 de la stack
3. Position 4 contient 0x08040000
4. Écriture : *(0x08040000) = 1094795585

RÉSULTAT :
┌──────────────────┐
│ 0x08040000:      │
│   0x41414141     │  ✅ Valeur écrite !
└──────────────────┘
```

## 3. Techniques Avancées

### 3.1 Accès Direct ($)

```ascii
SANS ACCÈS DIRECT :

printf("%x %x %x %x %x %x %x TARGET")
        1  2  3  4  5  6  7   8

Besoin de 7 %x pour atteindre le 8ème argument

AVEC ACCÈS DIRECT :

printf("%8$x TARGET")
        └┘
    Position 8 directement

Gain : Plus besoin de padding
```

### 3.2 Écriture Par Morceaux

Écrire 0x41424344 en 4 fois (byte par byte) :

```ascii
Adresse cible : 0x08040000

ÉCRITURE 1 : Byte 0 (0x44 = 68)
printf("%68d%10$n", ...) → 0x08040000 = 0x44

ÉCRITURE 2 : Byte 1 (0x43 = 67)
printf("%67d%11$n", ...) → 0x08040001 = 0x43

ÉCRITURE 3 : Byte 2 (0x42 = 66)
printf("%66d%12$n", ...) → 0x08040002 = 0x42

ÉCRITURE 4 : Byte 3 (0x41 = 65)
printf("%65d%13$n", ...) → 0x08040003 = 0x41

RÉSULTAT FINAL :
┌───┬───┬───┬───┐
│ 41│ 42│ 43│ 44│  = 0x41424344 ✅
└───┴───┴───┴───┘
0x08040000
```

## 4. Détection et Protection

### 4.1 Code Sécurisé

```c
// ❌ VULNÉRABLE
printf(user_input);

// ✅ SÉCURISÉ
printf("%s", user_input);
```

**Pourquoi ?**

```ascii
printf(user_input) :
  user_input est traité comme FORMAT STRING
  %x, %n, etc. sont interprétés

printf("%s", user_input) :
  user_input est traité comme DONNÉE
  %x affiché littéralement (pas interprété)
```

### 4.2 FORTIFY_SOURCE

```bash
gcc -D_FORTIFY_SOURCE=2 program.c
```

Vérifie au runtime :
- Nombre d'arguments correspond aux format specifiers
- Détecte les printf() suspects
- Arrête le programme en cas d'anomalie

## Ressources

- [Format String Attacks](https://owasp.org/www-community/attacks/Format_string_attack)
- [Exploiting Format Strings](https://cs155.stanford.edu/papers/formatstring-1.2.pdf)

