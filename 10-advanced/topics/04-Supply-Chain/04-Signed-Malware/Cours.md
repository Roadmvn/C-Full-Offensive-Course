# Module A18 : Signed Malware - Abus de signature de code

## Objectifs pédagogiques

- Comprendre la signature de code (Authenticode, codesign)
- Exploiter les certificats volés ou compromis
- Analyser des cas réels (Stuxnet, Flame)
- Obtenir une signature légitime pour un malware

## Introduction

La **signature de code** assure que le binaire provient d'un éditeur de confiance. Mais si un attaquant obtient un certificat valide, son malware sera considéré comme légitime.

```
┌────────────────────────────────────────────┐
│       Signature de code workflow           │
└────────────────────────────────────────────┘

Éditeur légitime
  ├─> Génère clé privée (EV Code Signing)
  ├─> Obtient certificat d'une CA (DigiCert, etc.)
  ├─> Signe ses binaires
  └─> Windows/macOS fait confiance

Attaquant
  ├─> Vole la clé privée
  ├─> OU compromet le build system
  ├─> Signe un malware
  └─> Bypasse SmartScreen/Gatekeeper !
```

## Cas réels

### Stuxnet (2010)

Utilisait **2 certificats volés** :
- Realtek Semiconductor
- JMicron Technology

Les drivers malveillants étaient signés, donc acceptés par Windows.

### Flame (2012)

Utilisait un certificat frauduleux émis par une CA compromise (Terminal Server Licensing).

## Techniques d'obtention

1. **Vol de certificat** : Compromission du serveur de l'éditeur
2. **Malware signé par erreur** : Soumettre malware à un service de signature automatisé
3. **Certificat révoqué mais encore valide** : Utiliser avant révocation

## PoC : Vérifier signature

**Windows (PowerShell) :**
```powershell
Get-AuthenticodeSignature malware.exe

# Vérifier la chaîne de confiance
(Get-AuthenticodeSignature malware.exe).SignerCertificate | Format-List
```

**Linux (osslsigncode) :**
```bash
osslsigncode verify malware.exe
```

## Défense

**Côté éditeur :**
- Protéger clé privée (HSM, pas sur disk)
- Logs d'utilisation du certificat
- Révocation rapide si compromis

**Côté détection :**
```powershell
# Vérifier tous les .exe signés dans un dossier
Get-ChildItem -Recurse -Include *.exe | Get-AuthenticodeSignature | Where-Object {$_.Status -ne "Valid"}
```

## Résumé

- Signature de code = confiance Windows/macOS
- Certificat volé = malware légitime
- Cas réels : Stuxnet, Flame
- Défense : HSM, révocation rapide, détection anomalies

## Ressources

- **Stuxnet Analysis** : https://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/w32_stuxnet_dossier.pdf
- **Code Signing Best Practices** : https://docs.microsoft.com/en-us/windows-hardware/drivers/install/code-signing-best-practices

---

**Module suivant** : [A19 - LLM Attack Surface](../../PHASE_A05_AI_SECURITY/A19_llm_attack_surface/)
