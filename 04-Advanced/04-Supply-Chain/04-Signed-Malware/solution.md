# Solutions - Signed Malware

## Exercice 1 : Découverte (Très facile)

**Objectif** : Comprendre la signature de code et son abus

**Solution** :

```bash
# Compilation
gcc example.c -o signed_malware

# Exécution
./signed_malware
```

**Résultat attendu** :
```
[*] Module : Signed Malware
[*] ==========================================

[+] Exemple terminé avec succès
```

**Explication** : Introduction à l'abus de signature de code pour faire passer un malware comme légitime.

---

## Exercice 2 : Vérificateur de signatures (Facile)

**Objectif** : Créer un outil pour vérifier les signatures de binaires

**Solution** :

```c
/*
 * Code Signature Verifier
 * Vérifie l'authenticité des signatures de code
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#define COLOR_RED     "\x1b[31m"
#define COLOR_GREEN   "\x1b[32m"
#define COLOR_YELLOW  "\x1b[33m"
#define COLOR_BLUE    "\x1b[34m"
#define COLOR_RESET   "\x1b[0m"

// Structure pour les informations de signature
typedef struct {
    char signer[256];
    char issuer[256];
    char serial[128];
    char valid_from[64];
    char valid_to[64];
    int is_valid;
    int is_trusted;
} SignatureInfo;

// Vérifier signature Windows (PE)
int verify_windows_signature(const char* filename, SignatureInfo* info) {
    char cmd[512];
    FILE* fp;

    printf("[*] Vérification de signature Windows (PE)...\n");

    // Utiliser osslsigncode (disponible sur Linux)
    snprintf(cmd, sizeof(cmd), "osslsigncode verify %s 2>&1", filename);

    fp = popen(cmd, "r");
    if (!fp) {
        printf("[-] Erreur: osslsigncode non disponible\n");
        printf("    Installer: sudo apt install osslsigncode\n");
        return -1;
    }

    char line[512];
    info->is_valid = 0;
    info->is_trusted = 0;

    while (fgets(line, sizeof(line), fp)) {
        printf("    %s", line);

        // Parser les informations
        if (strstr(line, "Signer:")) {
            sscanf(line, "Signer: %[^\n]", info->signer);
        } else if (strstr(line, "Issuer:")) {
            sscanf(line, "Issuer: %[^\n]", info->issuer);
        } else if (strstr(line, "Serial:")) {
            sscanf(line, "Serial: %[^\n]", info->serial);
        } else if (strstr(line, "Signature verification: ok")) {
            info->is_valid = 1;
        }
    }

    pclose(fp);
    return info->is_valid ? 0 : -1;
}

// Vérifier signature ELF (Linux)
int verify_elf_signature(const char* filename, SignatureInfo* info) {
    printf("[*] Vérification de signature ELF...\n");

    // Les binaires Linux utilisent généralement GPG signatures
    char cmd[512];
    snprintf(cmd, sizeof(cmd), "gpg --verify %s.sig %s 2>&1", filename, filename);

    FILE* fp = popen(cmd, "r");
    if (!fp) {
        printf("[-] Pas de signature détachée (.sig) trouvée\n");
        return -1;
    }

    char line[512];
    info->is_valid = 0;

    while (fgets(line, sizeof(line), fp)) {
        printf("    %s", line);

        if (strstr(line, "Good signature")) {
            info->is_valid = 1;
        } else if (strstr(line, "BAD signature")) {
            info->is_valid = 0;
        }

        if (strstr(line, "from")) {
            char* start = strchr(line, '"');
            if (start) {
                char* end = strchr(start + 1, '"');
                if (end) {
                    int len = end - start - 1;
                    strncpy(info->signer, start + 1, len);
                    info->signer[len] = '\0';
                }
            }
        }
    }

    pclose(fp);
    return info->is_valid ? 0 : -1;
}

// Détecter le type de fichier
int detect_file_type(const char* filename) {
    FILE* f = fopen(filename, "rb");
    if (!f) return -1;

    unsigned char magic[4];
    fread(magic, 1, 4, f);
    fclose(f);

    // PE (Windows): MZ
    if (magic[0] == 'M' && magic[1] == 'Z') {
        return 1;  // PE
    }

    // ELF (Linux): 0x7F E L F
    if (magic[0] == 0x7F && magic[1] == 'E' &&
        magic[2] == 'L' && magic[3] == 'F') {
        return 2;  // ELF
    }

    // Mach-O (macOS): 0xFEEDFACE ou 0xFEEDFACF
    if ((magic[0] == 0xFE && magic[1] == 0xED &&
         magic[2] == 0xFA && magic[3] == 0xCE) ||
        (magic[0] == 0xFE && magic[1] == 0xED &&
         magic[2] == 0xFA && magic[3] == 0xCF)) {
        return 3;  // Mach-O
    }

    return 0;  // Inconnu
}

// Analyser le signataire
void analyze_signer(const SignatureInfo* info) {
    printf("\n[*] Analyse du signataire:\n");
    printf("==========================================\n");

    if (strlen(info->signer) > 0) {
        printf("Signataire: %s\n", info->signer);

        // Vérifier si c'est un signataire connu/suspect
        if (strstr(info->signer, "Realtek") || strstr(info->signer, "JMicron")) {
            printf("%s[!] ALERTE: Certificat utilisé dans Stuxnet!%s\n",
                   COLOR_RED, COLOR_RESET);
        }

        if (strstr(info->signer, "Microsoft") ||
            strstr(info->signer, "Apple") ||
            strstr(info->signer, "Google")) {
            printf("%s[+] Signataire légitime connu%s\n",
                   COLOR_GREEN, COLOR_RESET);
        }
    }

    if (strlen(info->issuer) > 0) {
        printf("Émetteur: %s\n", info->issuer);
    }

    if (strlen(info->serial) > 0) {
        printf("Numéro de série: %s\n", info->serial);
    }

    printf("\nValidité: %s%s%s\n",
           info->is_valid ? COLOR_GREEN : COLOR_RED,
           info->is_valid ? "VALIDE" : "INVALIDE",
           COLOR_RESET);
}

// Vérifier révocation du certificat
void check_certificate_revocation(const char* serial) {
    printf("\n[*] Vérification de révocation du certificat...\n");

    // Note: Implémentation simplifiée
    // Dans un cas réel, on interrogerait une CRL ou OCSP

    const char* revoked_serials[] = {
        "03:37:C5:2C:1D:7B:15:9C",  // Exemple Stuxnet
        "47:EB:93:D0:7B:E2:8D:DE",  // Exemple
        NULL
    };

    for (int i = 0; revoked_serials[i] != NULL; i++) {
        if (strcasecmp(serial, revoked_serials[i]) == 0) {
            printf("%s[!] ALERTE: Certificat révoqué!%s\n",
                   COLOR_RED, COLOR_RESET);
            printf("    Ce certificat a été utilisé dans des malwares connus\n");
            return;
        }
    }

    printf("%s[+] Certificat non révoqué (dans la base locale)%s\n",
           COLOR_GREEN, COLOR_RESET);
}

int main(int argc, char* argv[]) {
    printf("[*] Code Signature Verifier\n");
    printf("[*] ==========================================\n\n");

    if (argc < 2) {
        printf("Usage: %s <fichier>\n", argv[0]);
        printf("\nExemple:\n");
        printf("  %s malware.exe\n", argv[0]);
        printf("  %s /bin/ls\n", argv[0]);
        return 1;
    }

    const char* filename = argv[1];

    // Vérifier que le fichier existe
    struct stat st;
    if (stat(filename, &st) != 0) {
        printf("[-] Erreur: Fichier '%s' introuvable\n", filename);
        return 1;
    }

    printf("[+] Analyse de: %s\n", filename);
    printf("    Taille: %ld octets\n\n", st.st_size);

    // Détecter le type
    int file_type = detect_file_type(filename);

    SignatureInfo info = {0};

    switch (file_type) {
        case 1:  // PE (Windows)
            printf("[+] Type: Windows PE\n\n");
            verify_windows_signature(filename, &info);
            break;

        case 2:  // ELF (Linux)
            printf("[+] Type: Linux ELF\n\n");
            verify_elf_signature(filename, &info);
            break;

        case 3:  // Mach-O (macOS)
            printf("[+] Type: macOS Mach-O\n\n");
            printf("[-] Vérification Mach-O non implémentée\n");
            printf("    Utiliser: codesign --verify --verbose %s\n", filename);
            return 1;

        default:
            printf("[-] Type de fichier non reconnu\n");
            return 1;
    }

    // Analyser les résultats
    analyze_signer(&info);

    if (strlen(info.serial) > 0) {
        check_certificate_revocation(info.serial);
    }

    // Verdict final
    printf("\n");
    printf("╔════════════════════════════════════════════════════╗\n");
    printf("║                  VERDICT FINAL                     ║\n");
    printf("╚════════════════════════════════════════════════════╝\n\n");

    if (info.is_valid) {
        printf("%s[+] Signature valide%s\n", COLOR_GREEN, COLOR_RESET);
        printf("\nCependant, une signature valide ne garantit pas:\n");
        printf("  - Que le binaire est sûr (certificat peut être volé)\n");
        printf("  - Que le certificat n'a pas été révoqué récemment\n");
        printf("  - Que le code n'est pas malveillant (ex: Stuxnet)\n");
    } else {
        printf("%s[!] Signature invalide ou absente%s\n", COLOR_RED, COLOR_RESET);
        printf("\nCe fichier:\n");
        printf("  - N'a pas de signature valide\n");
        printf("  - Peut être modifié ou malveillant\n");
        printf("  - Ne devrait pas être exécuté sans analyse\n");
    }

    return 0;
}
```

**Compilation** :
```bash
gcc signature_verifier.c -o signature_verifier
```

**Usage** :
```bash
# Vérifier un binaire Windows
./signature_verifier malware.exe

# Vérifier un binaire Linux
./signature_verifier /usr/bin/curl
```

---

## Exercice 3 : Simulateur d'attaque Stuxnet (Moyen)

**Objectif** : Simuler comment Stuxnet utilisait des certificats volés

**Solution** :

```c
/*
 * Stuxnet Attack Simulator
 * Simulation de l'utilisation de certificats volés
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#define COLOR_RED     "\x1b[31m"
#define COLOR_GREEN   "\x1b[32m"
#define COLOR_YELLOW  "\x1b[33m"
#define COLOR_BLUE    "\x1b[34m"
#define COLOR_RESET   "\x1b[0m"

// Informations sur les certificats volés de Stuxnet
typedef struct {
    char company[128];
    char cert_serial[64];
    char theft_date[32];
    char usage[256];
} StolenCert;

StolenCert stuxnet_certs[] = {
    {
        "Realtek Semiconductor Corp",
        "03:37:C5:2C:1D:7B:15:9C",
        "2010-01",
        "Signature des drivers mrxcls.sys et mrxnet.sys"
    },
    {
        "JMicron Technology Corp",
        "47:EB:93:D0:7B:E2:8D:DE",
        "2010-01",
        "Signature du driver jmidebs.sys"
    }
};

// Simuler le vol de certificat
void simulate_certificate_theft() {
    printf("\n%s╔════════════════════════════════════════════════════╗%s\n",
           COLOR_RED, COLOR_RESET);
    printf("%s║   PHASE 1: VOL DU CERTIFICAT                       ║%s\n",
           COLOR_RED, COLOR_RESET);
    printf("%s╚════════════════════════════════════════════════════╝%s\n\n",
           COLOR_RED, COLOR_RESET);

    printf("[*] Cible: Realtek Semiconductor Corp\n");
    printf("[*] Objectif: Voler le certificat de signature de code\n\n");

    printf("%s[Attaquant]%s Intrusion dans le réseau de Realtek...\n",
           COLOR_YELLOW, COLOR_RESET);
    sleep(1);

    printf("%s[Attaquant]%s Recherche des serveurs de signature...\n",
           COLOR_YELLOW, COLOR_RESET);
    sleep(1);

    printf("%s[Attaquant]%s Serveur de signature trouvé: 192.168.1.50\n",
           COLOR_YELLOW, COLOR_RESET);
    sleep(1);

    printf("\n[*] Extraction de la clé privée:\n");
    printf("    Fichier: realtek_codesign.pfx\n");
    printf("    Mot de passe: [RÉCUPÉRÉ VIA KEYLOGGER]\n");
    sleep(1);

    printf("\n%s[+] CERTIFICAT VOLÉ AVEC SUCCÈS!%s\n", COLOR_RED, COLOR_RESET);

    printf("\n[*] Informations du certificat:\n");
    printf("    Émetteur: VeriSign\n");
    printf("    Sujet: Realtek Semiconductor Corp\n");
    printf("    Valide jusqu'à: 2012-08-19\n");
    printf("    Numéro de série: %s\n", stuxnet_certs[0].cert_serial);
}

// Simuler la signature du malware
void simulate_malware_signing() {
    printf("\n%s╔════════════════════════════════════════════════════╗%s\n",
           COLOR_YELLOW, COLOR_RESET);
    printf("%s║   PHASE 2: SIGNATURE DU MALWARE                    ║%s\n",
           COLOR_YELLOW, COLOR_RESET);
    printf("%s╚════════════════════════════════════════════════════╝%s\n\n",
           COLOR_YELLOW, COLOR_RESET);

    printf("[*] Drivers malveillants à signer:\n");
    printf("    - mrxcls.sys (rootkit)\n");
    printf("    - mrxnet.sys (propagation)\n\n");

    printf("%s[Attaquant]%s Chargement de la clé privée Realtek...\n",
           COLOR_YELLOW, COLOR_RESET);
    sleep(1);

    printf("%s[Attaquant]%s Signature de mrxcls.sys...\n",
           COLOR_YELLOW, COLOR_RESET);

    printf("\n--- Processus de signature ---\n");
    printf("SignTool sign /f realtek_codesign.pfx \\\n");
    printf("         /p [PASSWORD] \\\n");
    printf("         /t http://timestamp.verisign.com/scripts/timstamp.dll \\\n");
    printf("         mrxcls.sys\n");

    sleep(1);

    printf("\n%sSigning succeeded%s\n", COLOR_GREEN, COLOR_RESET);
    printf("Number of files successfully Signed: 1\n");
    printf("Number of warnings: 0\n");
    printf("Number of errors: 0\n");

    printf("\n%s[+] Driver signé avec certificat légitime!%s\n",
           COLOR_RED, COLOR_RESET);
}

// Simuler le bypass de Windows
void simulate_windows_bypass() {
    printf("\n%s╔════════════════════════════════════════════════════╗%s\n",
           COLOR_BLUE, COLOR_RESET);
    printf("%s║   PHASE 3: BYPASS WINDOWS SECURITY                 ║%s\n",
           COLOR_BLUE, COLOR_RESET);
    printf("%s╚════════════════════════════════════════════════════╝%s\n\n",
           COLOR_BLUE, COLOR_RESET);

    printf("[*] Installation du driver sur machine cible...\n\n");

    printf("%s[Windows]%s Vérification de la signature du driver...\n",
           COLOR_BLUE, COLOR_RESET);
    sleep(1);

    printf("%s[Windows]%s Signature trouvée:\n", COLOR_BLUE, COLOR_RESET);
    printf("           Signataire: Realtek Semiconductor Corp\n");
    printf("           Émetteur: VeriSign Class 3 Code Signing 2010 CA\n");
    printf("           Statut: %sVALIDE%s\n", COLOR_GREEN, COLOR_RESET);
    sleep(1);

    printf("\n%s[Windows]%s Vérification de la chaîne de confiance...\n",
           COLOR_BLUE, COLOR_RESET);
    printf("%s[Windows]%s ✓ Certificat racine de confiance\n",
           COLOR_BLUE, COLOR_RESET);
    printf("%s[Windows]%s ✓ Certificat intermédiaire valide\n",
           COLOR_BLUE, COLOR_RESET);
    printf("%s[Windows]%s ✓ Certificat de signature valide\n",
           COLOR_BLUE, COLOR_RESET);
    sleep(1);

    printf("\n%s[Windows]%s %sChargement du driver autorisé!%s\n",
           COLOR_BLUE, COLOR_RESET, COLOR_GREEN, COLOR_RESET);

    printf("\n%s[!] BYPASS RÉUSSI!%s\n", COLOR_RED, COLOR_RESET);
    printf("    - Windows fait confiance au driver\n");
    printf("    - Aucune alerte pour l'utilisateur\n");
    printf("    - SmartScreen/UAC bypassed\n");
    printf("    - Driver chargé en mode kernel\n");
}

// Timeline de Stuxnet
void show_stuxnet_timeline() {
    printf("\n%s╔════════════════════════════════════════════════════╗%s\n",
           COLOR_GREEN, COLOR_RESET);
    printf("%s║   TIMELINE: STUXNET (2010)                         ║%s\n",
           COLOR_GREEN, COLOR_RESET);
    printf("%s╚════════════════════════════════════════════════════╝%s\n\n",
           COLOR_GREEN, COLOR_RESET);

    printf("%s[Janvier 2010]%s\n", COLOR_YELLOW, COLOR_RESET);
    printf("  Vol des certificats Realtek et JMicron\n\n");

    printf("%s[Juin 2010]%s\n", COLOR_YELLOW, COLOR_RESET);
    printf("  Première détection de Stuxnet en Iran\n\n");

    printf("%s[Juillet 2010]%s\n", COLOR_YELLOW, COLOR_RESET);
    printf("  Analyse par VirusBlokAda (Belarus)\n");
    printf("  Découverte des 4 zero-days Windows\n\n");

    printf("%s[Septembre 2010]%s\n", COLOR_YELLOW, COLOR_RESET);
    printf("  Symantec publie l'analyse complète\n");
    printf("  Révélation de la cible: Centrifugeuses iraniennes\n\n");

    printf("%s[Août 2010]%s\n", COLOR_YELLOW, COLOR_RESET);
    printf("  Révocation des certificats Realtek et JMicron\n\n");

    printf("%sImpact:%s\n", COLOR_RED, COLOR_RESET);
    printf("  - 60% des centrifugeuses iraniennes détruites\n");
    printf("  - 200,000+ machines infectées\n");
    printf("  - Première cyberarme confirmée (USA + Israël)\n");
    printf("  - Coût estimé: $3 millions\n");
}

// Analyser les contre-mesures
void analyze_countermeasures() {
    printf("\n%s╔════════════════════════════════════════════════════╗%s\n",
           COLOR_GREEN, COLOR_RESET);
    printf("%s║   CONTRE-MESURES                                   ║%s\n",
           COLOR_GREEN, COLOR_RESET);
    printf("%s╚════════════════════════════════════════════════════╝%s\n\n",
           COLOR_GREEN, COLOR_RESET);

    printf("1. %sPour les éditeurs de logiciels:%s\n", COLOR_BLUE, COLOR_RESET);
    printf("   - Stocker clés privées dans HSM (Hardware Security Module)\n");
    printf("   - Never store on disk or network shares\n");
    printf("   - Two-person rule pour signature\n");
    printf("   - Audit logs de toutes les signatures\n");
    printf("   - Rotation régulière des certificats\n\n");

    printf("2. %sPour les Certificate Authorities (CA):%s\n", COLOR_BLUE, COLOR_RESET);
    printf("   - Validation stricte avant émission\n");
    printf("   - Révocation rapide si compromis\n");
    printf("   - OCSP stapling (vérification en temps réel)\n");
    printf("   - Certificate Transparency logs\n\n");

    printf("3. %sPour les utilisateurs/administrateurs:%s\n", COLOR_BLUE, COLOR_RESET);
    printf("   - Vérifier signatures AVANT exécution\n");
    printf("   - Whitelist de signataires de confiance\n");
    printf("   - Monitoring des certificats révoqués\n");
    printf("   - Application whitelisting (pas juste signature)\n");
    printf("   - EDR/XDR pour behavioral analysis\n\n");

    printf("4. %sTechnologies de protection:%s\n", COLOR_BLUE, COLOR_RESET);
    printf("   - Windows Defender Application Control (WDAC)\n");
    printf("   - macOS Gatekeeper + Notarization\n");
    printf("   - Linux kernel module signing\n");
    printf("   - EV Code Signing (validation étendue)\n");
}

int main() {
    printf("%s", COLOR_BLUE);
    printf("╔══════════════════════════════════════════════════════╗\n");
    printf("║                                                      ║\n");
    printf("║    STUXNET ATTACK SIMULATOR                         ║\n");
    printf("║    Signed Malware Case Study                        ║\n");
    printf("║                                                      ║\n");
    printf("║    À des fins éducatives uniquement                 ║\n");
    printf("║                                                      ║\n");
    printf("╚══════════════════════════════════════════════════════╝\n");
    printf("%s\n", COLOR_RESET);

    printf("Cette simulation démontre comment Stuxnet (2010) a utilisé\n");
    printf("des certificats de signature de code VOLÉS pour bypasser\n");
    printf("les protections de Windows.\n");

    printf("\n%s[!] AVERTISSEMENT:%s Activité illégale dans la vie réelle!\n",
           COLOR_RED, COLOR_RESET);

    printf("\nAppuyez sur Entrée pour continuer...");
    getchar();

    simulate_certificate_theft();

    printf("\n\nAppuyez sur Entrée pour continuer...");
    getchar();

    simulate_malware_signing();

    printf("\n\nAppuyez sur Entrée pour continuer...");
    getchar();

    simulate_windows_bypass();

    printf("\n\nAppuyez sur Entrée pour continuer...");
    getchar();

    show_stuxnet_timeline();

    printf("\n\nAppuyez sur Entrée pour voir les contre-mesures...");
    getchar();

    analyze_countermeasures();

    return 0;
}
```

**Compilation et exécution** :
```bash
gcc stuxnet_sim.c -o stuxnet_sim
./stuxnet_sim
```

**Critères de réussite** :
- Simulation complète de l'attaque Stuxnet
- Explication du bypass Windows
- Timeline historique
- Contre-mesures détaillées

---

## Exercice 4 : Outil de détection de certificats suspects (Difficile)

**Objectif** : Créer un système de détection de binaires signés avec des certificats compromis

**Solution** :

```c
/*
 * Malicious Certificate Detector
 * Détecte les binaires signés avec des certificats compromis ou suspects
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <time.h>

#define MAX_CERTS 1000
#define COLOR_RED     "\x1b[31m"
#define COLOR_YELLOW  "\x1b[33m"
#define COLOR_GREEN   "\x1b[32m"
#define COLOR_RESET   "\x1b[0m"

// Base de données de certificats compromis
typedef struct {
    char serial[128];
    char issuer[256];
    char reason[256];
    char threat[64];  // Stuxnet, Flame, etc.
} CompromisedCert;

CompromisedCert known_threats[] = {
    {
        "03:37:C5:2C:1D:7B:15:9C",
        "Realtek Semiconductor Corp",
        "Utilisé dans Stuxnet",
        "Stuxnet"
    },
    {
        "47:EB:93:D0:7B:E2:8D:DE",
        "JMicron Technology Corp",
        "Utilisé dans Stuxnet",
        "Stuxnet"
    },
    {
        "00:92:BB:FE:FE:AE:A4:1A",
        "Terminal Server Licensing",
        "Utilisé dans Flame",
        "Flame"
    },
    {NULL, NULL, NULL, NULL}
};

// Scanner un répertoire pour les binaires signés
void scan_directory_for_signed_files(const char* path) {
    DIR* dir = opendir(path);
    if (!dir) {
        printf("[-] Impossible d'ouvrir: %s\n", path);
        return;
    }

    printf("\n[*] Scan de: %s\n", path);
    printf("==========================================\n");

    struct dirent* entry;
    int total_files = 0;
    int signed_files = 0;
    int suspicious_files = 0;

    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_name[0] == '.') continue;

        char filepath[1024];
        snprintf(filepath, sizeof(filepath), "%s/%s", path, entry->d_name);

        struct stat st;
        if (stat(filepath, &st) != 0) continue;

        // Ignorer les répertoires
        if (S_ISDIR(st.st_mode)) continue;

        total_files++;

        // Vérifier si c'est un PE (Windows executable)
        FILE* f = fopen(filepath, "rb");
        if (!f) continue;

        unsigned char magic[2];
        fread(magic, 1, 2, f);
        fclose(f);

        if (magic[0] != 'M' || magic[1] != 'Z') continue;  // Pas un PE

        // Vérifier la signature
        char cmd[1024];
        snprintf(cmd, sizeof(cmd),
                 "osslsigncode verify %s 2>&1 | grep -i 'serial\\|signer'",
                 filepath);

        FILE* fp = popen(cmd, "r");
        if (!fp) continue;

        char line[512];
        char serial[128] = {0};
        char signer[256] = {0};

        while (fgets(line, sizeof(line), fp)) {
            if (strstr(line, "Serial:")) {
                sscanf(line, "Serial: %s", serial);
            } else if (strstr(line, "Signer:")) {
                sscanf(line, "Signer: %[^\n]", signer);
            }
        }

        pclose(fp);

        if (strlen(serial) > 0) {
            signed_files++;

            // Vérifier si le certificat est compromis
            int is_compromised = 0;
            const char* threat_name = NULL;

            for (int i = 0; known_threats[i].serial != NULL; i++) {
                if (strcasecmp(serial, known_threats[i].serial) == 0) {
                    is_compromised = 1;
                    threat_name = known_threats[i].threat;
                    break;
                }
            }

            if (is_compromised) {
                suspicious_files++;
                printf("%s[!] ALERTE: %s%s\n", COLOR_RED, filepath, COLOR_RESET);
                printf("    Serial: %s\n", serial);
                printf("    Signer: %s\n", signer);
                printf("    Menace: %s\n", threat_name);
                printf("\n");
            }
        }
    }

    closedir(dir);

    printf("\n[*] Résumé du scan:\n");
    printf("    Total fichiers: %d\n", total_files);
    printf("    Fichiers signés: %d\n", signed_files);
    printf("    %sFichiers suspects: %d%s\n",
           suspicious_files > 0 ? COLOR_RED : COLOR_GREEN,
           suspicious_files,
           COLOR_RESET);
}

// Vérifier un fichier spécifique
void check_single_file(const char* filename) {
    printf("\n[*] Analyse de: %s\n", filename);
    printf("==========================================\n");

    // Extraire les infos de signature
    char cmd[512];
    snprintf(cmd, sizeof(cmd), "osslsigncode verify %s 2>&1", filename);

    FILE* fp = popen(cmd, "r");
    if (!fp) {
        printf("[-] Erreur lors de la vérification\n");
        return;
    }

    char line[512];
    char serial[128] = {0};
    char signer[256] = {0};
    char issuer[256] = {0};

    printf("\n%s[*] Informations de signature:%s\n", COLOR_BLUE, COLOR_RESET);

    while (fgets(line, sizeof(line), fp)) {
        printf("%s", line);

        if (strstr(line, "Serial:")) {
            sscanf(line, "Serial: %s", serial);
        } else if (strstr(line, "Signer:")) {
            sscanf(line, "Signer: %[^\n]", signer);
        } else if (strstr(line, "Issuer:")) {
            sscanf(line, "Issuer: %[^\n]", issuer);
        }
    }

    pclose(fp);

    // Vérifier contre la base de données
    printf("\n%s[*] Vérification contre base de menaces connues:%s\n",
           COLOR_YELLOW, COLOR_RESET);

    int is_threat = 0;

    for (int i = 0; known_threats[i].serial != NULL; i++) {
        if (strlen(serial) > 0 &&
            strcasecmp(serial, known_threats[i].serial) == 0) {
            printf("\n%s╔════════════════════════════════════════════════════╗%s\n",
                   COLOR_RED, COLOR_RESET);
            printf("%s║   MENACE DÉTECTÉE!                                 ║%s\n",
                   COLOR_RED, COLOR_RESET);
            printf("%s╚════════════════════════════════════════════════════╝%s\n\n",
                   COLOR_RED, COLOR_RESET);

            printf("Menace: %s\n", known_threats[i].threat);
            printf("Raison: %s\n", known_threats[i].reason);
            printf("\n%s[!] NE PAS EXÉCUTER CE FICHIER!%s\n",
                   COLOR_RED, COLOR_RESET);
            is_threat = 1;
            break;
        }
    }

    if (!is_threat) {
        printf("%s[+] Certificat non présent dans la base de menaces%s\n",
               COLOR_GREEN, COLOR_RESET);
        printf("\nNote: Cela ne garantit pas que le fichier est sûr.\n");
        printf("      Toujours effectuer une analyse complète.\n");
    }

    // Recommandations
    printf("\n%s[*] Recommandations:%s\n", COLOR_YELLOW, COLOR_RESET);
    printf("  1. Scanner avec antivirus (ClamAV, etc.)\n");
    printf("  2. Vérifier sur VirusTotal: virustotal.com\n");
    printf("  3. Analyser dans un sandbox\n");
    printf("  4. Vérifier la réputation du signataire\n");
    printf("  5. Vérifier si le certificat est révoqué (CRL/OCSP)\n");
}

// Générer un rapport
void generate_threat_report() {
    printf("\n%s╔════════════════════════════════════════════════════╗%s\n",
           COLOR_BLUE, COLOR_RESET);
    printf("%s║   BASE DE DONNÉES: CERTIFICATS COMPROMIS          ║%s\n",
           COLOR_BLUE, COLOR_RESET);
    printf("%s╚════════════════════════════════════════════════════╝%s\n\n",
           COLOR_BLUE, COLOR_RESET);

    printf("%-40s %-20s %-15s\n", "Émetteur", "Menace", "Numéro série");
    printf("─────────────────────────────────────────────────────────────────────────\n");

    for (int i = 0; known_threats[i].serial != NULL; i++) {
        printf("%-40s %-20s %s\n",
               known_threats[i].issuer,
               known_threats[i].threat,
               known_threats[i].serial);
        printf("  → %s\n\n", known_threats[i].reason);
    }

    printf("Sources:\n");
    printf("  - Symantec Threat Intelligence\n");
    printf("  - Microsoft Security Response Center\n");
    printf("  - Public CRL (Certificate Revocation Lists)\n");
}

int main(int argc, char* argv[]) {
    printf("[*] Malicious Certificate Detector\n");
    printf("[*] ==========================================\n");

    if (argc < 2) {
        printf("\nUsage:\n");
        printf("  %s <fichier>           - Vérifier un fichier\n", argv[0]);
        printf("  %s --scan <répertoire> - Scanner un répertoire\n", argv[0]);
        printf("  %s --list              - Liste des certificats compromis\n", argv[0]);
        return 1;
    }

    if (strcmp(argv[1], "--list") == 0) {
        generate_threat_report();
    } else if (strcmp(argv[1], "--scan") == 0) {
        if (argc < 3) {
            printf("[-] Spécifier un répertoire à scanner\n");
            return 1;
        }
        scan_directory_for_signed_files(argv[2]);
    } else {
        check_single_file(argv[1]);
    }

    return 0;
}
```

**Compilation** :
```bash
gcc malicious_cert_detector.c -o malicious_cert_detector
```

**Usage** :
```bash
# Vérifier un fichier
./malicious_cert_detector suspicious.exe

# Scanner un répertoire
./malicious_cert_detector --scan /path/to/binaries

# Liste des certificats compromis
./malicious_cert_detector --list
```

**Bonus - Script de monitoring** :

```bash
#!/bin/bash
# Continuous Certificate Monitoring

LOG_FILE="/var/log/cert_monitor.log"
SCAN_DIR="/usr/bin"

echo "[*] Certificate Monitoring Service"
echo "=========================================="

while true; do
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    echo "[$timestamp] Scan en cours..." | tee -a "$LOG_FILE"

    # Scanner tous les binaires
    find "$SCAN_DIR" -type f -executable | while read file; do
        # Vérifier signature
        if osslsigncode verify "$file" 2>&1 | grep -q "03:37:C5:2C:1D:7B:15:9C"; then
            echo "[$timestamp] ALERT: Stuxnet cert detected in $file" | tee -a "$LOG_FILE"
            # Envoyer alerte
            mail -s "SECURITY ALERT: Malicious Certificate" admin@company.com < "$LOG_FILE"
        fi
    done

    # Attendre 1 heure
    sleep 3600
done
```

---

## Auto-évaluation

Avant de passer au module suivant, vérifiez que vous pouvez :
- [ ] Expliquer comment fonctionne la signature de code
- [ ] Vérifier l'authenticité d'une signature
- [ ] Comprendre l'attaque Stuxnet
- [ ] Détecter des certificats compromis
- [ ] Implémenter des contre-mesures (HSM, monitoring)

## Notes importantes

- **Stuxnet (2010)** : Premier cas confirmé de certificats volés pour malware étatique
- **Flame (2012)** : Certificat frauduleux émis par CA compromise
- **Impact** : Une signature valide ne garantit PAS que le code est sûr
- **Protection** : HSM, two-person rule, certificate transparency, monitoring
